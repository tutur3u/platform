---
title: '@tuturuuu/masonry'
description: 'A lightweight, responsive masonry grid component for React applications'
updatedAt: '2025-11-07'
---

## Overview

The `@tuturuuu/masonry` package provides a Pinterest-style masonry grid component for React. It offers two distribution strategies: a fast count-based approach for uniform content, and an intelligent height-based balancing algorithm that progressively optimizes layout as content loads - with zero hidden measurement phase.

## Installation

<CodeGroup>

```bash npm
npm install @tuturuuu/masonry
```

```bash yarn
yarn add @tuturuuu/masonry
```

```bash pnpm
pnpm add @tuturuuu/masonry
```

```bash bun
bun add @tuturuuu/masonry
```

</CodeGroup>

## Features

- üé® **Pinterest-style Layout**: Creates beautiful masonry grids with balanced columns
- üì± **Responsive Design**: Automatically adjusts columns based on viewport width
- ‚öñÔ∏è **Smart Distribution**: Two strategies - fast count-based or height-balanced
- üñºÔ∏è **Progressive Image Loading**: Visible-first rendering with background optimization for image galleries
- üéØ **TypeScript Support**: Fully typed with TypeScript
- ‚ö° **Lightweight**: Zero external dependencies besides React
- üîß **Customizable**: Flexible column, gap, and breakpoint configuration
- ‚ö° **Zero Layout Shift**: Items render immediately, no hidden measurement phase

## Basic Usage

```tsx
import { Masonry } from '@tuturuuu/masonry';

export function Gallery() {
  return (
    <Masonry columns={3} gap={16}>
      <div>Item 1</div>
      <div>Item 2</div>
      <div>Item 3</div>
      <div>Item 4</div>
    </Masonry>
  );
}
```

## API Reference

### Props

<ResponseField name="children" type="ReactNode[]" required>
  Array of React elements to display in the masonry grid. Each child will be distributed across columns using the shortest-column algorithm.
</ResponseField>

<ResponseField name="columns" type="number" default={3}>
  Default number of columns to display. This will be overridden by breakpoint configurations if the viewport matches a defined breakpoint.
</ResponseField>

<ResponseField name="gap" type="number" default={16}>
  Gap between items in pixels. This applies both horizontally (between columns) and vertically (between items within a column).
</ResponseField>

<ResponseField name="breakpoints" type="object" default={{ 640: 1, 768: 2, 1024: 3, 1280: 4 }}>
  Responsive breakpoint configuration. Keys are viewport widths in pixels, values are the number of columns to display at or above that width.
  
  Default breakpoints:
  - `640px`: 1 column (mobile)
  - `768px`: 2 columns (tablet)
  - `1024px`: 3 columns (desktop)
  - `1280px`: 4 columns (large desktop)
</ResponseField>

<ResponseField name="className" type="string" default="">
  Additional CSS classes to apply to the masonry container element.
</ResponseField>

<ResponseField name="strategy" type="'balanced' | 'count'" default="count">
  Strategy for distributing items across columns:
  
  - `'count'` (default): Distributes items based on item count. Faster with no layout shift, but may result in uneven column heights when items have varying heights.
  - `'balanced'`: Distributes items based on actual measured heights for better visual balance. May cause a brief initial layout shift as heights are measured, but results in more evenly balanced column heights.
  
  Use `'balanced'` when visual balance is critical (e.g., image galleries with varying aspect ratios). Use `'count'` for better performance and no layout shift.
</ResponseField>

## Examples

### Image Gallery

```tsx
import { Masonry } from '@tuturuuu/masonry';

interface Image {
  id: number;
  url: string;
  title: string;
}

export function ImageGallery({ images }: { images: Image[] }) {
  return (
    <Masonry
      columns={4}
      gap={12}
      breakpoints={{
        640: 1,
        768: 2,
        1024: 3,
        1280: 4,
      }}
    >
      {images.map((image) => (
        <div key={image.id} className="overflow-hidden rounded-lg">
          <img
            src={image.url}
            alt={image.title}
            className="h-auto w-full"
          />
        </div>
      ))}
    </Masonry>
  );
}
```

### Card Grid

```tsx
import { Masonry } from '@tuturuuu/masonry';

interface CardProps {
  title: string;
  description: string;
  image?: string;
}

export function CardGrid({ cards }: { cards: CardProps[] }) {
  return (
    <Masonry columns={3} gap={20} className="my-8">
      {cards.map((card, index) => (
        <div
          key={index}
          className="rounded-lg bg-white p-6 shadow-lg dark:bg-gray-800"
        >
          {card.image && (
            <img
              src={card.image}
              alt={card.title}
              className="mb-4 h-auto w-full rounded"
            />
          )}
          <h3 className="mb-2 text-xl font-bold">{card.title}</h3>
          <p className="text-gray-600 dark:text-gray-300">
            {card.description}
          </p>
        </div>
      ))}
    </Masonry>
  );
}
```

### Custom Breakpoints

```tsx
import { Masonry } from '@tuturuuu/masonry';

export function CustomBreakpointGallery() {
  return (
    <Masonry
      columns={5}
      gap={24}
      breakpoints={{
        480: 1,    // Extra small screens
        768: 2,    // Small screens
        1024: 3,   // Medium screens
        1440: 4,   // Large screens
        1920: 5,   // Extra large screens
      }}
    >
      {items.map((item) => (
        <div key={item.id}>{item.content}</div>
      ))}
    </Masonry>
  );
}
```

### Without Breakpoints

To use a fixed number of columns regardless of viewport width, pass an empty breakpoints object:

```tsx
import { Masonry } from '@tuturuuu/masonry';

export function FixedColumnGrid() {
  return (
    <Masonry columns={4} gap={16} breakpoints={{}}>
      {items.map((item) => (
        <div key={item.id}>{item.content}</div>
      ))}
    </Masonry>
  );
}
```

### Balanced vs Count Strategy

Choose between fast count-based distribution or height-based balancing:

```tsx
import { Masonry } from '@tuturuuu/masonry';

// Count-based (default) - Fast, no layout shift
export function CountBasedGallery() {
  return (
    <Masonry columns={3} gap={16} strategy="count">
      {items.map((item) => (
        <div key={item.id} style={{ height: item.height }}>
          {item.content}
        </div>
      ))}
    </Masonry>
  );
}

// Height-based - Better visual balance for varying heights
export function BalancedGallery() {
  return (
    <Masonry columns={3} gap={16} strategy="balanced">
      {items.map((item) => (
        <div key={item.id} style={{ height: item.height }}>
          {item.content}
        </div>
      ))}
    </Masonry>
  );
}
```

The `balanced` strategy is particularly useful for image galleries where images have varying aspect ratios, while `count` works well for uniform content like cards or tiles.

## How It Works

The masonry component uses a **shortest-column algorithm** to distribute items:

1. **Responsive Breakpoints**: Determines the number of columns based on container width
2. **Distribution Strategy**:
   - **Count-based** (default): Places each item in the column with the fewest items, rotating through equal columns
   - **Height-based** (`strategy="balanced"`): Measures actual item heights using ResizeObserver and places each item in the shortest column
3. **CSS Grid Layout**: Uses native CSS Grid with auto-flow dense for optimal rendering
4. **Even Distribution**: Ensures items are distributed evenly across columns with no stacking bias

The height-based strategy provides better visual balance for items with varying heights, while the count-based strategy is faster and avoids layout shift.

## Performance Considerations

- **Count Strategy (Default)**: Lightweight and fast. No height measurements, no layout shift. Ideal for most use cases.
- **Balanced Strategy**: Uses ResizeObserver to measure heights. Slightly more overhead and may cause initial layout shift, but provides better visual balance for varying item sizes.
- **Responsive**: Automatically adjusts columns based on container width
- **CSS Grid**: Leverages native browser optimizations
- **No JavaScript Layout**: Distribution logic runs once, then pure CSS handles rendering

For best performance with many items or frequent updates, use the default `strategy="count"`. Use `strategy="balanced"` when visual balance is more important than avoiding layout shift.

## Styling

The component uses inline styles for core layout functionality and accepts a `className` prop for custom styling:

```tsx
<Masonry
  columns={3}
  gap={16}
  className="mx-auto max-w-7xl px-4"
>
  {items.map((item) => (
    <div
      key={item.id}
      className="rounded-lg bg-gradient-to-br from-blue-500 to-purple-600 p-4"
    >
      {item.content}
    </div>
  ))}
</Masonry>
```

## Best Practices

<AccordionGroup>
  <Accordion title="Use consistent item widths">
    For best results, ensure all items have the same width. The masonry layout handles varying heights automatically, but varying widths can break the grid.
  </Accordion>

  <Accordion title="Set appropriate gap values">
    Choose gap values that match your design system. Common values are 8px, 12px, 16px, or 24px.
  </Accordion>

  <Accordion title="Configure breakpoints thoughtfully">
    Consider your content and screen sizes. More columns work well for small items (like thumbnails), while fewer columns suit larger content cards.
  </Accordion>

  <Accordion title="Use keys properly">
    Always provide unique `key` props to direct children of Masonry to ensure proper React reconciliation.
  </Accordion>

  <Accordion title="Choose the right distribution strategy">
    - Use `strategy="count"` (default) for best performance with uniform or near-uniform content. Zero layout shift, instant rendering.
    - Use `strategy="balanced"` for image galleries or content with varying heights. Renders immediately with count-based distribution, then progressively optimizes to height-balanced layout as images load. No hidden measurement phase - content is visible from first render.
  </Accordion>

  <Accordion title="Optimize images for progressive loading">
    When using `strategy="balanced"` with images:
    - Items render immediately using count-based distribution
    - As images load, the layout progressively rebalances every 100ms
    - Final balanced distribution achieved once all images complete loading
    - No flash or hidden content - smooth progressive enhancement
  </Accordion>
</AccordionGroup>

## How Balanced Strategy Works

The `strategy="balanced"` mode uses a sophisticated progressive loading approach optimized for image galleries:

1. **Immediate Render**: Items appear instantly using fast count-based distribution
2. **Background Measurement**: Heights are measured without hiding content  
3. **Progressive Optimization**: Every 100ms, layout redistributes based on current measurements
4. **Image Load Tracking**: Monitors image loading progress and updates heights dynamically
5. **Final Balance**: Once all images load, achieves optimal height-balanced distribution

This approach provides:
- ‚úÖ Fast initial render - no waiting for measurements
- ‚úÖ Smooth progressive improvement - no layout jumps
- ‚úÖ Optimal final balance - equal column heights
- ‚úÖ No hidden content phase - everything visible immediately

## Performance Considerations

- The component uses React state and effects efficiently
- Resize events are properly debounced through React's rendering cycle  
- Count strategy: No DOM measurements, instant rendering
- Balanced strategy: Minimal background measurements (100ms intervals), no render blocking
- Progressive redistribution only runs while images are loading
- Minimal re-renders when breakpoints change

## TypeScript

The package is written in TypeScript and exports all necessary types:

```tsx
import { Masonry } from '@tuturuuu/masonry';
import type { ReactNode } from 'react';

interface MasonryProps {
  children: ReactNode[];
  columns?: number;
  gap?: number;
  breakpoints?: {
    [key: number]: number;
  };
  className?: string;
  strategy?: 'balanced' | 'count';
}
```

## Accessibility

The masonry component renders semantic HTML and preserves the DOM order of items. Screen readers will encounter items in the order they appear in the `children` array, not in their visual column order.

For improved accessibility:
- Ensure items have proper semantic markup
- Use ARIA labels where appropriate
- Maintain logical tab order in interactive elements

## Browser Support

The package supports all modern browsers that support:
- React 19+
- CSS Flexbox
- ES2015+ JavaScript features

## Troubleshooting

<AccordionGroup>
  <Accordion title="Columns are uneven in height">
    With the default `strategy="count"`, this is expected behavior. The algorithm balances by item count, not pixel height. 
    
    For better visual balance with varying item heights, use `strategy="balanced"` which measures actual heights and distributes items to achieve equal column heights.
  </Accordion>

  <Accordion title="Breakpoints not working">
    Ensure you're passing an object with numeric keys. The component checks `window.innerWidth`, so it won't work in SSR without hydration.
  </Accordion>

  <Accordion title="Items not appearing">
    Make sure you're passing an array of valid React elements to the `children` prop. Check console for any React warnings.
  </Accordion>

  <Accordion title="Unexpected column count">
    If you see 3 columns when expecting a different number, check that you've either:
    - Passed a custom `columns` prop, or
    - Passed an empty `breakpoints={{}}` object to disable responsive behavior
  </Accordion>

  <Accordion title="Images taking time to balance">
    This is expected with `strategy="balanced"`. The component:
    - Renders items immediately using count-based distribution
    - Progressively rebalances every 100ms as images load
    - Achieves final optimal balance once all images complete
    - Automatically stops updating once all images are loaded
    
    If instant rendering is more important than perfect balance, use `strategy="count"` (default).
  </Accordion>

  <Accordion title="Component keeps re-rendering">
    This should not happen in v0.1.5+. If you're experiencing infinite rendering:
    - Ensure you're using the latest version (`bun add @tuturuuu/masonry@latest`)
    - Check that children array is stable (use proper keys and avoid recreating on each render)
    - Verify images have proper `src` attributes
    
    The component automatically stops measuring and redistributing once all images are loaded.
  </Accordion>
</AccordionGroup>

## Related Packages

- [`@tuturuuu/ui`](/reference/packages/ui) - Complete UI component library
- [`@tuturuuu/utils`](/reference/packages/utils) - Utility functions and helpers

## Source Code

The package is open source and available on GitHub:

- [View on GitHub](https://github.com/tutur3u/platform/tree/main/packages/masonry)
- [Report Issues](https://github.com/tutur3u/platform/issues)

## Changelog

### 0.1.5 (Current)
- **Fixed infinite rendering issue**: Proper cleanup of measurement intervals
- Removed problematic component remounting from key prop changes
- Improved lifecycle management with better effect dependencies
- Stable rendering once all images are loaded

### 0.1.4
- **Visible-first rendering**: Removed hidden measurement phase
- Items now appear immediately - no more delayed visibility
- Background measurement and progressive optimization
- Zero layout shift with count strategy, smooth progressive improvement with balanced

### 0.1.3
- **Optimized progressive loading**: Periodic redistribution every 100ms while images load
- Smooth, continuous layout improvements as images become available
- Final perfect distribution after all images are fully loaded
- Better visual experience with gradual optimization instead of sudden changes
- Eliminates janky single-redistribution in favor of smooth progressive refinement

### 0.1.2
- **Progressive image loading**: Distribution now recalculates as each image loads instead of waiting for all
- Smoother user experience with incremental layout improvements
- Better handling of mixed content (images and non-image items)
- Eliminates long wait times for image-heavy galleries

### 0.1.1
- **Fixed image support in balanced strategy**: Now waits for all images to load before measuring heights
- Handles both loaded and unloaded images gracefully
- Prevents measurement of images before they have dimensions
- Improved reliability for image galleries with `strategy="balanced"`

### 0.1.0
- **STABLE RELEASE**: Production-ready masonry grid component
- Fixed infinite rendering loop in balanced strategy
- Implemented proper two-phase measurement approach for balanced distribution
- Fixed column distribution to properly rotate through equal-height columns
- Improved visual balance with varying item heights (100+ items tested)
- Balanced strategy now uses hidden measurement phase for accurate height calculations
- Performance optimizations: measurement happens once, distribution is stable

### 0.0.4
- Added `strategy` prop with `'count'` and `'balanced'` modes
- `'balanced'` mode uses ResizeObserver to measure heights for better visual balance
- `'count'` mode (default) provides best performance with no layout shift

### 0.0.3
- Fixed unbalanced column distribution using shortest-column algorithm
- Improved visual balance across all column heights

### 0.0.2
- Added build configuration for proper module distribution
- Published compiled JavaScript and TypeScript declarations

### 0.0.1
- Initial release with basic masonry layout functionality
