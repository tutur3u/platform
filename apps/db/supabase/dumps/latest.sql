SET
  statement_timeout = 0;

SET
  lock_timeout = 0;

SET
  idle_in_transaction_session_timeout = 0;

SET
  client_encoding = 'UTF8';

SET
  standard_conforming_strings = on;

SELECT
  pg_catalog.set_config('search_path', '', false);

SET
  check_function_bodies = false;

SET
  xmloption = content;

SET
  client_min_messages = warning;

SET
  row_security = off;

CREATE SCHEMA IF NOT EXISTS "audit";

ALTER SCHEMA "audit" OWNER TO "postgres";

CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";

CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";

ALTER SCHEMA "public" OWNER TO "postgres";

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE EXTENSION IF NOT EXISTS "citext" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA "public";

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "vector" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "wrappers" WITH SCHEMA "extensions";

CREATE TYPE "audit"."operation" AS ENUM (
  'INSERT',
  'UPDATE',
  'DELETE',
  'TRUNCATE'
);

ALTER TYPE "audit"."operation" OWNER TO "postgres";

CREATE TYPE "public"."abuse_event_type" AS ENUM (
  'otp_send',
  'otp_verify_failed',
  'mfa_challenge',
  'mfa_verify_failed',
  'reauth_send',
  'reauth_verify_failed',
  'password_login_failed',
  'manual'
);

ALTER TYPE "public"."abuse_event_type" OWNER TO "postgres";

CREATE TYPE "public"."ai_message_type" AS ENUM (
  'message',
  'file',
  'summary',
  'notes',
  'multi_choice_quiz',
  'paragraph_quiz',
  'flashcards'
);

ALTER TYPE "public"."ai_message_type" OWNER TO "postgres";

CREATE TYPE "public"."billing_reason" AS ENUM (
  'purchase',
  'subscription_create',
  'subscription_cycle',
  'subscription_update'
);

ALTER TYPE "public"."billing_reason" OWNER TO "postgres";

CREATE TYPE "public"."blacklist_entry_type" AS ENUM ('email', 'domain');

ALTER TYPE "public"."blacklist_entry_type" OWNER TO "postgres";

CREATE TYPE "public"."calendar_hour_type" AS ENUM ('WORK', 'PERSONAL', 'MEETING');

ALTER TYPE "public"."calendar_hour_type" OWNER TO "postgres";

CREATE TYPE "public"."calendar_hours" AS ENUM (
  'work_hours',
  'personal_hours',
  'meeting_hours'
);

ALTER TYPE "public"."calendar_hours" OWNER TO "postgres";

CREATE TYPE "public"."calendar_provider" AS ENUM ('tuturuuu', 'google', 'microsoft');

ALTER TYPE "public"."calendar_provider" OWNER TO "postgres";

CREATE TYPE "public"."calendar_scheduling_source" AS ENUM ('manual', 'task', 'habit');

ALTER TYPE "public"."calendar_scheduling_source" OWNER TO "postgres";

CREATE TYPE "public"."certificate_templates" AS ENUM ('original', 'modern', 'elegant');

ALTER TYPE "public"."certificate_templates" OWNER TO "postgres";

CREATE TYPE "public"."chat_role" AS ENUM (
  'FUNCTION',
  'USER',
  'SYSTEM',
  'ASSISTANT'
);

ALTER TYPE "public"."chat_role" OWNER TO "postgres";

CREATE TYPE "public"."dataset_type" AS ENUM ('excel', 'csv', 'html');

ALTER TYPE "public"."dataset_type" OWNER TO "postgres";

CREATE TYPE "public"."email_block_status" AS (
  "email" "text",
  "is_blocked" boolean,
  "reason" "text"
);

ALTER TYPE "public"."email_block_status" OWNER TO "postgres";

CREATE TYPE "public"."estimation_type" AS ENUM (
  'exponential',
  'fibonacci',
  'linear',
  't-shirt'
);

ALTER TYPE "public"."estimation_type" OWNER TO "postgres";

CREATE TYPE "public"."feature_flag" AS ENUM (
  'ENABLE_AI',
  'ENABLE_EDUCATION',
  'ENABLE_CHALLENGES',
  'ENABLE_QUIZZES'
);

ALTER TYPE "public"."feature_flag" OWNER TO "postgres";

CREATE TYPE "public"."habit_frequency" AS ENUM (
  'daily',
  'weekly',
  'monthly',
  'yearly',
  'custom'
);

ALTER TYPE "public"."habit_frequency" OWNER TO "postgres";

CREATE TYPE "public"."ip_block_status" AS ENUM (
  'active',
  'expired',
  'manually_unblocked'
);

ALTER TYPE "public"."ip_block_status" OWNER TO "postgres";

CREATE TYPE "public"."monthly_recurrence_type" AS ENUM ('day_of_month', 'day_of_week');

ALTER TYPE "public"."monthly_recurrence_type" OWNER TO "postgres";

CREATE TYPE "public"."notification_delivery_mode" AS ENUM ('immediate', 'batched');

ALTER TYPE "public"."notification_delivery_mode" OWNER TO "postgres";

COMMENT ON TYPE "public"."notification_delivery_mode" IS 'Delivery mode for notification emails: immediate (sent right away) or batched (grouped in digest)';

CREATE TYPE "public"."notification_priority" AS ENUM (
  'low',
  'medium',
  'high',
  'urgent'
);

ALTER TYPE "public"."notification_priority" OWNER TO "postgres";

COMMENT ON TYPE "public"."notification_priority" IS 'Notification priority: low, medium, high, urgent';

CREATE TYPE "public"."notification_scope" AS ENUM ('user', 'workspace', 'system');

ALTER TYPE "public"."notification_scope" OWNER TO "postgres";

COMMENT ON TYPE "public"."notification_scope" IS 'Notification scope: user (personal), workspace (workspace-specific), system (platform-wide)';

CREATE TYPE "public"."order_status" AS ENUM (
  'pending',
  'paid',
  'refunded',
  'partially_refunded'
);

ALTER TYPE "public"."order_status" OWNER TO "postgres";

CREATE TYPE "public"."platform_service" AS ENUM (
  'TUTURUUU',
  'REWISE',
  'NOVA',
  'UPSKII'
);

ALTER TYPE "public"."platform_service" OWNER TO "postgres";

CREATE TYPE "public"."product" AS ENUM (
  'web',
  'nova',
  'rewise',
  'calendar',
  'finance',
  'tudo',
  'tumeet',
  'shortener',
  'qr',
  'drive',
  'mail',
  'other'
);

ALTER TYPE "public"."product" OWNER TO "postgres";

CREATE TYPE "public"."promotion_type" AS ENUM ('REGULAR', 'REFERRAL');

ALTER TYPE "public"."promotion_type" OWNER TO "postgres";

CREATE TYPE "public"."recording_status" AS ENUM (
  'recording',
  'interrupted',
  'pending_transcription',
  'transcribing',
  'completed',
  'failed'
);

ALTER TYPE "public"."recording_status" OWNER TO "postgres";

CREATE TYPE "public"."recurring_frequency" AS ENUM (
  'daily',
  'weekly',
  'monthly',
  'yearly'
);

ALTER TYPE "public"."recurring_frequency" OWNER TO "postgres";

CREATE TYPE "public"."subscription_status" AS ENUM (
  'incomplete',
  'incomplete_expired',
  'trialing',
  'active',
  'past_due',
  'canceled',
  'unpaid'
);

ALTER TYPE "public"."subscription_status" OWNER TO "postgres";

CREATE TYPE "public"."support_type" AS ENUM (
  'bug',
  'feature-request',
  'support',
  'job-application'
);

ALTER TYPE "public"."support_type" OWNER TO "postgres";

CREATE TYPE "public"."task_board_status" AS ENUM (
  'not_started',
  'active',
  'done',
  'closed',
  'documents'
);

ALTER TYPE "public"."task_board_status" OWNER TO "postgres";

COMMENT ON TYPE "public"."task_board_status" IS 'Task list status types: not_started (Backlog), active (Active), done (Done), closed (Closed), documents (Reference materials without completion tracking)';

CREATE TYPE "public"."task_priority" AS ENUM (
  'low',
  'normal',
  'high',
  'critical'
);

ALTER TYPE "public"."task_priority" OWNER TO "postgres";

CREATE TYPE "public"."task_relationship_type" AS ENUM (
  'parent_child',
  'blocks',
  'related'
);

ALTER TYPE "public"."task_relationship_type" OWNER TO "postgres";

CREATE TYPE "public"."time_of_day_preference" AS ENUM (
  'morning',
  'afternoon',
  'evening',
  'night'
);

ALTER TYPE "public"."time_of_day_preference" OWNER TO "postgres";

CREATE TYPE "public"."time_tracking_request_status" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

ALTER TYPE "public"."time_tracking_request_status" OWNER TO "postgres";

CREATE TYPE "public"."workspace_api_key_scope" AS ENUM (
  'gemini-2.0-flash',
  'gemini-2.5-flash',
  'gemini-2.0-pro',
  'gemini-2.5-pro',
  'gemini-2.0-flash-lite',
  'gemini-2.5-flash-lite'
);

ALTER TYPE "public"."workspace_api_key_scope" OWNER TO "postgres";

CREATE TYPE "public"."workspace_board_icon" AS ENUM (
  'Users',
  'User',
  'Briefcase',
  'Target',
  'Rocket',
  'TrendingUp',
  'ClipboardList',
  'ListChecks',
  'CheckSquare',
  'Calendar',
  'CalendarDays',
  'CalendarCheck',
  'Clock',
  'AlarmClock',
  'Bell',
  'Star',
  'Settings',
  'Shield',
  'Tag',
  'Folder',
  'FolderOpen',
  'FileText',
  'Database',
  'Server',
  'Inbox',
  'Mail',
  'MessageSquare',
  'Phone',
  'Video',
  'Mic',
  'Image',
  'Paperclip',
  'Link',
  'ExternalLink',
  'Download',
  'Upload',
  'Search',
  'Eye',
  'EyeOff',
  'Lock',
  'Key',
  'Wrench',
  'Paintbrush',
  'Wand2',
  'Lightbulb',
  'Bug',
  'GraduationCap',
  'BookOpen',
  'Bookmark',
  'Newspaper',
  'PieChart',
  'Play',
  'PlusSquare',
  'Puzzle',
  'Package',
  'Truck',
  'Monitor',
  'Laptop',
  'Music',
  'Timer',
  'Trash2',
  'Heart',
  'HelpCircle',
  'Moon',
  'Zap',
  'Flame',
  'Gift',
  'Globe',
  'MapPin',
  'Home',
  'Building2',
  'ShoppingCart',
  'CreditCard',
  'Wallet',
  'ThumbsUp',
  'Trophy',
  'Smartphone',
  'Tablet',
  'Cpu',
  'HardDrive',
  'Wifi',
  'Bluetooth',
  'Camera',
  'Headphones',
  'Speaker',
  'Tv',
  'Printer',
  'Keyboard',
  'Mouse',
  'DollarSign',
  'Banknote',
  'Receipt',
  'Calculator',
  'TrendingDown',
  'BarChart',
  'BarChart2',
  'LineChart',
  'Activity',
  'Coins',
  'PiggyBank',
  'Send',
  'AtSign',
  'Hash',
  'MessageCircle',
  'MessagesSquare',
  'Share',
  'Share2',
  'Megaphone',
  'Radio',
  'Rss',
  'File',
  'FileCode',
  'FileImage',
  'FileAudio',
  'FileVideo',
  'FileSpreadsheet',
  'FileCheck',
  'FilePlus',
  'FolderPlus',
  'FolderCheck',
  'Archive',
  'ClipboardCheck',
  'UserPlus',
  'UserCheck',
  'UserX',
  'UserMinus',
  'UsersRound',
  'UserRound',
  'Crown',
  'Contact',
  'Handshake',
  'Map',
  'Navigation',
  'Compass',
  'Locate',
  'Milestone',
  'Signpost',
  'Route',
  'Sun',
  'Cloud',
  'CloudRain',
  'Snowflake',
  'Wind',
  'Thermometer',
  'Umbrella',
  'Rainbow',
  'Leaf',
  'Trees',
  'Flower2',
  'Mountain',
  'HeartPulse',
  'Stethoscope',
  'Pill',
  'Syringe',
  'Dumbbell',
  'Bike',
  'Footprints',
  'Brain',
  'Salad',
  'UtensilsCrossed',
  'Coffee',
  'Wine',
  'Beer',
  'Pizza',
  'Cake',
  'Cookie',
  'IceCream2',
  'Apple',
  'Plane',
  'Car',
  'Bus',
  'Train',
  'Ship',
  'Anchor',
  'Luggage',
  'Ticket',
  'Hotel',
  'Gamepad2',
  'Dice1',
  'Clapperboard',
  'Popcorn',
  'Drama',
  'PartyPopper',
  'Sparkles',
  'Film',
  'Tv2',
  'Book',
  'Library',
  'PenTool',
  'Highlighter',
  'Ruler',
  'School',
  'Presentation',
  'Languages',
  'FlaskConical',
  'Microscope',
  'Atom',
  'Dna',
  'Telescope',
  'Orbit',
  'Satellite',
  'Code',
  'Code2',
  'Terminal',
  'GitBranch',
  'GitMerge',
  'GitPullRequest',
  'Hammer',
  'Axe',
  'Scissors',
  'Brush',
  'Palette',
  'Pipette',
  'Eraser',
  'CircleDot',
  'Square',
  'Triangle',
  'Pentagon',
  'Hexagon',
  'Octagon',
  'Diamond',
  'Shapes',
  'ShieldCheck',
  'ShieldAlert',
  'Fingerprint',
  'ScanFace',
  'KeyRound',
  'LockKeyhole',
  'UnlockKeyhole',
  'Armchair',
  'Bed',
  'Bath',
  'Lamp',
  'Sofa',
  'Shirt',
  'Watch',
  'Glasses',
  'Gem',
  'Award',
  'Medal',
  'BadgeCheck',
  'Flag',
  'Bookmark2',
  'Pin',
  'Magnet',
  'Battery',
  'Power',
  'Plug',
  'Infinity',
  'QrCode',
  'Barcode',
  'Scan',
  'Bot',
  'BrainCircuit',
  'Sparkle',
  'Blocks',
  'Layers',
  'LayoutGrid',
  'LayoutList',
  'LayoutDashboard',
  'ArrowRight',
  'ArrowUp',
  'ArrowDown',
  'ArrowLeft',
  'RefreshCw',
  'RotateCcw',
  'Repeat',
  'Shuffle',
  'Move',
  'Maximize2',
  'Minimize2',
  'AlertCircle',
  'AlertTriangle',
  'Info',
  'CircleCheck',
  'CircleX',
  'CircleAlert',
  'BellRing',
  'BellOff'
);

ALTER TYPE "public"."workspace_board_icon" OWNER TO "postgres";

CREATE TYPE "public"."workspace_calendar_type" AS ENUM (
  'primary',
  'tasks',
  'habits',
  'custom'
);

ALTER TYPE "public"."workspace_calendar_type" OWNER TO "postgres";

CREATE TYPE "public"."workspace_product_tier" AS ENUM (
  'FREE',
  'PLUS',
  'PRO',
  'ENTERPRISE'
);

ALTER TYPE "public"."workspace_product_tier" OWNER TO "postgres";

CREATE TYPE "public"."workspace_role_permission" AS ENUM (
  'view_infrastructure',
  'manage_workspace_secrets',
  'manage_external_migrations',
  'manage_workspace_roles',
  'manage_workspace_members',
  'manage_workspace_settings',
  'manage_workspace_integrations',
  'manage_workspace_billing',
  'manage_workspace_security',
  'manage_workspace_audit_logs',
  'manage_user_report_templates',
  'manage_calendar',
  'manage_projects',
  'manage_documents',
  'manage_drive',
  'manage_users',
  'export_users_data',
  'manage_inventory',
  'manage_finance',
  'export_finance_data',
  'ai_chat',
  'ai_lab',
  'send_user_group_post_emails',
  'view_users_private_info',
  'view_users_public_info',
  'view_finance_stats',
  'create_users',
  'update_users',
  'delete_users',
  'check_user_attendance',
  'create_inventory',
  'update_inventory',
  'delete_inventory',
  'view_inventory',
  'view_transactions',
  'create_transactions',
  'update_transactions',
  'delete_transactions',
  'view_invoices',
  'create_invoices',
  'update_invoices',
  'delete_invoices',
  'view_user_groups',
  'create_user_groups',
  'update_user_groups',
  'delete_user_groups',
  'view_user_groups_scores',
  'create_user_groups_scores',
  'update_user_groups_scores',
  'delete_user_groups_scores',
  'view_user_groups_posts',
  'create_user_groups_posts',
  'update_user_groups_posts',
  'delete_user_groups_posts',
  'create_lead_generations',
  'manage_api_keys',
  'view_confidential_amount',
  'view_confidential_description',
  'view_confidential_category',
  'create_confidential_transactions',
  'update_confidential_transactions',
  'delete_confidential_transactions',
  'manage_time_tracking_requests',
  'bypass_time_tracking_request_approval',
  'manage_changelog',
  'manage_subscription',
  'manage_e2ee'
);

ALTER TYPE "public"."workspace_role_permission" OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."disable_tracking"("regclass") RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO '' AS $ _ $ declare statement_row text = format(
    'drop trigger if exists audit_i_u_d on %s;',
    $ 1
  );

statement_stmt text = format(
  'drop trigger if exists audit_t on %s;',
  $ 1
);

begin execute statement_row;

execute statement_stmt;

end;

$ _ $;

ALTER FUNCTION "audit"."disable_tracking"("regclass") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."enable_tracking"("regclass") RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO '' AS $ _ $ declare statement_row text = format(
    '
        create trigger audit_i_u_d
            after insert or update or delete
            on %s
            for each row
            execute procedure audit.insert_update_delete_trigger();',
    $ 1
  );

statement_stmt text = format(
  '
        create trigger audit_t
            after truncate
            on %s
            for each statement
            execute procedure audit.truncate_trigger();',
  $ 1
);

pkey_cols text [] = audit.primary_key_columns($ 1);

begin if pkey_cols = array [] :: text [] then raise exception 'Table % can not be audited because it has no primary key',
$ 1;

end if;

if not exists(
  select
    1
  from
    pg_trigger
  where
    tgrelid = $ 1
    and tgname = 'audit_i_u_d'
) then execute statement_row;

end if;

if not exists(
  select
    1
  from
    pg_trigger
  where
    tgrelid = $ 1
    and tgname = 'audit_t'
) then execute statement_stmt;

end if;

end;

$ _ $;

ALTER FUNCTION "audit"."enable_tracking"("regclass") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."get_ws_id"("table_name" "text", "record" "jsonb") RETURNS "uuid" LANGUAGE "plpgsql" IMMUTABLE PARALLEL SAFE AS $ $ BEGIN IF table_name = 'workspaces' THEN RETURN (record ->> 'id') :: UUID;

END IF;

IF table_name = 'wallet_transactions' THEN RETURN (
  SELECT
    ws_id
  FROM
    public.workspace_wallets
  WHERE
    id = (record ->> 'wallet_id') :: UUID
);

END IF;

IF table_name = 'calendar_event_platform_participants'
OR table_name = 'calendar_event_virtual_participants'
OR table_name = 'calendar_event_participant_groups' THEN RETURN (
  SELECT
    ws_id
  FROM
    public.workspace_calendar_events
  WHERE
    id = (record ->> 'event_id') :: UUID
);

END IF;

RETURN (record ->> 'ws_id') :: UUID;

END;

$ $;

ALTER FUNCTION "audit"."get_ws_id"("table_name" "text", "record" "jsonb") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."insert_update_delete_trigger"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ declare pkey_cols text [] = audit.primary_key_columns(TG_RELID);

record_jsonb jsonb = to_jsonb(new);

record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, record_jsonb);

old_record_jsonb jsonb = to_jsonb(old);

old_record_id uuid = audit.to_record_id(TG_RELID, pkey_cols, old_record_jsonb);

begin
insert into
  audit.record_version(
    record_id,
    old_record_id,
    op,
    table_oid,
    table_schema,
    table_name,
    record,
    old_record
  )
select
  record_id,
  old_record_id,
  TG_OP :: audit.operation,
  TG_RELID,
  TG_TABLE_SCHEMA,
  TG_TABLE_NAME,
  record_jsonb,
  old_record_jsonb;

return coalesce(new, old);

end;

$ $;

ALTER FUNCTION "audit"."insert_update_delete_trigger"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."primary_key_columns"("entity_oid" "oid") RETURNS "text" [] LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO '' AS $ _ $ -- Looks up the names of a table's primary key columns
select
  coalesce(
    array_agg(
      pa.attname :: text
      order by
        pa.attnum
    ),
    array [] :: text []
  ) column_names
from
  pg_index pi
  join pg_attribute pa on pi.indrelid = pa.attrelid
  and pa.attnum = any(pi.indkey)
where
  indrelid = $ 1
  and indisprimary $ _ $;

ALTER FUNCTION "audit"."primary_key_columns"("entity_oid" "oid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."to_record_id"(
  "entity_oid" "oid",
  "pkey_cols" "text" [],
  "rec" "jsonb"
) RETURNS "uuid" LANGUAGE "sql" STABLE
SET
  "search_path" TO 'extensions' AS $ _ $
select
  case
    when rec is null then null
    when pkey_cols = array [] :: text [] then gen_random_uuid()
    else (
      select
        extensions.uuid_generate_v5(
          'fd62bc3d-8d6e-43c2-919c-802ba3762271',
          (
            jsonb_build_array(to_jsonb($ 1)) || jsonb_agg($ 3 ->> key_)
          ) :: text
        )
      from
        unnest($ 2) x(key_)
    )
  end $ _ $;

ALTER FUNCTION "audit"."to_record_id"(
  "entity_oid" "oid",
  "pkey_cols" "text" [],
  "rec" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "audit"."truncate_trigger"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO '' AS $ $ begin
insert into
  audit.record_version(
    op,
    table_oid,
    table_schema,
    table_name
  )
select
  TG_OP :: audit.operation,
  TG_RELID,
  TG_TABLE_SCHEMA,
  TG_TABLE_NAME;

return coalesce(old, new);

end;

$ $;

ALTER FUNCTION "audit"."truncate_trigger"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."add_ws_creator"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN IF auth.uid() IS NOT NULL THEN -- Insert workspace creator as a member (role column removed)
INSERT INTO
  public.workspace_members(ws_id, user_id)
VALUES
  (new.id, auth.uid());

END IF;

RETURN new;

END;

$ $;

ALTER FUNCTION "public"."add_ws_creator"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."archive_old_notifications"("p_days_threshold" integer DEFAULT 90) RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_archived_count INTEGER;

BEGIN
UPDATE
  public.notifications
SET
  archived_at = now()
WHERE
  read_at IS NOT NULL
  AND read_at < (now() - (p_days_threshold || ' days') :: interval)
  AND archived_at IS NULL;

GET DIAGNOSTICS v_archived_count = ROW_COUNT;

RETURN v_archived_count;

END;

$ $;

ALTER FUNCTION "public"."archive_old_notifications"("p_days_threshold" integer) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."archive_old_notifications"("p_days_threshold" integer) IS 'Archives old read notifications';

CREATE
OR REPLACE FUNCTION "public"."assign_task_display_number"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE v_board_id UUID;

v_old_board_id UUID;

BEGIN -- Get the board_id for this task's list
SELECT
  tl.board_id INTO v_board_id
FROM
  task_lists tl
WHERE
  tl.id = NEW.list_id;

-- Store old board_id for UPDATE operations
IF TG_OP = 'UPDATE' THEN v_old_board_id := OLD.board_id;

END IF;

-- Always set board_id to match the list's board (keeps it synchronized)
NEW.board_id := v_board_id;

-- Only assign display_number if not already set
IF NEW.display_number IS NULL THEN NEW.display_number := get_next_task_display_number(v_board_id);

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."assign_task_display_number"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."atomic_sync_token_operation"(
  "p_ws_id" "uuid",
  "p_calendar_id" "text" DEFAULT 'primary' :: "text",
  "p_operation" "text" DEFAULT 'get' :: "text",
  "p_sync_token" "text" DEFAULT NULL :: "text"
) RETURNS TABLE(
  "sync_token" "text",
  "last_synced_at" timestamp with time zone,
  "success" boolean,
  "message" "text"
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_sync_token TEXT;

v_last_synced_at TIMESTAMPTZ;

BEGIN -- Note: PostgreSQL functions automatically run within a transaction
-- No need for manual BEGIN/COMMIT/ROLLBACK
IF p_operation = 'get' THEN -- Get sync token with row-level lock
SELECT
  sync_token,
  last_synced_at INTO v_sync_token,
  v_last_synced_at
FROM
  calendar_sync_states
WHERE
  ws_id = p_ws_id
  AND calendar_id = p_calendar_id FOR
UPDATE
  NOWAIT;

-- NOWAIT prevents blocking if row is already locked
RETURN QUERY
SELECT
  COALESCE(v_sync_token, ''),
  COALESCE(v_last_synced_at, NOW()),
  TRUE,
  'Sync token retrieved successfully';

ELSIF p_operation = 'update' THEN -- Update sync token atomically
INSERT INTO
  calendar_sync_states (ws_id, calendar_id, sync_token, last_synced_at)
VALUES
  (p_ws_id, p_calendar_id, p_sync_token, NOW()) ON CONFLICT (ws_id, calendar_id) DO
UPDATE
SET
  sync_token = EXCLUDED.sync_token,
  last_synced_at = EXCLUDED.last_synced_at;

RETURN QUERY
SELECT
  p_sync_token,
  NOW(),
  TRUE,
  'Sync token updated successfully';

ELSIF p_operation = 'clear' THEN -- Clear invalid sync token
DELETE FROM
  calendar_sync_states
WHERE
  ws_id = p_ws_id
  AND calendar_id = p_calendar_id;

RETURN QUERY
SELECT
  '',
  NOW(),
  TRUE,
  'Sync token cleared successfully';

ELSE RETURN QUERY
SELECT
  '',
  NOW(),
  FALSE,
  'Invalid operation specified';

END IF;

EXCEPTION
WHEN lock_not_available THEN -- Handle case where row is already locked
RETURN QUERY
SELECT
  '',
  NOW(),
  FALSE,
  'Row is locked by another process, try again later';

WHEN OTHERS THEN -- Handle any other errors
RETURN QUERY
SELECT
  '',
  NOW(),
  FALSE,
  'Error: ' || SQLERRM;

END;

$ $;

ALTER FUNCTION "public"."atomic_sync_token_operation"(
  "p_ws_id" "uuid",
  "p_calendar_id" "text",
  "p_operation" "text",
  "p_sync_token" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."auto_add_assignee_as_watcher"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Insert the assignee as a watcher if not already watching
INSERT INTO
  public.task_watchers (task_id, user_id)
VALUES
  (NEW.task_id, NEW.user_id) ON CONFLICT (task_id, user_id) DO NOTHING;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."auto_add_assignee_as_watcher"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."auto_add_assignee_as_watcher"() IS 'Automatically adds task assignees as watchers to receive due date reminders';

CREATE
OR REPLACE FUNCTION "public"."auto_link_referral_promotion"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN -- Insert a new record into user_linked_promotions
-- using the owner's ID and the new promotion's ID.
INSERT INTO
  public.user_linked_promotions (user_id, promo_id)
VALUES
  (NEW.owner_id, NEW.id);

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."auto_link_referral_promotion"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."calculate_next_occurrence"(
  "from_date" "date",
  "frequency" "public"."recurring_frequency"
) RETURNS "date" LANGUAGE "plpgsql" IMMUTABLE AS $ $ BEGIN RETURN CASE
  frequency
  WHEN 'daily' THEN from_date + INTERVAL '1 day'
  WHEN 'weekly' THEN from_date + INTERVAL '1 week'
  WHEN 'monthly' THEN from_date + INTERVAL '1 month'
  WHEN 'yearly' THEN from_date + INTERVAL '1 year'
END;

END;

$ $;

ALTER FUNCTION "public"."calculate_next_occurrence"(
  "from_date" "date",
  "frequency" "public"."recurring_frequency"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."calculate_productivity_score"(
  "duration_seconds" integer,
  "category_color" "text"
) RETURNS integer LANGUAGE "plpgsql" IMMUTABLE AS $ $ BEGIN -- Base score from duration (up to 100 points for 4+ hours)
DECLARE duration_score INTEGER := LEAST(duration_seconds / 144, 100);

-- 144 seconds per point
category_multiplier DECIMAL := 1.0;

BEGIN -- Category-based multiplier
CASE
  category_color
  WHEN 'BLUE',
  'GREEN' THEN category_multiplier := 1.2;

-- Development, Meetings
WHEN 'PURPLE',
'ORANGE' THEN category_multiplier := 1.1;

-- Research, Planning
ELSE category_multiplier := 1.0;

END CASE
;

RETURN ROUND(duration_score * category_multiplier);

END;

END;

$ $;

ALTER FUNCTION "public"."calculate_productivity_score"(
  "duration_seconds" integer,
  "category_color" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."calculate_time_tracker_streak"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean
) RETURNS integer LANGUAGE "plpgsql" STABLE AS $ $ DECLARE v_streak INTEGER := 0;

BEGIN -- Use gap-and-islands pattern with ROW_NUMBER() to find consecutive activity groups
-- in a single query instead of looping with O(n) EXISTS checks
WITH activity_data AS (
  SELECT
    DISTINCT activity_date
  FROM
    time_tracker_daily_activity
  WHERE
    user_id = p_user_id
    AND (
      p_is_personal
      OR ws_id = p_ws_id
    )
    AND activity_date <= CURRENT_DATE
),
-- Create islands by subtracting row number from date
-- Consecutive dates will have the same island_id
islands AS (
  SELECT
    activity_date,
    activity_date - (
      ROW_NUMBER() OVER (
        ORDER BY
          activity_date
      )
    ) :: INTEGER AS island_id
  FROM
    activity_data
),
-- Aggregate each island to find first and last date, and count
island_groups AS (
  SELECT
    island_id,
    MIN(activity_date) AS first_date,
    MAX(activity_date) AS last_date,
    COUNT(*) :: INTEGER AS day_count
  FROM
    islands
  GROUP BY
    island_id
) -- Find the island whose last_date is today or yesterday
-- (streak continues if activity was today, or if yesterday was the last day)
SELECT
  day_count INTO v_streak
FROM
  island_groups
WHERE
  last_date = CURRENT_DATE
  OR last_date = CURRENT_DATE - INTERVAL '1 day'
ORDER BY
  last_date DESC
LIMIT
  1;

-- Return 0 if no streak found (handles no-activity case)
RETURN COALESCE(v_streak, 0);

END;

$ $;

ALTER FUNCTION "public"."calculate_time_tracker_streak"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."calculate_time_tracker_streak"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean
) IS 'Calculates the current streak of consecutive days with time tracking activity.';

CREATE
OR REPLACE FUNCTION "public"."calculate_time_tracking_break_duration"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin if new.break_end is not null
and new.break_start is not null then new.break_duration_seconds := extract(
  epoch
  from
    (new.break_end - new.break_start)
) :: integer;

end if;

return new;

end;

$ $;

ALTER FUNCTION "public"."calculate_time_tracking_break_duration"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."can_create_workspace"("p_user_id" "uuid") RETURNS boolean LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
select
  (
    exists (
      select
        1
      from
        public.platform_user_roles pur
      where
        pur.user_id = p_user_id
        and pur.allow_workspace_creation = true
    )
  )
  or (
    not exists (
      select
        1
      from
        public.workspaces w
      where
        w.creator_id = p_user_id
        and w.personal = true
        and w.deleted = false
    )
  );

$ $;

ALTER FUNCTION "public"."can_create_workspace"("p_user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."can_manage_indicator"("p_indicator_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      healthcare_vitals hv
    WHERE
      hv.id = p_indicator_id
      AND is_org_member(auth.uid(), hv.ws_id)
  );

$ $;

ALTER FUNCTION "public"."can_manage_indicator"("p_indicator_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_challenge_attempt_limits"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE challenge_max_attempts smallint;

challenge_max_daily_attempts smallint;

total_attempts bigint;

daily_attempts bigint;

BEGIN
SELECT
  nc.max_attempts,
  nc.max_daily_attempts,
  COUNT(ns.id) FILTER (
    WHERE
      ns.user_id = NEW.user_id
  ),
  COUNT(ns.id) FILTER (
    WHERE
      ns.user_id = NEW.user_id
      AND ns.created_at :: date = current_date
  ) INTO challenge_max_attempts,
  challenge_max_daily_attempts,
  total_attempts,
  daily_attempts
FROM
  nova_challenges nc
  LEFT JOIN nova_sessions ns ON nc.id = ns.challenge_id
WHERE
  nc.id = NEW.challenge_id
GROUP BY
  nc.max_attempts,
  nc.max_daily_attempts;

challenge_max_attempts := COALESCE(challenge_max_attempts, 32767);

challenge_max_daily_attempts := COALESCE(challenge_max_daily_attempts, 32767);

total_attempts := COALESCE(total_attempts, 0);

daily_attempts := COALESCE(daily_attempts, 0);

IF total_attempts >= challenge_max_attempts THEN RAISE EXCEPTION 'You have exceeded the maximum number of total attempts for this challenge.';

ELSIF daily_attempts >= challenge_max_daily_attempts THEN RAISE EXCEPTION 'You have exceeded the daily attempt limit for this challenge.';

END IF;

RETURN NEW;

END $ $;

ALTER FUNCTION "public"."check_challenge_attempt_limits"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_email_blocked"("p_email" "text") RETURNS boolean LANGUAGE "plpgsql" STABLE SECURITY DEFINER
SET
  "search_path" TO '' AS $ $ DECLARE v_email TEXT := lower(p_email);

-- Normalize input email
v_domain TEXT := split_part(v_email, '@', 2);

BEGIN RETURN EXISTS (
  SELECT
    1
  FROM
    public.email_blacklist
  WHERE
    -- Case 1: Direct email match (e.g., 'bad-user@example.com')
    (
      entry_type = 'email'
      AND value = v_email
    )
    OR -- Case 2: Domain match (e.g., 'example.com')
    (
      entry_type = 'domain'
      AND value = v_domain
    )
);

END;

$ $;

ALTER FUNCTION "public"."check_email_blocked"("p_email" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_email_bounce_status"(
  "p_email_hash" "text",
  "p_window_days" integer DEFAULT 30
) RETURNS TABLE(
  "is_blocked" boolean,
  "hard_bounce_count" bigint,
  "soft_bounce_count" bigint,
  "complaint_count" bigint,
  "block_reason" "text"
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_hard_bounces BIGINT;

v_soft_bounces BIGINT;

v_complaints BIGINT;

v_since TIMESTAMPTZ;

BEGIN v_since := NOW() - (p_window_days || ' days') :: INTERVAL;

-- Count different event types
SELECT
  COUNT(*) FILTER (
    WHERE
      event_type = 'bounce'
      AND bounce_type = 'hard'
  ),
  COUNT(*) FILTER (
    WHERE
      event_type = 'bounce'
      AND bounce_type IN ('soft', 'transient')
  ),
  COUNT(*) FILTER (
    WHERE
      event_type = 'complaint'
  ) INTO v_hard_bounces,
  v_soft_bounces,
  v_complaints
FROM
  public.email_bounce_complaints
WHERE
  email_hash = p_email_hash
  AND created_at >= v_since;

-- Determine if blocked
IF v_hard_bounces > 0 THEN RETURN QUERY
SELECT
  TRUE :: BOOLEAN,
  v_hard_bounces,
  v_soft_bounces,
  v_complaints,
  'Hard bounce detected' :: TEXT;

ELSIF v_complaints > 0 THEN RETURN QUERY
SELECT
  TRUE :: BOOLEAN,
  v_hard_bounces,
  v_soft_bounces,
  v_complaints,
  'Spam complaint received' :: TEXT;

ELSIF v_soft_bounces >= 3 THEN RETURN QUERY
SELECT
  TRUE :: BOOLEAN,
  v_hard_bounces,
  v_soft_bounces,
  v_complaints,
  'Multiple soft bounces' :: TEXT;

ELSE RETURN QUERY
SELECT
  FALSE :: BOOLEAN,
  v_hard_bounces,
  v_soft_bounces,
  v_complaints,
  NULL :: TEXT;

END IF;

END;

$ $;

ALTER FUNCTION "public"."check_email_bounce_status"("p_email_hash" "text", "p_window_days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_guest_group"("group_id" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ BEGIN RETURN EXISTS (
  SELECT
    1
  FROM
    workspace_user_groups ws
  WHERE
    ws.id = check_guest_group.group_id
    AND ws.is_guest = TRUE
);

END;

$ $;

ALTER FUNCTION "public"."check_guest_group"("group_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_guest_lead_eligibility"("p_ws_id" "uuid", "p_user_id" "uuid") RETURNS "jsonb" LANGUAGE "plpgsql" AS $ $ DECLARE is_guest_user BOOLEAN;

attendance_threshold SMALLINT;

attendance_count INTEGER;

BEGIN -- Check 0: Verify the user belongs to the workspace
IF NOT EXISTS (
  SELECT
    1
  FROM
    public.workspace_users
  WHERE
    id = p_user_id
    AND ws_id = p_ws_id
) THEN RETURN jsonb_build_object(
  'eligible',
  false,
  'reason',
  'User does not belong to the specified workspace',
  'details',
  jsonb_build_object()
);

END IF;

-- Check 1: Verify the user is a guest
SELECT
  public.is_user_guest(p_user_id) INTO is_guest_user;

IF NOT is_guest_user THEN RETURN jsonb_build_object(
  'eligible',
  false,
  'reason',
  'User is not a guest user',
  'details',
  jsonb_build_object('is_guest', false)
);

END IF;

-- Check 2: Verify attendance threshold is configured
SELECT
  ws.guest_user_checkup_threshold INTO attendance_threshold
FROM
  public.workspace_settings ws
WHERE
  ws.ws_id = p_ws_id;

IF attendance_threshold IS NULL THEN RETURN jsonb_build_object(
  'eligible',
  false,
  'reason',
  'Attendance threshold not configured for workspace',
  'details',
  jsonb_build_object(
    'is_guest',
    true,
    'threshold_configured',
    false
  )
);

END IF;

-- Check 3: Calculate attendance count
SELECT
  COUNT(*) INTO attendance_count
FROM
  public.user_group_attendance
WHERE
  user_id = p_user_id
  AND status IN ('PRESENT', 'LATE');

-- Check 4: Verify attendance meets minimum threshold
IF attendance_count < attendance_threshold THEN RETURN jsonb_build_object(
  'eligible',
  false,
  'reason',
  format(
    'User attendance count (%s) does not meet minimum threshold (%s)',
    attendance_count,
    attendance_threshold
  ),
  'details',
  jsonb_build_object(
    'is_guest',
    true,
    'threshold_configured',
    true,
    'attendance_count',
    attendance_count,
    'required_threshold',
    attendance_threshold,
    'meets_threshold',
    false
  )
);

END IF;

-- All checks passed
RETURN jsonb_build_object(
  'eligible',
  true,
  'reason',
  'User meets all eligibility criteria',
  'details',
  jsonb_build_object(
    'is_guest',
    true,
    'threshold_configured',
    true,
    'attendance_count',
    attendance_count,
    'required_threshold',
    attendance_threshold,
    'meets_threshold',
    true
  )
);

END;

$ $;

ALTER FUNCTION "public"."check_guest_lead_eligibility"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_guest_lead_generation_conditions"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE is_guest_user BOOLEAN;

attendance_threshold SMALLINT;

attendance_count INTEGER;

BEGIN -- Check 1: Verify the user is a guest
SELECT
  public.is_user_guest(NEW.user_id) INTO is_guest_user;

IF COALESCE(is_guest_user, FALSE) = FALSE THEN RAISE EXCEPTION 'Cannot create lead generation record: User is not a guest.';

END IF;

-- Check 2: Verify attendance meets the workspace's minimum threshold
SELECT
  ws.guest_user_checkup_threshold INTO attendance_threshold
FROM
  public.workspace_settings ws
WHERE
  ws.ws_id = NEW.ws_id;

IF attendance_threshold IS NULL THEN RAISE EXCEPTION 'Cannot create lead generation record: Attendance threshold is not set for this workspace.';

END IF;

-- Calculate the raw count of PRESENT or LATE sessions for this user within the workspace
SELECT
  COUNT(*) INTO attendance_count
FROM
  public.user_group_attendance uga
  JOIN public.workspace_user_groups gug ON gug.id = uga.group_id
WHERE
  uga.user_id = NEW.user_id
  AND gug.ws_id = NEW.ws_id
  AND uga.status IN ('PRESENT', 'LATE');

-- Block the insert if attendance is BELOW the minimum required threshold
IF attendance_count < attendance_threshold THEN RAISE EXCEPTION 'Cannot create lead generation record: User attendance count (%) does not meet the minimum required threshold of %.',
attendance_count,
attendance_threshold;

END IF;

-- All checks passed, allow the INSERT operation to proceed
RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."check_guest_lead_generation_conditions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_time_tracking_request_update"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin -- If user is NOT the owner (approver path)
if NEW.user_id <> auth.uid() then -- Ensure content fields are not modified
if NEW.title <> OLD.title
OR NEW.description IS DISTINCT
FROM
  OLD.description
  OR NEW.start_time <> OLD.start_time
  OR NEW.end_time <> OLD.end_time
  OR NEW.task_id IS DISTINCT
FROM
  OLD.task_id
  OR NEW.category_id IS DISTINCT
FROM
  OLD.category_id
  OR NEW.images IS DISTINCT
FROM
  OLD.images then raise exception 'Approvers cannot modify request content fields';

end if;

-- Ensure ownership/creation fields are not modified
if NEW.user_id <> OLD.user_id
OR NEW.workspace_id <> OLD.workspace_id
OR NEW.created_at <> OLD.created_at then raise exception 'Cannot modify ownership or creation fields';

end if;

-- Validate approval/rejection data integrity
if NEW.approval_status = 'APPROVED' then if NEW.approved_by <> auth.uid()
OR NEW.approved_at IS NULL then raise exception 'Invalid approval data';

end if;

if NEW.rejected_by IS NOT NULL
OR NEW.rejected_at IS NOT NULL
OR NEW.rejection_reason IS NOT NULL then raise exception 'Cannot have rejection data when approving';

end if;

elsif NEW.approval_status = 'REJECTED' then if NEW.rejected_by <> auth.uid()
OR NEW.rejected_at IS NULL
OR NEW.rejection_reason IS NULL then raise exception 'Invalid rejection data';

end if;

if NEW.approved_by IS NOT NULL
OR NEW.approved_at IS NOT NULL then raise exception 'Cannot have approval data when rejecting';

end if;

end if;

end if;

-- If user IS the owner, check for bypass flag to allow approval status change
if NEW.user_id = auth.uid() then if NEW.approval_status <> OLD.approval_status then -- Check for the bypass flag set in the current session.
-- Set this using: SET time_tracking.bypass_approval_rules = 'on';
if current_setting('time_tracking.bypass_approval_rules', true) <> 'on' then raise exception 'Request owner cannot change approval status';

end if;

end if;

end if;

return NEW;

end;

$ $;

ALTER FUNCTION "public"."check_time_tracking_request_update"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_time_tracking_session_insert"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE threshold_days INTEGER;

BEGIN -- Allow start times up to 5 minutes in the future for clock sync and manual entries
-- This provides flexibility while maintaining data integrity
IF NEW.start_time > NOW() + INTERVAL '5 minutes' THEN RAISE EXCEPTION 'Cannot create a time tracking session with a start time more than 5 minutes in the future.';

END IF;

-- Check for the bypass flag set in the current session.
-- Set this using: SET time_tracking.bypass_insert_limit = 'on';
IF current_setting('time_tracking.bypass_insert_limit', true) = 'on' THEN RETURN NEW;

-- Bypass the rule and allow the insert.
END IF;

-- Fetch threshold from workspace_settings
SELECT
  missed_entry_date_threshold INTO threshold_days
FROM
  workspace_settings
WHERE
  ws_id = NEW.ws_id;

-- If threshold is NULL (not found or explicitly null), no restrictions apply
-- This is the new default behavior: no approval needed
IF threshold_days IS NULL THEN RETURN NEW;

END IF;

-- For manual entries (is_running = false and has start_time and end_time)
IF NEW.is_running = false
AND NEW.start_time IS NOT NULL
AND NEW.end_time IS NOT NULL THEN -- If threshold is 0, all missed entries must go through request flow
IF threshold_days = 0 THEN RAISE EXCEPTION 'All missed entries must be submitted as requests for approval.';

END IF;

-- Check if the start_time is older than the threshold
IF NEW.start_time < (NOW() - (threshold_days || ' days') :: INTERVAL) THEN -- Block the insert and return an error message
RAISE EXCEPTION 'Adding missed entries with start time older than % days is not allowed.',
threshold_days;

END IF;

END IF;

-- If the checks pass, allow the insert to proceed by returning the NEW row.
RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."check_time_tracking_session_insert"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."check_time_tracking_session_insert"() IS 'Trigger function that validates time tracking session inserts:
1. Prevents sessions with start_time > NOW() + 5 minutes (cannot be bypassed)
2. When bypass_insert_limit is on, skips remaining checks
3. Otherwise enforces missed_entry_date_threshold from workspace_settings';

CREATE
OR REPLACE FUNCTION "public"."check_time_tracking_session_update"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE threshold_days INTEGER;

BEGIN -- Allow start times up to 5 minutes in the future for clock sync and manual entries
-- Only check when start_time or end_time are being changed
IF NEW.start_time IS DISTINCT
FROM
  OLD.start_time
  OR NEW.end_time IS DISTINCT
FROM
  OLD.end_time THEN IF NEW.start_time > NOW() + INTERVAL '5 minutes' THEN RAISE EXCEPTION 'Cannot update a time tracking session to have a start time more than 5 minutes in the future.';

END IF;

END IF;

-- Check for the bypass flag set in the current session.
-- Set this using: SET time_tracking.bypass_update_limit = 'on';
IF current_setting('time_tracking.bypass_update_limit', true) = 'on' THEN RETURN NEW;

-- Bypass the rule and allow the update.
END IF;

-- Check if a break is being paused (via context variable set by app)
-- When pausing to take a break, skip threshold validation since approval happens at request level
IF current_setting('time_tracking.is_break_pause', true) = 'on' THEN RETURN NEW;

-- Allow pause for breaks without threshold validation
END IF;

-- Fetch threshold and pause exemption from workspace_settings
SELECT
  missed_entry_date_threshold INTO threshold_days
FROM
  workspace_settings
WHERE
  ws_id = NEW.ws_id;

-- If threshold is NULL (not found or explicitly null), no restrictions apply
-- This is the new default behavior: no approval needed
IF threshold_days IS NULL THEN RETURN NEW;

END IF;

-- CRITICAL: Check if session is being completed (is_running changing from true to false)
-- IMPORTANT: When pausing to create a break, this validation is SKIPPED via the flag above.
-- The threshold check only applies to normal stop/completion, not break pauses.
-- Break pauses are validated at the request creation level instead.
IF OLD.is_running = true
AND NEW.is_running = false THEN -- If threshold is 0, all completed sessions that aren't same-day must go through request flow
-- EXCEPTION: Break pauses are exempt (checked via flag above)
IF threshold_days = 0 THEN RAISE EXCEPTION 'All missed entries must be submitted as requests for approval.';

END IF;

-- Check if the session's start_time is older than the threshold
IF threshold_days > 0
AND OLD.start_time < (NOW() - (threshold_days || ' days') :: INTERVAL) THEN RAISE EXCEPTION 'Cannot complete sessions older than % days. Please submit a missed entry request instead.',
threshold_days;

END IF;

END IF;

-- This check only applies if start_time or end_time are being changed.
-- It allows other fields (like notes or tasks) to be updated freely.
IF NEW.start_time IS DISTINCT
FROM
  OLD.start_time
  OR NEW.end_time IS DISTINCT
FROM
  OLD.end_time THEN -- Check if the original start_time is older than the threshold.
  -- We use OLD.start_time to base the check on the session's original creation time.
  IF threshold_days > 0
  AND OLD.start_time < (NOW() - (threshold_days || ' days') :: INTERVAL) THEN -- If the condition is met, block the update and return an error message.
  RAISE EXCEPTION 'Editing start_time or end_time for sessions older than % days is not allowed.',
  threshold_days;

END IF;

-- Also check if the NEW start_time being set is older than the threshold
-- This prevents the vulnerability of creating a session for today and backdating it to the past
IF threshold_days > 0
AND NEW.start_time < (NOW() - (threshold_days || ' days') :: INTERVAL) THEN RAISE EXCEPTION 'Cannot update session to a start time more than % days ago.',
threshold_days;

END IF;

END IF;

-- If the checks pass, allow the update to proceed by returning the NEW row.
RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."check_time_tracking_session_update"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."check_time_tracking_session_update"() IS 'Trigger function that validates time tracking session updates:
1. Prevents sessions with start_time > NOW() + 5 minutes when time fields change (cannot be bypassed)
2. When bypass_update_limit is on, skips remaining checks
3. Otherwise enforces missed_entry_date_threshold from workspace_settings for time field edits';

CREATE
OR REPLACE FUNCTION "public"."check_workspace_storage_limit"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE workspace_id uuid;

current_size BIGINT;

storage_limit BIGINT;

BEGIN -- Extract workspace ID from the object name (format: wsId/path/to/file)
workspace_id := split_part(NEW.name, '/', 1) :: uuid;

-- Get storage limit from workspace_secrets (defaults to 100MB)
storage_limit := get_workspace_storage_limit(workspace_id);

-- Calculate current workspace storage size
-- REMOVED: AND owner IS NOT NULL filter
SELECT
  COALESCE(SUM(COALESCE((metadata ->> 'size') :: BIGINT, 0)), 0) INTO current_size
FROM
  storage.objects
WHERE
  bucket_id = 'workspaces'
  AND split_part(name, '/', 1) :: uuid = workspace_id;

-- Add the size of the new object being inserted
current_size := current_size + COALESCE((NEW.metadata ->> 'size') :: BIGINT, 0);

-- Check if storage limit would be exceeded
IF current_size > storage_limit THEN RAISE EXCEPTION 'Storage limit exceeded. Maximum storage per workspace is % bytes. Current usage would be: % bytes',
storage_limit,
current_size;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."check_workspace_storage_limit"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_ws_creator"("ws_id" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ BEGIN RETURN (
  (
    SELECT
      creator_id
    FROM
      public.workspaces
    WHERE
      id = check_ws_creator.ws_id
  ) = auth.uid()
);

END;

$ $;

ALTER FUNCTION "public"."check_ws_creator"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."check_ws_creator"("ws_id" "uuid", "user_id" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ BEGIN RETURN (
  EXISTS (
    SELECT
      1
    FROM
      public.workspaces
    WHERE
      id = check_ws_creator.ws_id
      AND creator_id = check_ws_creator.user_id
  )
);

END;

$ $;

ALTER FUNCTION "public"."check_ws_creator"("ws_id" "uuid", "user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."cleanup_expired_cross_app_tokens"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
DELETE FROM
  public.cross_app_tokens
WHERE
  expires_at < now()
  OR (
    used_at IS NOT NULL
    AND used_at < now() - INTERVAL '1 hour'
  );

END;

$ $;

ALTER FUNCTION "public"."cleanup_expired_cross_app_tokens"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."cleanup_expired_live_sessions"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
DELETE FROM
  public.live_api_sessions
WHERE
  expires_at < NOW();

END;

$ $;

ALTER FUNCTION "public"."cleanup_expired_live_sessions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."cleanup_expired_notifications"() RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_deleted_count INTEGER;

BEGIN
DELETE FROM
  public.notifications
WHERE
  expires_at IS NOT NULL
  AND expires_at < now();

GET DIAGNOSTICS v_deleted_count = ROW_COUNT;

RETURN v_deleted_count;

END;

$ $;

ALTER FUNCTION "public"."cleanup_expired_notifications"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."cleanup_expired_notifications"() IS 'Deletes expired notifications';

CREATE
OR REPLACE FUNCTION "public"."cleanup_old_api_key_usage_logs"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
DELETE FROM
  "public"."workspace_api_key_usage_logs"
WHERE
  created_at < now() - INTERVAL '90 days';

END;

$ $;

ALTER FUNCTION "public"."cleanup_old_api_key_usage_logs"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."cleanup_old_api_key_usage_logs"() IS 'Deletes API key usage logs older than 90 days. Should be run daily via cron or scheduled job.';

CREATE
OR REPLACE FUNCTION "public"."cleanup_old_typing_indicators"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
DELETE FROM
  public.workspace_chat_typing_indicators
WHERE
  updated_at < NOW() - INTERVAL '5 seconds';

END;

$ $;

ALTER FUNCTION "public"."cleanup_old_typing_indicators"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."cleanup_platform_email_roles"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
DELETE FROM
  public.platform_email_roles per
WHERE
  per.email = (
    SELECT
      upd.email
    FROM
      public.user_private_details upd
    WHERE
      upd.user_id = NEW.user_id
  );

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."cleanup_platform_email_roles"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."cleanup_role_inconsistencies"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE migrated_count INT := 0;

BEGIN -- Migrate any remaining platform_email_roles to platform_user_roles where users exist
INSERT INTO
  public.platform_user_roles (
    user_id,
    enabled,
    allow_challenge_management,
    allow_manage_all_challenges,
    allow_role_management
  )
SELECT
  upd.user_id,
  per.enabled,
  per.allow_challenge_management,
  per.allow_manage_all_challenges,
  per.allow_role_management
FROM
  public.platform_email_roles per
  JOIN public.user_private_details upd ON per.email = upd.email ON CONFLICT (user_id) DO
UPDATE
SET
  enabled = EXCLUDED.enabled,
  allow_challenge_management = EXCLUDED.allow_challenge_management,
  allow_manage_all_challenges = EXCLUDED.allow_manage_all_challenges,
  allow_role_management = EXCLUDED.allow_role_management;

-- Get the number of affected rows
GET DIAGNOSTICS migrated_count = ROW_COUNT;

RAISE NOTICE 'Migrated % roles from platform_email_roles to platform_user_roles',
migrated_count;

-- Remove the migrated email roles
DELETE FROM
  public.platform_email_roles per
WHERE
  EXISTS (
    SELECT
      1
    FROM
      public.user_private_details upd
    WHERE
      upd.email = per.email
  );

-- Ensure all users have a platform_user_roles entry
INSERT INTO
  public.platform_user_roles (user_id, enabled)
SELECT
  u.id,
  false
FROM
  public.users u
  LEFT JOIN public.platform_user_roles pur ON u.id = pur.user_id
WHERE
  pur.user_id IS NULL;

END;

$ $;

ALTER FUNCTION "public"."cleanup_role_inconsistencies"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."compute_ai_cost_usd"(
  "p_model_id" "text",
  "p_input_tokens" numeric,
  "p_output_tokens" numeric,
  "p_reasoning_tokens" numeric,
  "p_pricing" "jsonb"
) RETURNS numeric LANGUAGE "plpgsql" STABLE AS $ $ DECLARE v_pricing JSONB := p_pricing;

v_model JSONB;

v_in NUMERIC := 0;

v_out NUMERIC := 0;

v_reason NUMERIC := 0;

BEGIN IF v_pricing IS NULL THEN v_pricing := get_default_ai_pricing();

END IF;

v_model := v_pricing -> p_model_id;

IF v_model IS NULL THEN RETURN 0;

END IF;

v_in := COALESCE((v_model ->> 'per1MInputTokens') :: NUMERIC, 0);

v_out := COALESCE((v_model ->> 'per1MOutputTokens') :: NUMERIC, 0);

v_reason := COALESCE((v_model ->> 'per1MReasoningTokens') :: NUMERIC, 0);

RETURN (COALESCE(p_input_tokens, 0) / 1000000.0) * v_in + (COALESCE(p_output_tokens, 0) / 1000000.0) * v_out + (COALESCE(p_reasoning_tokens, 0) / 1000000.0) * v_reason;

END;

$ $;

ALTER FUNCTION "public"."compute_ai_cost_usd"(
  "p_model_id" "text",
  "p_input_tokens" numeric,
  "p_output_tokens" numeric,
  "p_reasoning_tokens" numeric,
  "p_pricing" "jsonb"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."compute_ai_cost_usd"(
  "p_model_id" "text",
  "p_input_tokens" numeric,
  "p_output_tokens" numeric,
  "p_reasoning_tokens" numeric,
  "p_pricing" "jsonb"
) IS 'Computes USD cost for a given model and token usage using provided pricing JSON (or defaults).';

CREATE
OR REPLACE FUNCTION "public"."count_search_users"(
  "search_query" "text",
  "role_filter" "text" DEFAULT NULL :: "text",
  "enabled_filter" boolean DEFAULT NULL :: boolean
) RETURNS integer LANGUAGE "plpgsql" AS $ _ $ DECLARE total_count INTEGER;

where_clause TEXT := '';

query TEXT;

BEGIN -- Base where condition
where_clause := 'u.display_name ILIKE ''%'' || $1 || ''%'' OR ud.email ILIKE ''%'' || $1 || ''%''';

-- Add role filter if provided
IF role_filter IS NOT NULL THEN CASE
  role_filter
  WHEN 'admin' THEN where_clause := where_clause || ' AND ur.allow_role_management = true';

WHEN 'global_manager' THEN where_clause := where_clause || ' AND ur.allow_manage_all_challenges = true';

WHEN 'challenge_manager' THEN where_clause := where_clause || ' AND ur.allow_challenge_management = true';

WHEN 'member' THEN where_clause := where_clause || ' AND ur.allow_challenge_management = false AND ur.allow_manage_all_challenges = false AND ur.allow_role_management = false';

ELSE -- No additional filter for 'all' or other values
END CASE
;

END IF;

-- Add enabled filter if provided
IF enabled_filter IS NOT NULL THEN where_clause := where_clause || ' AND ur.enabled = ' || enabled_filter :: TEXT;

END IF;

-- Construct and execute dynamic query
query := '
    SELECT COUNT(DISTINCT u.id)
    FROM platform_user_roles ur
    JOIN users u ON ur.user_id = u.id
    JOIN user_private_details ud ON u.id = ud.user_id
    WHERE ' || where_clause;

EXECUTE query INTO total_count USING search_query;

RETURN total_count;

END;

$ _ $;

ALTER FUNCTION "public"."count_search_users"(
  "search_query" "text",
  "role_filter" "text",
  "enabled_filter" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."count_user_workspaces"("user_id" "uuid") RETURNS bigint LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
select
  count(*)
from
  public.workspaces
where
  creator_id = user_id
  and deleted = false;

$ $;

ALTER FUNCTION "public"."count_user_workspaces"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_ai_chat"("title" "text", "message" "text", "model" "text") RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ declare generated_chat_id uuid;

begin generated_chat_id := gen_random_uuid();

insert into
  ai_chats (id, title, creator_id, model)
values
  (generated_chat_id, title, auth.uid(), model);

insert into
  ai_chat_messages (chat_id, content, creator_id, role)
values
  (generated_chat_id, message, auth.uid(), 'USER');

return generated_chat_id;

end;

$ $;

ALTER FUNCTION "public"."create_ai_chat"("title" "text", "message" "text", "model" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_default_lists_from_template"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE template_record RECORD;

status_item JSONB;

position_counter INTEGER := 0;

BEGIN -- Only proceed if template_id is set
IF NEW.template_id IS NOT NULL THEN -- Get the template
SELECT
  * INTO template_record
FROM
  task_board_status_templates
WHERE
  id = NEW.template_id;

-- Create lists for each status in the template
FOR status_item IN
SELECT
  *
FROM
  jsonb_array_elements(template_record.statuses) LOOP
INSERT INTO
  task_lists (
    board_id,
    name,
    status,
    color,
    position
  )
VALUES
  (
    NEW.id,
    status_item ->> 'name',
    (status_item ->> 'status') :: task_board_status,
    status_item ->> 'color',
    position_counter
  );

position_counter := position_counter + 1;

END LOOP;

ELSE -- Create default lists if no template
INSERT INTO
  task_lists (board_id, name, status, color, position)
VALUES
  (NEW.id, 'To Do', 'not_started', 'GRAY', 0),
  (NEW.id, 'In Progress', 'active', 'BLUE', 1),
  (NEW.id, 'Done', 'done', 'GREEN', 2),
  (NEW.id, 'Closed', 'closed', 'PURPLE', 3);

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."create_default_lists_from_template"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_guest_lead_email"(
  "p_ws_id" "uuid",
  "p_sender_id" "uuid",
  "p_receiver_id" "uuid",
  "p_source_name" "text",
  "p_source_email" "text",
  "p_subject" "text",
  "p_content" "text",
  "p_email" "text",
  "p_post_id" "uuid" DEFAULT NULL :: "uuid"
) RETURNS "jsonb" LANGUAGE "plpgsql" AS $ $ DECLARE new_mail_id UUID;

BEGIN -- Step 1: Insert the email record into 'sent_emails'
INSERT INTO
  public.sent_emails (
    ws_id,
    sender_id,
    receiver_id,
    source_name,
    source_email,
    subject,
    content,
    email,
    post_id
  )
VALUES
  (
    p_ws_id,
    p_sender_id,
    p_receiver_id,
    p_source_name,
    p_source_email,
    p_subject,
    p_content,
    p_email,
    p_post_id
  ) RETURNING id INTO new_mail_id;

-- Step 2: Attempt to insert into 'guest_user_lead_generation'.
-- The trigger will automatically run here and perform all validations.
INSERT INTO
  public.guest_users_lead_generation (ws_id, user_id, mail_id)
VALUES
  (p_ws_id, p_receiver_id, new_mail_id);

-- If both inserts succeed, return the new mail ID
RETURN jsonb_build_object('status', 'success', 'mail_id', new_mail_id);

END;

$ $;

ALTER FUNCTION "public"."create_guest_lead_email"(
  "p_ws_id" "uuid",
  "p_sender_id" "uuid",
  "p_receiver_id" "uuid",
  "p_source_name" "text",
  "p_source_email" "text",
  "p_subject" "text",
  "p_content" "text",
  "p_email" "text",
  "p_post_id" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_missing_personal_workspaces"() RETURNS TABLE(
  "user_id" "uuid",
  "workspace_id" "uuid",
  "success" boolean,
  "error_message" "text"
) LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE user_record RECORD;

new_ws_id uuid;

BEGIN -- Loop through users who don't have a personal workspace
FOR user_record IN
SELECT
  u.id
FROM
  auth.users u
WHERE
  NOT EXISTS (
    SELECT
      1
    FROM
      public.workspaces w
    WHERE
      w.creator_id = u.id
      AND w.personal = true
  )
  AND u.deleted_at IS NULL LOOP BEGIN -- Create personal workspace
INSERT INTO
  public.workspaces (name, creator_id, personal)
VALUES
  ('Personal', user_record.id, true) RETURNING id INTO new_ws_id;

-- Add user as member
INSERT INTO
  public.workspace_members (ws_id, user_id)
VALUES
  (new_ws_id, user_record.id);

-- Return success
user_id := user_record.id;

workspace_id := new_ws_id;

success := true;

error_message := NULL;

RETURN NEXT;

EXCEPTION
WHEN OTHERS THEN -- Return failure
user_id := user_record.id;

workspace_id := NULL;

success := false;

error_message := SQLERRM;

RETURN NEXT;

END;

END LOOP;

END;

$ $;

ALTER FUNCTION "public"."create_missing_personal_workspaces"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_notification"(
  "p_ws_id" "uuid" DEFAULT NULL :: "uuid",
  "p_user_id" "uuid" DEFAULT NULL :: "uuid",
  "p_email" "text" DEFAULT NULL :: "text",
  "p_type" "text" DEFAULT NULL :: "text",
  "p_code" "text" DEFAULT NULL :: "text",
  "p_title" "text" DEFAULT NULL :: "text",
  "p_description" "text" DEFAULT NULL :: "text",
  "p_data" "jsonb" DEFAULT '{}' :: "jsonb",
  "p_entity_type" "text" DEFAULT NULL :: "text",
  "p_entity_id" "uuid" DEFAULT NULL :: "uuid",
  "p_created_by" "uuid" DEFAULT NULL :: "uuid",
  "p_scope" "public"."notification_scope" DEFAULT 'workspace' :: "public"."notification_scope",
  "p_priority" "public"."notification_priority" DEFAULT 'medium' :: "public"."notification_priority"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_notification_id UUID;

v_should_send_web BOOLEAN;

v_should_send_email BOOLEAN;

v_batch_id UUID;

v_target_user_id UUID;

v_target_email TEXT;

v_email_config RECORD;

v_delivery_mode public.notification_delivery_mode;

v_batch_window INTEGER;

v_final_priority public.notification_priority;

BEGIN -- Validate that at least user_id or email is provided
IF p_user_id IS NULL
AND p_email IS NULL THEN RAISE EXCEPTION 'Either p_user_id or p_email must be provided';

END IF;

-- Get email configuration for this notification type
SELECT
  * INTO v_email_config
FROM
  public.get_notification_email_config(COALESCE(p_type, p_code));

v_delivery_mode := COALESCE(v_email_config.delivery_mode, 'batched');

v_batch_window := COALESCE(v_email_config.batch_window_minutes, 10);

v_final_priority := COALESCE(v_email_config.priority_override, p_priority);

-- Determine target user_id and email
IF p_user_id IS NOT NULL THEN v_target_user_id := p_user_id;

-- Get email from user_id if not provided
IF p_email IS NULL THEN
SELECT
  email INTO v_target_email
FROM
  public.user_private_details
WHERE
  user_id = p_user_id;

ELSE v_target_email := p_email;

END IF;

ELSE -- Only email provided (pending user)
v_target_user_id := NULL;

v_target_email := p_email;

END IF;

-- Check if notifications are enabled (skip if no user_id for preferences)
IF v_target_user_id IS NOT NULL THEN v_should_send_web := public.should_send_notification(
  v_target_user_id,
  COALESCE(p_type, p_code),
  'web',
  p_scope,
  p_ws_id
);

ELSE -- For pending users, always create notification (they'll see it when they sign up)
v_should_send_web := TRUE;

END IF;

-- Only create notification if enabled
IF v_should_send_web THEN -- Create the notification
INSERT INTO
  public.notifications (
    ws_id,
    user_id,
    email,
    type,
    code,
    title,
    description,
    data,
    entity_type,
    entity_id,
    created_by,
    scope,
    priority
  )
VALUES
  (
    p_ws_id,
    v_target_user_id,
    v_target_email,
    p_type,
    p_code,
    p_title,
    p_description,
    p_data,
    p_entity_type,
    p_entity_id,
    p_created_by,
    p_scope,
    v_final_priority
  ) RETURNING id INTO v_notification_id;

-- Check if email notifications are enabled
IF v_target_user_id IS NOT NULL THEN v_should_send_email := public.should_send_notification(
  v_target_user_id,
  COALESCE(p_type, p_code),
  'email',
  p_scope,
  p_ws_id
);

ELSE -- For pending users, always send email
v_should_send_email := TRUE;

END IF;

-- If email is enabled, add to delivery queue
IF v_should_send_email
AND v_target_email IS NOT NULL THEN -- Get or create a batch with appropriate delivery mode
v_batch_id := public.get_or_create_notification_batch(
  p_ws_id,
  v_target_user_id,
  'email',
  v_batch_window,
  v_target_email,
  v_delivery_mode
);

-- Create delivery log entry
INSERT INTO
  public.notification_delivery_log (
    notification_id,
    channel,
    status,
    batch_id
  )
VALUES
  (
    v_notification_id,
    'email',
    'pending',
    v_batch_id
  );

-- Update batch notification count
UPDATE
  public.notification_batches
SET
  notification_count = notification_count + 1
WHERE
  id = v_batch_id;

END IF;

RETURN v_notification_id;

END IF;

RETURN NULL;

END;

$ $;

ALTER FUNCTION "public"."create_notification"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_email" "text",
  "p_type" "text",
  "p_code" "text",
  "p_title" "text",
  "p_description" "text",
  "p_data" "jsonb",
  "p_entity_type" "text",
  "p_entity_id" "uuid",
  "p_created_by" "uuid",
  "p_scope" "public"."notification_scope",
  "p_priority" "public"."notification_priority"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."create_notification"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_email" "text",
  "p_type" "text",
  "p_code" "text",
  "p_title" "text",
  "p_description" "text",
  "p_data" "jsonb",
  "p_entity_type" "text",
  "p_entity_id" "uuid",
  "p_created_by" "uuid",
  "p_scope" "public"."notification_scope",
  "p_priority" "public"."notification_priority"
) IS 'Creates a notification with support for workspace, user, and email-based notifications. All parameters have defaults for maximum flexibility. This is the canonical version that replaced multiple conflicting overloads.';

CREATE
OR REPLACE FUNCTION "public"."create_personal_workspace_for_new_user"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE new_workspace_id uuid;

BEGIN -- Check if user already has a personal workspace
IF NOT EXISTS (
  SELECT
    1
  FROM
    public.workspaces
  WHERE
    creator_id = NEW.id
    AND personal = true
) THEN -- Create a personal workspace for the new user
-- Note: Using SECURITY DEFINER allows bypassing RLS for initial workspace creation
INSERT INTO
  public.workspaces (
    name,
    creator_id,
    personal
  )
VALUES
  (
    'Personal',
    -- Default name, can be customized by user later
    NEW.id,
    true
  ) RETURNING id INTO new_workspace_id;

-- Add the user as a member of their personal workspace
INSERT INTO
  public.workspace_members (ws_id, user_id)
VALUES
  (new_workspace_id, NEW.id);

END IF;

RETURN NEW;

EXCEPTION
WHEN OTHERS THEN -- Log the error but don't fail user creation
RAISE WARNING 'Failed to create personal workspace for user %: %',
NEW.id,
SQLERRM;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."create_personal_workspace_for_new_user"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_system_announcement"(
  "p_title" "text",
  "p_description" "text",
  "p_priority" "public"."notification_priority" DEFAULT 'medium' :: "public"."notification_priority",
  "p_action_url" "text" DEFAULT NULL :: "text",
  "p_expires_at" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_data" "jsonb" DEFAULT '{}' :: "jsonb"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_notification_id UUID;

BEGIN -- Create system notification for all users (user_id can be NULL for broadcast)
INSERT INTO
  public.notifications (
    user_id,
    type,
    title,
    description,
    scope,
    priority,
    action_url,
    expires_at,
    data
  )
VALUES
  (
    NULL,
    -- NULL means broadcast to all users
    'system_announcement',
    p_title,
    p_description,
    'system',
    p_priority,
    p_action_url,
    p_expires_at,
    p_data
  ) RETURNING id INTO v_notification_id;

RETURN v_notification_id;

END;

$ $;

ALTER FUNCTION "public"."create_system_announcement"(
  "p_title" "text",
  "p_description" "text",
  "p_priority" "public"."notification_priority",
  "p_action_url" "text",
  "p_expires_at" timestamp with time zone,
  "p_data" "jsonb"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."create_system_announcement"(
  "p_title" "text",
  "p_description" "text",
  "p_priority" "public"."notification_priority",
  "p_action_url" "text",
  "p_expires_at" timestamp with time zone,
  "p_data" "jsonb"
) IS 'Creates a system-wide announcement visible to all users';

CREATE
OR REPLACE FUNCTION "public"."create_task_with_relationship"(
  "p_name" "text",
  "p_list_id" "uuid",
  "p_current_task_id" "uuid",
  "p_relationship_type" "public"."task_relationship_type",
  "p_current_task_is_source" boolean,
  "p_description" "text" DEFAULT NULL :: "text",
  "p_priority" smallint DEFAULT NULL :: smallint,
  "p_start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_estimation_points" smallint DEFAULT NULL :: smallint
) RETURNS "jsonb" LANGUAGE "plpgsql"
SET
  "search_path" TO 'public' AS $ $ DECLARE v_new_task_id UUID;

v_new_task JSONB;

v_relationship JSONB;

v_source_task_id UUID;

v_target_task_id UUID;

v_relationship_id UUID;

v_highest_sort_key BIGINT;

v_new_sort_key BIGINT;

v_user_id UUID;

v_list_exists BOOLEAN;

v_current_task_exists BOOLEAN;

BEGIN -- Get the current user
v_user_id := auth.uid();

IF v_user_id IS NULL THEN RAISE EXCEPTION 'User not authenticated';

END IF;

-- Validate inputs
IF p_name IS NULL
OR trim(p_name) = '' THEN RAISE EXCEPTION 'Task name is required';

END IF;

IF p_list_id IS NULL THEN RAISE EXCEPTION 'List ID is required';

END IF;

IF p_current_task_id IS NULL THEN RAISE EXCEPTION 'Current task ID is required';

END IF;

-- Verify the list exists and get board_id for RLS check
SELECT
  EXISTS(
    SELECT
      1
    FROM
      task_lists
    WHERE
      id = p_list_id
  ) INTO v_list_exists;

IF NOT v_list_exists THEN RAISE EXCEPTION 'List not found or access denied';

END IF;

-- Verify the current task exists
SELECT
  EXISTS(
    SELECT
      1
    FROM
      tasks
    WHERE
      id = p_current_task_id
      AND deleted_at IS NULL
  ) INTO v_current_task_exists;

IF NOT v_current_task_exists THEN RAISE EXCEPTION 'Current task not found';

END IF;

-- Get the highest sort_key in the list to place new task at the end
SELECT
  COALESCE(MAX(sort_key), 0) INTO v_highest_sort_key
FROM
  tasks
WHERE
  list_id = p_list_id
  AND deleted_at IS NULL;

-- Calculate new sort key (add 1,000,000 for proper spacing)
v_new_sort_key := v_highest_sort_key + 1000000;

-- Create the new task
-- Note: display_number and board_id are auto-assigned by database trigger
INSERT INTO
  tasks (
    name,
    description,
    list_id,
    priority,
    start_date,
    end_date,
    estimation_points,
    sort_key,
    creator_id,
    created_at
  )
VALUES
  (
    trim(p_name),
    p_description,
    p_list_id,
    p_priority,
    p_start_date,
    p_end_date,
    p_estimation_points,
    v_new_sort_key,
    v_user_id,
    now()
  ) RETURNING id INTO v_new_task_id;

-- Determine source and target based on relationship direction
IF p_current_task_is_source THEN v_source_task_id := p_current_task_id;

v_target_task_id := v_new_task_id;

ELSE v_source_task_id := v_new_task_id;

v_target_task_id := p_current_task_id;

END IF;

-- Create the relationship
INSERT INTO
  task_relationships (
    source_task_id,
    target_task_id,
    type,
    created_by,
    created_at
  )
VALUES
  (
    v_source_task_id,
    v_target_task_id,
    p_relationship_type,
    v_user_id,
    now()
  ) RETURNING id INTO v_relationship_id;

-- Fetch the complete task data with relations for the response
SELECT
  jsonb_build_object(
    'id',
    t.id,
    'name',
    t.name,
    'description',
    t.description,
    'list_id',
    t.list_id,
    'board_id',
    t.board_id,
    'display_number',
    t.display_number,
    'priority',
    t.priority,
    'start_date',
    t.start_date,
    'end_date',
    t.end_date,
    'estimation_points',
    t.estimation_points,
    'sort_key',
    t.sort_key,
    'completed',
    t.completed,
    'completed_at',
    t.completed_at,
    'closed_at',
    t.closed_at,
    'archived',
    t.archived,
    'creator_id',
    t.creator_id,
    'created_at',
    t.created_at,
    'assignees',
    COALESCE(
      (
        SELECT
          jsonb_agg(
            jsonb_build_object(
              'user',
              jsonb_build_object(
                'id',
                u.id,
                'display_name',
                u.display_name,
                'avatar_url',
                u.avatar_url
              )
            )
          )
        FROM
          task_assignees ta
          JOIN users u ON ta.user_id = u.id
        WHERE
          ta.task_id = t.id
      ),
      '[]' :: jsonb
    ),
    'labels',
    COALESCE(
      (
        SELECT
          jsonb_agg(
            jsonb_build_object(
              'label',
              jsonb_build_object(
                'id',
                wtl.id,
                'name',
                wtl.name,
                'color',
                wtl.color,
                'created_at',
                wtl.created_at
              )
            )
          )
        FROM
          task_labels tl
          JOIN workspace_task_labels wtl ON tl.label_id = wtl.id
        WHERE
          tl.task_id = t.id
      ),
      '[]' :: jsonb
    ),
    'projects',
    COALESCE(
      (
        SELECT
          jsonb_agg(
            jsonb_build_object(
              'project',
              jsonb_build_object(
                'id',
                tp.id,
                'name',
                tp.name,
                'status',
                tp.status
              )
            )
          )
        FROM
          task_project_tasks tpt
          JOIN task_projects tp ON tpt.project_id = tp.id
        WHERE
          tpt.task_id = t.id
      ),
      '[]' :: jsonb
    )
  ) INTO v_new_task
FROM
  tasks t
WHERE
  t.id = v_new_task_id;

-- Build relationship response
SELECT
  jsonb_build_object(
    'id',
    tr.id,
    'source_task_id',
    tr.source_task_id,
    'target_task_id',
    tr.target_task_id,
    'type',
    tr.type,
    'created_at',
    tr.created_at,
    'created_by',
    tr.created_by
  ) INTO v_relationship
FROM
  task_relationships tr
WHERE
  tr.id = v_relationship_id;

-- Return both the task and relationship
RETURN jsonb_build_object(
  'task',
  v_new_task,
  'relationship',
  v_relationship
);

EXCEPTION
WHEN unique_violation THEN -- Handle duplicate relationship
RAISE EXCEPTION 'This relationship already exists.';

WHEN OTHERS THEN -- Re-raise other errors
RAISE;

END;

$ $;

ALTER FUNCTION "public"."create_task_with_relationship"(
  "p_name" "text",
  "p_list_id" "uuid",
  "p_current_task_id" "uuid",
  "p_relationship_type" "public"."task_relationship_type",
  "p_current_task_is_source" boolean,
  "p_description" "text",
  "p_priority" smallint,
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_estimation_points" smallint
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."create_task_with_relationship"(
  "p_name" "text",
  "p_list_id" "uuid",
  "p_current_task_id" "uuid",
  "p_relationship_type" "public"."task_relationship_type",
  "p_current_task_is_source" boolean,
  "p_description" "text",
  "p_priority" smallint,
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_estimation_points" smallint
) IS 'Creates a new task and establishes a relationship with an existing task atomically.
Parameters:
- p_name: Name of the new task (required)
- p_list_id: ID of the list where the task will be created (required)
- p_current_task_id: ID of the existing task to relate to (required)
- p_relationship_type: Type of relationship (parent_child, blocks, related)
- p_current_task_is_source: Whether the current task is the source of the relationship
  - For parent: false (new task is parent, current is child)
  - For child/subtask: true (current task is parent, new is child)
  - For blocks: true (current task blocks new task)
  - For blocked-by: false (new task blocks current task)
  - For related: true (direction does not matter)
- p_description: Optional task description
- p_priority: Optional priority (smallint)
- p_start_date: Optional start date
- p_end_date: Optional end date
- p_estimation_points: Optional estimation points (0-8)

Returns JSONB with task and relationship objects.';

CREATE
OR REPLACE FUNCTION "public"."create_user_notification"(
  "p_user_id" "uuid",
  "p_type" "text",
  "p_title" "text",
  "p_description" "text" DEFAULT NULL :: "text",
  "p_priority" "public"."notification_priority" DEFAULT 'medium' :: "public"."notification_priority",
  "p_action_url" "text" DEFAULT NULL :: "text",
  "p_data" "jsonb" DEFAULT '{}' :: "jsonb"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN public.create_notification(
  p_user_id := p_user_id,
  p_type := p_type,
  p_title := p_title,
  p_description := p_description,
  p_scope := 'user',
  p_ws_id := NULL,
  p_data := p_data,
  p_priority := p_priority,
  p_action_url := p_action_url
);

END;

$ $;

ALTER FUNCTION "public"."create_user_notification"(
  "p_user_id" "uuid",
  "p_type" "text",
  "p_title" "text",
  "p_description" "text",
  "p_priority" "public"."notification_priority",
  "p_action_url" "text",
  "p_data" "jsonb"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."create_user_notification"(
  "p_user_id" "uuid",
  "p_type" "text",
  "p_title" "text",
  "p_description" "text",
  "p_priority" "public"."notification_priority",
  "p_action_url" "text",
  "p_data" "jsonb"
) IS 'Creates a user-level notification (account, security, etc.)';

CREATE
OR REPLACE FUNCTION "public"."create_user_profile"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE email_role RECORD;

BEGIN -- Insert the user ID into public.users
INSERT INTO
  public.users (id)
VALUES
  (NEW.id);

-- Check if the email exists in platform_email_roles
SELECT
  * INTO email_role
FROM
  public.platform_email_roles
WHERE
  email = NEW.email;

-- If email exists in platform_email_roles, use those settings
IF FOUND THEN -- Add user to platform_user_roles with settings from platform_email_roles
INSERT INTO
  public.platform_user_roles(
    user_id,
    enabled,
    allow_challenge_management,
    allow_manage_all_challenges,
    allow_role_management
  )
VALUES
  (
    NEW.id,
    email_role.enabled,
    email_role.allow_challenge_management,
    email_role.allow_manage_all_challenges,
    email_role.allow_role_management
  );

-- Delete the entry from platform_email_roles
DELETE FROM
  public.platform_email_roles
WHERE
  email = NEW.email;

ELSE -- Default behavior: add user to platform_user_roles with default settings
INSERT INTO
  public.platform_user_roles(user_id, enabled)
VALUES
  (NEW.id, false);

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."create_user_profile"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_workspace_system_calendars"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Create primary calendar
INSERT INTO
  public.workspace_calendars (
    ws_id,
    name,
    description,
    color,
    calendar_type,
    is_system,
    position
  )
VALUES
  (
    NEW.id,
    'Primary',
    'Default calendar for events',
    'BLUE',
    'primary',
    true,
    0
  );

-- Create tasks calendar
INSERT INTO
  public.workspace_calendars (
    ws_id,
    name,
    description,
    color,
    calendar_type,
    is_system,
    position
  )
VALUES
  (
    NEW.id,
    'Tasks',
    'Smart scheduled tasks',
    'PURPLE',
    'tasks',
    true,
    1
  );

-- Create habits calendar
INSERT INTO
  public.workspace_calendars (
    ws_id,
    name,
    description,
    color,
    calendar_type,
    is_system,
    position
  )
VALUES
  (
    NEW.id,
    'Habits',
    'Habit instances',
    'GREEN',
    'habits',
    true,
    2
  );

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."create_workspace_system_calendars"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."create_workspace_user_linked_user"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin if not exists (
  select
    1
  from
    workspace_users wu
    join user_private_details up on wu.email = up.email
  where
    up.user_id = new.user_id
    and wu.ws_id = new.ws_id
)
and not exists (
  select
    1
  from
    workspace_user_linked_users wul
  where
    wul.platform_user_id = new.user_id
    and wul.ws_id = new.ws_id
) then
insert into
  workspace_users (id, ws_id, display_name, email)
select
  gen_random_uuid(),
  new.ws_id,
  u.display_name,
  up.email
from
  users u
  join user_private_details up on up.user_id = u.id
where
  u.id = new.user_id;

insert into
  workspace_user_linked_users (platform_user_id, virtual_user_id, ws_id)
select
  new.user_id,
  wu.id,
  new.ws_id
from
  workspace_users wu
  join user_private_details up on up.email = wu.email
where
  up.user_id = new.user_id
  and wu.ws_id = new.ws_id;

end if;

return new;

end;

$ $;

ALTER FUNCTION "public"."create_workspace_user_linked_user"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."delete_complementary_transaction"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN
DELETE FROM
  public.wallet_transactions
WHERE
  id = OLD.from_transaction_id
  OR id = OLD.to_transaction_id;

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."delete_complementary_transaction"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."delete_invite_when_accepted"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ begin -- Delete the invite
delete FROM
  public.workspace_invites i
WHERE
  i.ws_id = new.ws_id
  AND i.user_id = auth.uid();

delete FROM
  public.workspace_email_invites i
WHERE
  i.ws_id = new.ws_id
  AND lower(i.email) = lower(auth.email());

return new;

end;

$ $;

ALTER FUNCTION "public"."delete_invite_when_accepted"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."delete_wallet_transaction"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN
DELETE FROM
  wallet_transactions wt
WHERE
  wt.id = OLD.transaction_id;

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."delete_wallet_transaction"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."delete_workspace_member_when_unlink"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin
delete from
  workspace_members wm
where
  wm.user_id = old.platform_user_id
  and wm.ws_id = old.ws_id;

return old;

end;

$ $;

ALTER FUNCTION "public"."delete_workspace_member_when_unlink"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."enforce_extended_estimation"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF NEW.extended_estimation = FALSE THEN -- tasks doesn't have board_id, so we need to join with workspace_boards via list_id
UPDATE
  "public"."tasks" t
SET
  estimation_points = 5
FROM
  "public"."task_lists" tl
  JOIN "public"."workspace_boards" wb ON tl.board_id = wb.id
WHERE
  t.list_id = tl.id
  AND wb.id = NEW.id
  AND t.estimation_points > 5;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."enforce_extended_estimation"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."enforce_single_parent_constraint"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Only check for parent_child relationships
IF NEW.type = 'parent_child' THEN -- Check if the target task already has a parent
IF EXISTS (
  SELECT
    1
  FROM
    public.task_relationships
  WHERE
    target_task_id = NEW.target_task_id
    AND type = 'parent_child'
    AND id != COALESCE(
      NEW.id,
      '00000000-0000-0000-0000-000000000000' :: uuid
    )
) THEN RAISE EXCEPTION 'Task % already has a parent. A sub-task can only have one parent.',
NEW.target_task_id;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."enforce_single_parent_constraint"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."ensure_single_closed_list"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN -- Check if we're inserting/updating to closed status
IF NEW.status = 'closed' THEN -- Check if there's already a closed list for this board (excluding current record for updates)
IF EXISTS (
  SELECT
    1
  FROM
    task_lists
  WHERE
    board_id = NEW.board_id
    AND status = 'closed'
    AND deleted = false
    AND (
      TG_OP = 'INSERT'
      OR id != NEW.id
    )
) THEN RAISE EXCEPTION 'Only one closed list is allowed per board';

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."ensure_single_closed_list"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."extract_domain"("url" "text") RETURNS "text" LANGUAGE "plpgsql" IMMUTABLE AS $ _ $ BEGIN -- Handle various URL formats and extract the domain
RETURN CASE
  WHEN url ~ '^https?://' THEN -- Extract domain from full URL
  REGEXP_REPLACE(
    REGEXP_REPLACE(url, '^https?://', ''),
    '/.*$',
    ''
  )
  WHEN url ~ '^//' THEN -- Handle protocol-relative URLs
  REGEXP_REPLACE(
    REGEXP_REPLACE(url, '^//', ''),
    '/.*$',
    ''
  )
  ELSE -- If it's already a domain or malformed, try to clean it
  REGEXP_REPLACE(url, '/.*$', '')
END;

END;

$ _ $;

ALTER FUNCTION "public"."extract_domain"("url" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."extract_referrer_domain"("url" "text") RETURNS "text" LANGUAGE "plpgsql" IMMUTABLE AS $ _ $ BEGIN -- Handle various referrer formats and extract the domain
RETURN CASE
  WHEN url IS NULL
  OR url = '' THEN NULL
  WHEN url ~ '^https?://' THEN -- Extract domain from full URL
  REGEXP_REPLACE(
    REGEXP_REPLACE(url, '^https?://', ''),
    '/.*$',
    ''
  )
  WHEN url ~ '^//' THEN -- Handle protocol-relative URLs
  REGEXP_REPLACE(
    REGEXP_REPLACE(url, '^//', ''),
    '/.*$',
    ''
  )
  ELSE -- If it's already a domain or malformed, try to clean it
  REGEXP_REPLACE(url, '/.*$', '')
END;

END;

$ _ $;

ALTER FUNCTION "public"."extract_referrer_domain"("url" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."fn_prevent_invalid_referral_link"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE promo record;

BEGIN -- Get the promotion details
SELECT
  * INTO promo
FROM
  public.workspace_promotions
WHERE
  id = NEW.promo_id;

-- If it's a referral promo, ensure the user is the owner
IF promo.promo_type = 'REFERRAL'
AND promo.owner_id IS DISTINCT
FROM
  NEW.user_id THEN RAISE EXCEPTION 'Referral promotions can only be linked to their owner.';

END IF;

-- If the check passes, allow the insertion to proceed
RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."fn_prevent_invalid_referral_link"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."fn_prevent_owner_referral_unlink"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE promo record;

BEGIN -- Get the promotion details from the main promotions table
SELECT
  * INTO promo
FROM
  public.workspace_promotions
WHERE
  id = OLD.promo_id;

-- Check if it's a referral promo and the user is the owner
IF promo.promo_type = 'REFERRAL'
AND promo.owner_id = OLD.user_id THEN RAISE EXCEPTION 'You cannot unlink your own referral promotion.';

END IF;

-- If the check passes, allow the deletion to proceed
RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."fn_prevent_owner_referral_unlink"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."generate_cross_app_token"(
  "p_user_id" "uuid",
  "p_origin_app" "text",
  "p_target_app" "text",
  "p_expiry_seconds" integer DEFAULT 300
) RETURNS "text" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_token TEXT;

BEGIN -- Generate a secure random token
v_token := encode(gen_random_bytes(32), 'hex');

-- Insert the token into the database
INSERT INTO
  public.cross_app_tokens (
    user_id,
    token,
    expires_at,
    origin_app,
    target_app
  )
VALUES
  (
    p_user_id,
    v_token,
    now() + (p_expiry_seconds * INTERVAL '1 second'),
    p_origin_app,
    p_target_app
  );

-- Return the token
RETURN v_token;

END;

$ $;

ALTER FUNCTION "public"."generate_cross_app_token"(
  "p_user_id" "uuid",
  "p_origin_app" "text",
  "p_target_app" "text",
  "p_expiry_seconds" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."generate_cross_app_token"(
  "p_user_id" "uuid",
  "p_origin_app" "text",
  "p_target_app" "text",
  "p_expiry_seconds" integer DEFAULT 300,
  "p_session_data" "jsonb" DEFAULT NULL :: "jsonb"
) RETURNS "text" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_token TEXT;

BEGIN -- Generate a secure random token
v_token := encode(gen_random_bytes(32), 'hex');

-- Log the session data for debugging
RAISE NOTICE 'Storing session data: %',
p_session_data;

-- Insert the token into the database with session data
INSERT INTO
  public.cross_app_tokens (
    user_id,
    token,
    expires_at,
    origin_app,
    target_app,
    session_data
  )
VALUES
  (
    p_user_id,
    v_token,
    now() + (p_expiry_seconds * INTERVAL '1 second'),
    p_origin_app,
    p_target_app,
    p_session_data
  );

-- Return the token
RETURN v_token;

END;

$ $;

ALTER FUNCTION "public"."generate_cross_app_token"(
  "p_user_id" "uuid",
  "p_origin_app" "text",
  "p_target_app" "text",
  "p_expiry_seconds" integer,
  "p_session_data" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_action_frequency_by_hour"() RETURNS TABLE("hour_of_day" integer, "action_count" bigint) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  EXTRACT(
    HOUR
    FROM
      created_at
  ) :: integer AS hour_of_day,
  COUNT(*) AS action_count
FROM
  auth.audit_log_entries
WHERE
  created_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY
  EXTRACT(
    HOUR
    FROM
      created_at
  )
ORDER BY
  hour_of_day;

$ $;

ALTER FUNCTION "public"."get_action_frequency_by_hour"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_active_ip_block"("p_ip_address" "text") RETURNS TABLE(
  "id" "uuid",
  "block_level" integer,
  "reason" "public"."abuse_event_type",
  "expires_at" timestamp with time zone,
  "blocked_at" timestamp with time zone
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY
SELECT
  b.id,
  b.block_level,
  b.reason,
  b.expires_at,
  b.blocked_at
FROM
  public.blocked_ips b
WHERE
  b.ip_address = p_ip_address
  AND b.status = 'active'
  AND b.expires_at > NOW()
ORDER BY
  b.expires_at DESC
LIMIT
  1;

END;

$ $;

ALTER FUNCTION "public"."get_active_ip_block"("p_ip_address" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_active_ip_block"("p_ip_address" "text") IS 'Returns active block information for an IP address if it exists';

CREATE
OR REPLACE FUNCTION "public"."get_active_sessions_count"() RETURNS bigint LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  COUNT(*)
FROM
  auth.sessions
WHERE
  not_after IS NULL
  OR not_after > NOW();

$ $;

ALTER FUNCTION "public"."get_active_sessions_count"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_active_sessions_count"() IS 'Returns count of currently active sessions';

CREATE
OR REPLACE FUNCTION "public"."get_activity_heatmap"() RETURNS TABLE(
  "day_of_week" integer,
  "hour_of_day" integer,
  "activity_count" bigint
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  EXTRACT(
    DOW
    FROM
      updated_at
  ) :: integer AS day_of_week,
  EXTRACT(
    HOUR
    FROM
      updated_at
  ) :: integer AS hour_of_day,
  COUNT(*) AS activity_count
FROM
  auth.sessions
WHERE
  updated_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY
  EXTRACT(
    DOW
    FROM
      updated_at
  ),
  EXTRACT(
    HOUR
    FROM
      updated_at
  )
ORDER BY
  day_of_week,
  hour_of_day;

$ $;

ALTER FUNCTION "public"."get_activity_heatmap"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_ai_execution_daily_stats_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_pricing" "jsonb" DEFAULT NULL :: "jsonb"
) RETURNS TABLE(
  "date" "date",
  "executions" bigint,
  "total_cost_usd" numeric,
  "total_tokens" bigint,
  "input_tokens" bigint,
  "output_tokens" bigint,
  "reasoning_tokens" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_pricing JSONB := COALESCE(p_pricing, get_default_ai_pricing());

BEGIN RETURN QUERY
SELECT
  DATE(wae.created_at) as date,
  COUNT(*) :: BIGINT as executions,
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as total_cost_usd,
  SUM(wae.total_tokens) :: BIGINT as total_tokens,
  SUM(wae.input_tokens) :: BIGINT as input_tokens,
  SUM(wae.output_tokens) :: BIGINT as output_tokens,
  SUM(wae.reasoning_tokens) :: BIGINT as reasoning_tokens
FROM
  workspace_ai_executions wae
WHERE
  wae.ws_id = p_ws_id
  AND (
    p_start_date IS NULL
    OR wae.created_at >= p_start_date
  )
  AND (
    p_end_date IS NULL
    OR wae.created_at <= p_end_date
  )
GROUP BY
  DATE(wae.created_at)
ORDER BY
  date;

END;

$ $;

ALTER FUNCTION "public"."get_ai_execution_daily_stats_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_pricing" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_ai_execution_model_stats_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_pricing" "jsonb" DEFAULT NULL :: "jsonb"
) RETURNS TABLE(
  "model_id" "text",
  "executions" bigint,
  "total_cost_usd" numeric,
  "total_tokens" bigint,
  "avg_cost_per_execution" numeric,
  "avg_tokens_per_execution" numeric,
  "percentage_of_total" numeric
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE total_executions BIGINT;

v_pricing JSONB := COALESCE(p_pricing, get_default_ai_pricing());

BEGIN
SELECT
  COUNT(*) INTO total_executions
FROM
  workspace_ai_executions
WHERE
  ws_id = p_ws_id
  AND (
    p_start_date IS NULL
    OR created_at >= p_start_date
  )
  AND (
    p_end_date IS NULL
    OR created_at <= p_end_date
  );

RETURN QUERY
SELECT
  wae.model_id,
  COUNT(*) :: BIGINT as executions,
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as total_cost_usd,
  SUM(wae.total_tokens) :: BIGINT as total_tokens,
  COALESCE(
    AVG(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as avg_cost_per_execution,
  COALESCE(AVG(wae.total_tokens :: NUMERIC), 0) as avg_tokens_per_execution,
  CASE
    WHEN total_executions > 0 THEN (COUNT(*) :: NUMERIC / total_executions) * 100
    ELSE 0
  END as percentage_of_total
FROM
  workspace_ai_executions wae
WHERE
  wae.ws_id = p_ws_id
  AND (
    p_start_date IS NULL
    OR wae.created_at >= p_start_date
  )
  AND (
    p_end_date IS NULL
    OR wae.created_at <= p_end_date
  )
GROUP BY
  wae.model_id
ORDER BY
  executions DESC;

END;

$ $;

ALTER FUNCTION "public"."get_ai_execution_model_stats_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_pricing" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_ai_execution_monthly_cost_v2"(
  "p_ws_id" "uuid",
  "p_year" integer DEFAULT EXTRACT(
    year
    FROM
      CURRENT_DATE
  ),
  "p_month" integer DEFAULT EXTRACT(
    month
    FROM
      CURRENT_DATE
  ),
  "p_pricing" "jsonb" DEFAULT NULL :: "jsonb",
  "p_exchange_rate" numeric DEFAULT 26000
) RETURNS TABLE(
  "total_cost_usd" numeric,
  "total_cost_vnd" numeric,
  "executions" bigint,
  "avg_daily_cost" numeric
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_pricing JSONB := COALESCE(p_pricing, get_default_ai_pricing());

BEGIN RETURN QUERY
SELECT
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as total_cost_usd,
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ) * p_exchange_rate,
    0
  ) as total_cost_vnd,
  COUNT(*) :: BIGINT as executions,
  COALESCE(
    AVG(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as avg_daily_cost
FROM
  workspace_ai_executions wae
WHERE
  wae.ws_id = p_ws_id
  AND EXTRACT(
    YEAR
    FROM
      wae.created_at
  ) = p_year
  AND EXTRACT(
    MONTH
    FROM
      wae.created_at
  ) = p_month;

END;

$ $;

ALTER FUNCTION "public"."get_ai_execution_monthly_cost_v2"(
  "p_ws_id" "uuid",
  "p_year" integer,
  "p_month" integer,
  "p_pricing" "jsonb",
  "p_exchange_rate" numeric
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_ai_execution_summary_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_pricing" "jsonb" DEFAULT NULL :: "jsonb",
  "p_exchange_rate" numeric DEFAULT 26000
) RETURNS TABLE(
  "total_executions" bigint,
  "total_cost_usd" numeric,
  "total_cost_vnd" numeric,
  "total_tokens" bigint,
  "total_input_tokens" bigint,
  "total_output_tokens" bigint,
  "total_reasoning_tokens" bigint,
  "avg_cost_per_execution" numeric,
  "avg_tokens_per_execution" numeric
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_pricing JSONB := COALESCE(p_pricing, get_default_ai_pricing());

BEGIN RETURN QUERY
SELECT
  COUNT(*) :: BIGINT as total_executions,
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as total_cost_usd,
  COALESCE(
    SUM(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ) * p_exchange_rate,
    0
  ) as total_cost_vnd,
  SUM(wae.total_tokens) :: BIGINT as total_tokens,
  SUM(wae.input_tokens) :: BIGINT as total_input_tokens,
  SUM(wae.output_tokens) :: BIGINT as total_output_tokens,
  SUM(wae.reasoning_tokens) :: BIGINT as total_reasoning_tokens,
  COALESCE(
    AVG(
      compute_ai_cost_usd(
        wae.model_id,
        wae.input_tokens,
        wae.output_tokens,
        wae.reasoning_tokens,
        v_pricing
      )
    ),
    0
  ) as avg_cost_per_execution,
  COALESCE(AVG(wae.total_tokens :: NUMERIC), 0) as avg_tokens_per_execution
FROM
  workspace_ai_executions wae
WHERE
  wae.ws_id = p_ws_id
  AND (
    p_start_date IS NULL
    OR wae.created_at >= p_start_date
  )
  AND (
    p_end_date IS NULL
    OR wae.created_at <= p_end_date
  );

END;

$ $;

ALTER FUNCTION "public"."get_ai_execution_summary_v2"(
  "p_ws_id" "uuid",
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_pricing" "jsonb",
  "p_exchange_rate" numeric
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_auth_provider_stats"() RETURNS TABLE(
  "provider" "text",
  "user_count" bigint,
  "percentage" numeric,
  "last_sign_in_avg" interval
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH provider_counts AS (
    SELECT
      i.provider,
      COUNT(DISTINCT i.user_id) AS user_count,
      AVG(NOW() - i.last_sign_in_at) AS avg_time_since_last_sign_in
    FROM
      auth.identities i
    GROUP BY
      i.provider
  ),
  total AS (
    SELECT
      COUNT(DISTINCT user_id) AS total_users
    FROM
      auth.identities
  )
SELECT
  pc.provider,
  pc.user_count,
  ROUND(
    (
      pc.user_count :: numeric / t.total_users :: numeric * 100
    ),
    2
  ) AS percentage,
  pc.avg_time_since_last_sign_in AS last_sign_in_avg
FROM
  provider_counts pc,
  total t
ORDER BY
  pc.user_count DESC;

$ $;

ALTER FUNCTION "public"."get_auth_provider_stats"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_auth_provider_stats"() IS 'Returns statistics grouped by authentication provider';

CREATE
OR REPLACE FUNCTION "public"."get_auth_session_statistics"() RETURNS TABLE(
  "total_sessions" bigint,
  "active_sessions" bigint,
  "avg_session_duration_hours" numeric,
  "median_session_duration_minutes" numeric,
  "sessions_today" bigint,
  "sessions_this_week" bigint,
  "sessions_this_month" bigint
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  COUNT(*) AS total_sessions,
  COUNT(*) FILTER (
    WHERE
      not_after IS NULL
      OR not_after > NOW()
  ) AS active_sessions,
  ROUND(
    AVG(
      EXTRACT(
        EPOCH
        FROM
          (COALESCE(not_after, NOW()) - created_at)
      ) / 3600
    ) :: numeric,
    2
  ) AS avg_session_duration_hours,
  ROUND(
    (
      (
        PERCENTILE_CONT(0.5) WITHIN GROUP (
          ORDER BY
            (
              EXTRACT(
                EPOCH
                FROM
                  (COALESCE(not_after, NOW()) - created_at)
              )
            )
        )
      ) / 60
    ) :: numeric,
    2
  ) AS median_session_duration_minutes,
  COUNT(*) FILTER (
    WHERE
      created_at >= CURRENT_DATE
  ) AS sessions_today,
  COUNT(*) FILTER (
    WHERE
      created_at >= CURRENT_DATE - INTERVAL '7 days'
  ) AS sessions_this_week,
  COUNT(*) FILTER (
    WHERE
      created_at >= CURRENT_DATE - INTERVAL '30 days'
  ) AS sessions_this_month
FROM
  auth.sessions;

$ $;

ALTER FUNCTION "public"."get_auth_session_statistics"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_auth_session_statistics"() IS 'Returns comprehensive auth session statistics, including median duration.';

CREATE
OR REPLACE FUNCTION "public"."get_available_referral_users"("p_ws_id" "uuid", "p_user_id" "uuid") RETURNS TABLE(
  "id" "uuid",
  "full_name" "text",
  "display_name" "text",
  "email" "text",
  "phone" "text"
) LANGUAGE "sql" AS $ $ WITH current AS (
  SELECT
    referred_by
  FROM
    public.workspace_users
  WHERE
    id = p_user_id
  LIMIT
    1
)
SELECT
  wu.id,
  wu.full_name,
  wu.display_name,
  wu.email,
  wu.phone
FROM
  public.workspace_users wu
  CROSS JOIN current c
WHERE
  wu.ws_id = p_ws_id
  AND wu.archived = false
  AND wu.id <> p_user_id -- Exclude the current user's own referrer if any
  AND (
    c.referred_by IS NULL
    OR wu.id <> c.referred_by
  ) -- Exclude users who have already been referred by someone
  AND wu.referred_by IS NULL
  AND is_org_member(auth.uid(), p_ws_id)
ORDER BY
  wu.full_name NULLS LAST;

$ $;

ALTER FUNCTION "public"."get_available_referral_users"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_available_referral_users"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns available referral candidates: excludes self, and anyone already referred.';

CREATE
OR REPLACE FUNCTION "public"."get_blocked_tasks"("p_task_id" "uuid") RETURNS TABLE("task_id" "uuid") LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $
SELECT
  target_task_id AS task_id
FROM
  public.task_relationships
WHERE
  source_task_id = p_task_id
  AND type = 'blocks';

$ $;

ALTER FUNCTION "public"."get_blocked_tasks"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_blocked_tasks"("p_task_id" "uuid") IS 'Returns all tasks that are blocked by the given task';

CREATE
OR REPLACE FUNCTION "public"."get_blocking_tasks"("p_task_id" "uuid") RETURNS TABLE("task_id" "uuid") LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $
SELECT
  source_task_id AS task_id
FROM
  public.task_relationships
WHERE
  target_task_id = p_task_id
  AND type = 'blocks';

$ $;

ALTER FUNCTION "public"."get_blocking_tasks"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_blocking_tasks"("p_task_id" "uuid") IS 'Returns all tasks that are blocking the given task';

CREATE
OR REPLACE FUNCTION "public"."get_bounce_complaint_stats"(
  "p_since" timestamp with time zone DEFAULT ("now"() - '30 days' :: interval)
) RETURNS TABLE(
  "total_events" bigint,
  "hard_bounces" bigint,
  "soft_bounces" bigint,
  "complaints" bigint,
  "unique_emails_affected" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY
SELECT
  COUNT(*) :: BIGINT AS total_events,
  COUNT(*) FILTER (
    WHERE
      event_type = 'bounce'
      AND bounce_type = 'hard'
  ) :: BIGINT AS hard_bounces,
  COUNT(*) FILTER (
    WHERE
      event_type = 'bounce'
      AND bounce_type IN ('soft', 'transient')
  ) :: BIGINT AS soft_bounces,
  COUNT(*) FILTER (
    WHERE
      event_type = 'complaint'
  ) :: BIGINT AS complaints,
  COUNT(DISTINCT email_hash) :: BIGINT AS unique_emails_affected
FROM
  public.email_bounce_complaints
WHERE
  created_at >= p_since;

END;

$ $;

ALTER FUNCTION "public"."get_bounce_complaint_stats"("p_since" timestamp with time zone) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_browsers"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("browser" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.browser, 'Unknown') AS browser,
  COUNT(*) AS count
FROM
  link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  COALESCE(la.browser, 'Unknown')
ORDER BY
  count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_browsers"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_budget_status"("_ws_id" "uuid") RETURNS TABLE(
  "budget_id" "uuid",
  "budget_name" "text",
  "amount" numeric,
  "spent" numeric,
  "remaining" numeric,
  "percentage_used" numeric,
  "is_over_budget" boolean,
  "is_near_threshold" boolean
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  fb.id,
  fb.name,
  fb.amount,
  fb.spent,
  fb.amount - fb.spent AS remaining,
  CASE
    WHEN fb.amount > 0 THEN ROUND((fb.spent / fb.amount * 100) :: numeric, 2)
    ELSE 0
  END AS percentage_used,
  fb.spent > fb.amount AS is_over_budget,
  CASE
    WHEN fb.amount > 0 THEN (fb.spent / fb.amount * 100) >= fb.alert_threshold
    ELSE false
  END AS is_near_threshold
FROM
  finance_budgets fb
WHERE
  fb.ws_id = _ws_id
  AND fb.is_active = true
ORDER BY
  fb.created_at DESC;

END;

$ $;

ALTER FUNCTION "public"."get_budget_status"("_ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_challenge_stats"(
  "challenge_id_param" "uuid",
  "user_id_param" "uuid"
) RETURNS TABLE(
  "total_score" double precision,
  "problems_attempted" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY WITH user_sessions AS (
  SELECT
    id
  FROM
    nova_sessions
  WHERE
    challenge_id = challenge_id_param
    AND user_id = user_id_param
),
best_submission_per_problem_per_session AS (
  -- For each session, find the best score for each problem
  SELECT
    us.id AS session_id,
    s.problem_id,
    MAX(s.total_score) AS best_problem_score
  FROM
    user_sessions us
    JOIN nova_submissions_with_scores s ON s.session_id = us.id
  GROUP BY
    us.id,
    s.problem_id
),
session_scores AS (
  -- Calculate each session's total from the best score per problem
  SELECT
    session_id,
    SUM(best_problem_score) AS session_total_score,
    COUNT(problem_id) AS session_problems_attempted
  FROM
    best_submission_per_problem_per_session
  GROUP BY
    session_id
),
best_session AS (
  -- Find the session with the highest total score
  SELECT
    session_total_score,
    session_problems_attempted
  FROM
    session_scores
  ORDER BY
    session_total_score DESC
  LIMIT
    1
) -- Return the best session stats, or zeros if no sessions exist
SELECT
  COALESCE(
    (
      SELECT
        session_total_score
      FROM
        best_session
    ),
    0
  ) AS total_score,
  COALESCE(
    (
      SELECT
        session_problems_attempted
      FROM
        best_session
    ),
    0
  ) AS problems_attempted;

END;

$ $;

ALTER FUNCTION "public"."get_challenge_stats"(
  "challenge_id_param" "uuid",
  "user_id_param" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_clicks_by_day"("p_link_id" "uuid", "p_days" integer DEFAULT 30) RETURNS TABLE("click_date" "date", "clicks" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  date_trunc('day', la.clicked_at) :: date,
  COUNT(*)
FROM
  public.link_analytics la
WHERE
  la.link_id = p_link_id
  AND la.clicked_at >= now() - (p_days || ' days') :: interval
GROUP BY
  1
ORDER BY
  1 DESC;

END;

$ $;

ALTER FUNCTION "public"."get_clicks_by_day"("p_link_id" "uuid", "p_days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_clicks_by_day_of_week"("p_link_id" "uuid") RETURNS TABLE(
  "day_of_week" integer,
  "day_name" "text",
  "clicks" bigint
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH days AS (
  SELECT
    s AS day_of_week,
    CASE
      s
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
    END AS day_name
  FROM
    generate_series(0, 6) AS s
)
SELECT
  d.day_of_week,
  d.day_name,
  COALESCE(COUNT(la.clicked_at), 0) AS clicks
FROM
  days d
  LEFT JOIN link_analytics la ON EXTRACT(
    DOW
    FROM
      la.clicked_at
  ) = d.day_of_week
  AND la.link_id = p_link_id
GROUP BY
  d.day_of_week,
  d.day_name
ORDER BY
  d.day_of_week;

END;

$ $;

ALTER FUNCTION "public"."get_clicks_by_day_of_week"("p_link_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_clicks_by_hour"("p_link_id" "uuid") RETURNS TABLE("hour" integer, "clicks" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH hours AS (
  SELECT
    generate_series(0, 23) AS hour
)
SELECT
  h.hour,
  COALESCE(COUNT(la.clicked_at), 0) AS clicks
FROM
  hours h
  LEFT JOIN link_analytics la ON EXTRACT(
    HOUR
    FROM
      la.clicked_at
  ) = h.hour
  AND la.link_id = p_link_id
GROUP BY
  h.hour
ORDER BY
  h.hour;

END;

$ $;

ALTER FUNCTION "public"."get_clicks_by_hour"("p_link_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_created_workspace_count"("user_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspaces
WHERE
  creator_id = $ 1
  AND deleted = false $ _ $;

ALTER FUNCTION "public"."get_created_workspace_count"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_daily_activity_heatmap"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT NULL :: "uuid",
  "p_days_back" integer DEFAULT 365
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE activity_data JSON;

user_filter TEXT := '';

BEGIN -- Set secure search path to prevent function hijacking
PERFORM set_config('search_path', 'public, pg_temp', true);

-- Validate input parameters
IF p_days_back <= 0
OR p_days_back > 1095 THEN -- Max 3 years
RAISE EXCEPTION 'Days back must be between 1 and 1095';

END IF;

-- Check workspace membership authorization
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: not a member of this workspace';

END IF;

-- If specific user requested, ensure it's either the current user or user has admin access
IF p_user_id IS NOT NULL
AND p_user_id != auth.uid() THEN IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
    AND wm.role IN ('ADMIN', 'OWNER')
) THEN RAISE EXCEPTION 'Access denied: insufficient permissions to view other users data';

END IF;

END IF;

-- Add user filter if specified
IF p_user_id IS NOT NULL THEN user_filter := FORMAT(' AND user_id = ''%s''', p_user_id);

END IF;

-- Get daily activity data
EXECUTE FORMAT(
  'SELECT JSON_AGG(
            JSON_BUILD_OBJECT(
                ''date'', date::TEXT,
                ''duration'', total_duration,
                ''sessions'', session_count,
                ''users'', unique_users
            ) ORDER BY date
        ) as activity
        FROM (
            SELECT 
                date,
                SUM(COALESCE(duration_seconds, 0)) as total_duration,
                COUNT(*) as session_count,
                COUNT(DISTINCT user_id) as unique_users
            FROM time_tracking_sessions
            WHERE ws_id = ''%s''%s 
                AND date >= CURRENT_DATE - INTERVAL ''%s days''
                AND duration_seconds IS NOT NULL
            GROUP BY date
            ORDER BY date
        ) daily_stats',
  p_ws_id,
  user_filter,
  p_days_back
) INTO activity_data;

RETURN COALESCE(activity_data, '[]' :: JSON);

END;

$ $;

ALTER FUNCTION "public"."get_daily_activity_heatmap"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_days_back" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_daily_income_expense"("_ws_id" "uuid", "past_days" integer DEFAULT 14) RETURNS TABLE(
  "day" "date",
  "total_income" numeric,
  "total_expense" numeric
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH date_series AS (
  SELECT
    generate_series(
      CURRENT_DATE - (past_days - 1),
      CURRENT_DATE,
      '1 day' :: interval
    ) :: DATE AS day
),
daily_transactions AS (
  SELECT
    date_trunc('day', wt.taken_at :: timestamp) :: DATE AS day,
    SUM(
      CASE
        WHEN wt.amount > 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS income,
    SUM(
      CASE
        WHEN wt.amount < 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS expense
  FROM
    wallet_transactions wt
    INNER JOIN workspace_wallets ww ON wt.wallet_id = ww.id
  WHERE
    wt.taken_at :: date >= CURRENT_DATE - (past_days - 1)
    AND ww.ws_id = _ws_id
  GROUP BY
    date_trunc('day', wt.taken_at :: timestamp) :: DATE
)
SELECT
  ds.day,
  COALESCE(dt.income, 0) :: NUMERIC AS total_income,
  ABS(COALESCE(dt.expense, 0)) :: NUMERIC AS total_expense
FROM
  date_series ds
  LEFT JOIN daily_transactions dt ON ds.day = dt.day
ORDER BY
  ds.day;

END;

$ $;

ALTER FUNCTION "public"."get_daily_income_expense"("_ws_id" "uuid", "past_days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_daily_income_expense"(
  "_ws_id" "uuid",
  "past_days" integer DEFAULT 14,
  "include_confidential" boolean DEFAULT true
) RETURNS TABLE(
  "day" "date",
  "total_income" numeric,
  "total_expense" numeric
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(_ws_id, auth.uid(), 'view_confidential_amount');

RETURN QUERY WITH date_series AS (
  SELECT
    generate_series(
      CURRENT_DATE - (past_days - 1),
      CURRENT_DATE,
      '1 day' :: interval
    ) :: DATE AS day
),
daily_transactions AS (
  SELECT
    date_trunc('day', wt.taken_at :: timestamp) :: DATE AS day,
    SUM(
      CASE
        WHEN wt.amount > 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS income,
    SUM(
      CASE
        WHEN wt.amount < 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS expense
  FROM
    wallet_transactions wt
    INNER JOIN workspace_wallets ww ON wt.wallet_id = ww.id
  WHERE
    wt.taken_at :: date >= CURRENT_DATE - (past_days - 1)
    AND ww.ws_id = _ws_id -- Confidential filtering
    AND (
      (
        NOT include_confidential
        AND NOT wt.is_amount_confidential
      )
      OR (
        include_confidential
        AND (
          NOT wt.is_amount_confidential
          OR can_view_amount
        )
      )
    )
  GROUP BY
    date_trunc('day', wt.taken_at :: timestamp) :: DATE
)
SELECT
  ds.day,
  COALESCE(dt.income, 0) :: NUMERIC AS total_income,
  ABS(COALESCE(dt.expense, 0)) :: NUMERIC AS total_expense
FROM
  date_series ds
  LEFT JOIN daily_transactions dt ON ds.day = dt.day
ORDER BY
  ds.day;

END;

$ $;

ALTER FUNCTION "public"."get_daily_income_expense"(
  "_ws_id" "uuid",
  "past_days" integer,
  "include_confidential" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_daily_income_expense"(
  "_ws_id" "uuid",
  "past_days" integer,
  "include_confidential" boolean
) IS 'Returns daily income and expense totals. Set include_confidential=false to exclude confidential transactions.';

CREATE
OR REPLACE FUNCTION "public"."get_daily_prompt_completion_tokens"("past_days" integer DEFAULT 14) RETURNS TABLE(
  "day" "date",
  "total_prompt_tokens" numeric,
  "total_completion_tokens" numeric
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH date_series AS (
  SELECT
    generate_series(
      CURRENT_DATE - (past_days - 1),
      CURRENT_DATE,
      '1 day' :: interval
    ) :: DATE AS day
),
daily_ai_chat_messages AS (
  SELECT
    date_trunc('day', acm.created_at :: timestamp) :: DATE AS day,
    SUM(acm.prompt_tokens) :: NUMERIC AS prompt_tokens,
    SUM(acm.completion_tokens) :: NUMERIC AS completion_tokens
  FROM
    ai_chat_messages acm
  WHERE
    acm.created_at :: date >= CURRENT_DATE - (past_days - 1)
  GROUP BY
    date_trunc('day', acm.created_at :: timestamp) :: DATE
)
SELECT
  ds.day,
  COALESCE(dcm.prompt_tokens, 0) :: NUMERIC AS total_prompt_tokens,
  COALESCE(dcm.completion_tokens, 0) :: NUMERIC AS total_completion_tokens
FROM
  date_series ds
  LEFT JOIN daily_ai_chat_messages dcm ON ds.day = dcm.day
ORDER BY
  ds.day;

END;

$ $;

ALTER FUNCTION "public"."get_daily_prompt_completion_tokens"("past_days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_dau_count"() RETURNS bigint LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  COUNT(DISTINCT user_id)
FROM
  auth.sessions
WHERE
  updated_at >= CURRENT_DATE;

$ $;

ALTER FUNCTION "public"."get_dau_count"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_dau_count"() IS 'Returns Daily Active Users count';

CREATE
OR REPLACE FUNCTION "public"."get_default_ai_pricing"() RETURNS "jsonb" LANGUAGE "sql" STABLE AS $ $
SELECT
  jsonb_build_object(
    'gemini-2.0-flash',
    jsonb_build_object(
      'per1MInputTokens',
      0.1,
      'per1MOutputTokens',
      0.4,
      'per1MReasoningTokens',
      0.4
    ),
    'gemini-2.0-flash-lite',
    jsonb_build_object(
      'per1MInputTokens',
      0.075,
      'per1MOutputTokens',
      0.3,
      'per1MReasoningTokens',
      0.3
    ),
    'gemini-2.5-flash',
    jsonb_build_object(
      'per1MInputTokens',
      0.3,
      'per1MOutputTokens',
      2.5,
      'per1MReasoningTokens',
      2.5
    ),
    'gemini-2.5-flash-lite',
    jsonb_build_object(
      'per1MInputTokens',
      0.1,
      'per1MOutputTokens',
      0.4,
      'per1MReasoningTokens',
      0.4
    ),
    'gemini-2.5-pro',
    jsonb_build_object(
      'per1MInputTokens',
      1.25,
      'per1MOutputTokens',
      10,
      'per1MReasoningTokens',
      10
    )
  );

$ $;

ALTER FUNCTION "public"."get_default_ai_pricing"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_default_ai_pricing"() IS 'Returns default per-1M token pricing for supported models.';

CREATE
OR REPLACE FUNCTION "public"."get_default_calendar_for_event"(
  "p_ws_id" "uuid",
  "p_scheduling_source" "public"."calendar_scheduling_source" DEFAULT 'manual' :: "public"."calendar_scheduling_source"
) RETURNS "uuid" LANGUAGE "plpgsql" STABLE AS $ $ DECLARE v_calendar_id UUID;

v_calendar_type public.workspace_calendar_type;

BEGIN -- Map scheduling source to calendar type
v_calendar_type := CASE
  p_scheduling_source
  WHEN 'task' THEN 'tasks' :: public.workspace_calendar_type
  WHEN 'habit' THEN 'habits' :: public.workspace_calendar_type
  ELSE 'primary' :: public.workspace_calendar_type
END;

-- Get the appropriate system calendar
SELECT
  id INTO v_calendar_id
FROM
  public.workspace_calendars
WHERE
  ws_id = p_ws_id
  AND calendar_type = v_calendar_type
LIMIT
  1;

-- Fallback to primary if not found
IF v_calendar_id IS NULL THEN
SELECT
  id INTO v_calendar_id
FROM
  public.workspace_calendars
WHERE
  ws_id = p_ws_id
  AND calendar_type = 'primary'
LIMIT
  1;

END IF;

RETURN v_calendar_id;

END;

$ $;

ALTER FUNCTION "public"."get_default_calendar_for_event"(
  "p_ws_id" "uuid",
  "p_scheduling_source" "public"."calendar_scheduling_source"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_device_types"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("device_type" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.device_type, 'Unknown') AS device_type,
  COUNT(*) AS count
FROM
  link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  COALESCE(la.device_type, 'Unknown')
ORDER BY
  count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_device_types"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_email_audit_stats"(
  "p_ws_id" "uuid",
  "p_since" timestamp with time zone DEFAULT ("now"() - '24:00:00' :: interval)
) RETURNS TABLE(
  "total" bigint,
  "sent" bigint,
  "failed" bigint,
  "bounced" bigint,
  "complained" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY
SELECT
  COUNT(*) :: BIGINT AS total,
  COUNT(*) FILTER (
    WHERE
      status = 'sent'
  ) :: BIGINT AS sent,
  COUNT(*) FILTER (
    WHERE
      status = 'failed'
  ) :: BIGINT AS failed,
  COUNT(*) FILTER (
    WHERE
      status = 'bounced'
  ) :: BIGINT AS bounced,
  COUNT(*) FILTER (
    WHERE
      status = 'complained'
  ) :: BIGINT AS complained
FROM
  public.email_audit
WHERE
  ws_id = p_ws_id
  AND created_at >= p_since;

END;

$ $;

ALTER FUNCTION "public"."get_email_audit_stats"(
  "p_ws_id" "uuid",
  "p_since" timestamp with time zone
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_email_audit_stats_global"(
  "p_since" timestamp with time zone DEFAULT ("now"() - '24:00:00' :: interval)
) RETURNS TABLE(
  "total" bigint,
  "sent" bigint,
  "failed" bigint,
  "bounced" bigint,
  "complained" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY
SELECT
  COUNT(*) :: BIGINT AS total,
  COUNT(*) FILTER (
    WHERE
      status = 'sent'
  ) :: BIGINT AS sent,
  COUNT(*) FILTER (
    WHERE
      status = 'failed'
  ) :: BIGINT AS failed,
  COUNT(*) FILTER (
    WHERE
      status = 'bounced'
  ) :: BIGINT AS bounced,
  COUNT(*) FILTER (
    WHERE
      status = 'complained'
  ) :: BIGINT AS complained
FROM
  public.email_audit
WHERE
  created_at >= p_since;

END;

$ $;

ALTER FUNCTION "public"."get_email_audit_stats_global"("p_since" timestamp with time zone) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_email_block_statuses"("p_emails" "text" []) RETURNS SETOF "public"."email_block_status" LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO '' AS $ $ WITH input_emails AS (
    -- Use GROUP BY to process each unique input email only once
    SELECT
      e.email_in AS original_email,
      lower(e.email_in) AS normalized_email,
      split_part(lower(e.email_in), '@', 2) AS normalized_domain
    FROM
      unnest(p_emails) AS e(email_in)
    GROUP BY
      e.email_in
  ),
  matches AS (
    -- Find all matches (blocking reason is not returned to caller for security)
    SELECT
      i.original_email
    FROM
      input_emails AS i -- Use INNER JOIN to find only those that *are* blocked
      JOIN public.email_blacklist AS bl ON (
        bl.entry_type = 'email'
        AND bl.value = i.normalized_email
      )
      OR (
        bl.entry_type = 'domain'
        AND bl.value = i.normalized_domain
      )
    GROUP BY
      i.original_email
  )
SELECT
  i.original_email AS email,
  (m.original_email IS NOT NULL) AS is_blocked,
  NULL :: TEXT AS reason
FROM
  input_emails AS i
  LEFT JOIN matches AS m ON i.original_email = m.original_email;

$ $;

ALTER FUNCTION "public"."get_email_block_statuses"("p_emails" "text" []) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_email_stats"(
  "filter_ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone
) RETURNS TABLE(
  "total_count" bigint,
  "sent_count" bigint,
  "failed_count" bigint,
  "rate_limited_count" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ begin return query
select
  count(*) :: bigint as total_count,
  count(*) filter (
    where
      status = 'sent'
  ) :: bigint as sent_count,
  count(*) filter (
    where
      status = 'failed'
  ) :: bigint as failed_count,
  count(*) filter (
    where
      status = 'failed'
      and (
        error_message ilike '%rate limit%'
        or (metadata ->> 'rateLimit') is not null
      )
  ) :: bigint as rate_limited_count
from
  email_audit
where
  ws_id = filter_ws_id
  and (
    start_date is null
    or created_at >= start_date
  )
  and (
    end_date is null
    or created_at <= end_date
  );

end;

$ $;

ALTER FUNCTION "public"."get_email_stats"(
  "filter_ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_engagement_metrics_over_time"("days" integer DEFAULT 90) RETURNS TABLE(
  "date" "date",
  "dau" bigint,
  "wau" bigint,
  "mau" bigint
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ BEGIN RETURN QUERY WITH date_series AS (
    SELECT
      generate_series(
        CURRENT_DATE - (days || ' days') :: interval,
        CURRENT_DATE,
        '1 day' :: interval
      ) :: date AS date
  ),
  daily_active AS (
    SELECT
      DATE(updated_at) AS activity_date,
      COUNT(DISTINCT user_id) AS active_users
    FROM
      auth.sessions
    WHERE
      updated_at >= CURRENT_DATE - (days || ' days') :: interval
    GROUP BY
      DATE(updated_at)
  )
SELECT
  ds.date,
  COALESCE(da.active_users, 0) AS dau,
  COALESCE(
    (
      SELECT
        COUNT(DISTINCT s.user_id)
      FROM
        auth.sessions s
      WHERE
        s.updated_at >= ds.date - INTERVAL '7 days'
        AND s.updated_at < ds.date + INTERVAL '1 day'
    ),
    0
  ) AS wau,
  COALESCE(
    (
      SELECT
        COUNT(DISTINCT s.user_id)
      FROM
        auth.sessions s
      WHERE
        s.updated_at >= ds.date - INTERVAL '30 days'
        AND s.updated_at < ds.date + INTERVAL '1 day'
    ),
    0
  ) AS mau
FROM
  date_series ds
  LEFT JOIN daily_active da ON ds.date = da.activity_date
ORDER BY
  ds.date;

END;

$ $;

ALTER FUNCTION "public"."get_engagement_metrics_over_time"("days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_feature_adoption"("feature_action_prefix" "text") RETURNS TABLE(
  "feature_name" "text",
  "adoption_count" bigint,
  "adoption_percentage" numeric
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH feature_actions AS (
    SELECT
      DISTINCT payload ->> 'action' as action_name,
      (payload ->> 'actor_id') :: uuid as user_id
    FROM
      auth.audit_log_entries
    WHERE
      payload ->> 'action' LIKE feature_action_prefix || '%'
  ),
  feature_usage AS (
    SELECT
      action_name,
      COUNT(DISTINCT user_id) as adoption_count
    FROM
      feature_actions
    GROUP BY
      action_name
  ),
  total_users AS (
    SELECT
      COUNT(DISTINCT id) as total_user_count
    FROM
      public.users
  )
SELECT
  fu.action_name as feature_name,
  fu.adoption_count,
  ROUND(
    (
      fu.adoption_count :: numeric / tu.total_user_count * 100
    ),
    2
  ) as adoption_percentage
FROM
  feature_usage fu,
  total_users tu
ORDER BY
  fu.adoption_count DESC;

$ $;

ALTER FUNCTION "public"."get_feature_adoption"("feature_action_prefix" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_feature_adoption"("feature_action_prefix" "text") IS 'Calculates the adoption rate of features based on audit log actions.';

CREATE
OR REPLACE FUNCTION "public"."get_finance_invoices_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.finance_invoices
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_finance_invoices_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_grouped_sessions_paginated"(
  "p_ws_id" "uuid",
  "p_period" "text" DEFAULT 'day' :: "text",
  "p_page" integer DEFAULT 1,
  "p_limit" integer DEFAULT 50,
  "p_search" "text" DEFAULT NULL :: "text",
  "p_start_date" "date" DEFAULT NULL :: "date",
  "p_end_date" "date" DEFAULT NULL :: "date",
  "p_timezone" "text" DEFAULT 'UTC' :: "text"
) RETURNS json LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE v_offset INTEGER;

v_total_count INTEGER;

v_sessions_data JSON;

v_filter_start TIMESTAMPTZ;

v_filter_end TIMESTAMPTZ;

BEGIN -- Set secure search path to prevent function hijacking
PERFORM set_config('search_path', 'public, pg_temp', true);

-- Validate input parameters
IF p_page < 1 THEN RAISE EXCEPTION 'Page must be >= 1';

END IF;

IF p_limit <= 0
OR p_limit > 200 THEN RAISE EXCEPTION 'Limit must be between 1 and 200';

END IF;

IF p_period NOT IN ('day', 'week', 'month') THEN RAISE EXCEPTION 'Period must be one of: day, week, month';

END IF;

-- Check workspace membership authorization
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: not a member of this workspace';

END IF;

-- Calculate offset
v_offset := (p_page - 1) * p_limit;

-- Convert date filters to timestamptz in user's timezone
IF p_start_date IS NOT NULL THEN v_filter_start := (p_start_date :: TEXT || ' 00:00:00') :: TIMESTAMP AT TIME ZONE p_timezone;

END IF;

IF p_end_date IS NOT NULL THEN v_filter_end := (p_end_date :: TEXT || ' 23:59:59.999') :: TIMESTAMP AT TIME ZONE p_timezone;

END IF;

-- Main query: Get grouped sessions with proper overnight session handling
WITH -- Step 1: Filter sessions that overlap with the date range
filtered_sessions AS (
  SELECT
    tts.*,
    u.display_name,
    u.avatar_url,
    ttc.name AS category_name,
    ttc.color AS category_color,
    -- Calculate local start and end dates for generating day series
    (tts.start_time AT TIME ZONE p_timezone) :: DATE AS local_start_date,
    (
      COALESCE(tts.end_time, NOW()) AT TIME ZONE p_timezone
    ) :: DATE AS local_end_date
  FROM
    time_tracking_sessions tts
    LEFT JOIN users u ON u.id = tts.user_id
    LEFT JOIN time_tracking_categories ttc ON ttc.id = tts.category_id
  WHERE
    tts.ws_id = p_ws_id -- Search filter
    AND (
      p_search IS NULL
      OR LENGTH(TRIM(p_search)) = 0
      OR tts.title ILIKE '%' || p_search || '%'
      OR u.display_name ILIKE '%' || p_search || '%'
    ) -- Date range filter: session overlaps with [filter_start, filter_end]
    -- A session overlaps if: start_time <= filter_end AND (end_time >= filter_start OR end_time IS NULL)
    AND (
      v_filter_start IS NULL
      OR tts.end_time >= v_filter_start
      OR tts.end_time IS NULL
    )
    AND (
      v_filter_end IS NULL
      OR tts.start_time <= v_filter_end
    )
),
-- Step 2: Generate all days that each session spans
-- This is crucial for overnight sessions - they need to appear on EACH day they touch
session_days AS (
  SELECT
    fs.*,
    day_date :: DATE AS period_key,
    -- Calculate period start (start of this day in user timezone)
    (day_date :: DATE :: TEXT || ' 00:00:00') :: TIMESTAMP AT TIME ZONE p_timezone AS period_start,
    -- Calculate period end (end of this day in user timezone)
    (day_date :: DATE :: TEXT || ' 23:59:59.999') :: TIMESTAMP AT TIME ZONE p_timezone AS period_end
  FROM
    filtered_sessions fs -- Generate a row for EACH day the session spans
    CROSS JOIN LATERAL generate_series(
      fs.local_start_date :: TIMESTAMP,
      fs.local_end_date :: TIMESTAMP,
      INTERVAL '1 day'
    ) AS day_date
  WHERE
    p_period = 'day'
),
-- Step 2b: For week period, generate week periods
session_weeks AS (
  SELECT
    fs.*,
    week_start :: DATE AS period_key,
    (week_start :: DATE :: TEXT || ' 00:00:00') :: TIMESTAMP AT TIME ZONE p_timezone AS period_start,
    (
      (week_start :: DATE + INTERVAL '6 days') :: DATE :: TEXT || ' 23:59:59.999'
    ) :: TIMESTAMP AT TIME ZONE p_timezone AS period_end
  FROM
    filtered_sessions fs
    CROSS JOIN LATERAL generate_series(
      DATE_TRUNC('week', fs.local_start_date :: TIMESTAMP),
      DATE_TRUNC('week', fs.local_end_date :: TIMESTAMP),
      INTERVAL '1 week'
    ) AS week_start
  WHERE
    p_period = 'week'
),
-- Step 2c: For month period, generate month periods  
session_months AS (
  SELECT
    fs.*,
    month_start :: DATE AS period_key,
    (month_start :: DATE :: TEXT || ' 00:00:00') :: TIMESTAMP AT TIME ZONE p_timezone AS period_start,
    (
      (
        month_start :: DATE + INTERVAL '1 month' - INTERVAL '1 day'
      ) :: DATE :: TEXT || ' 23:59:59.999'
    ) :: TIMESTAMP AT TIME ZONE p_timezone AS period_end
  FROM
    filtered_sessions fs
    CROSS JOIN LATERAL generate_series(
      DATE_TRUNC('month', fs.local_start_date :: TIMESTAMP),
      DATE_TRUNC('month', fs.local_end_date :: TIMESTAMP),
      INTERVAL '1 month'
    ) AS month_start
  WHERE
    p_period = 'month'
),
-- Step 3: Combine all period types
session_periods AS (
  SELECT
    *
  FROM
    session_days
  UNION
  ALL
  SELECT
    *
  FROM
    session_weeks
  UNION
  ALL
  SELECT
    *
  FROM
    session_months
),
-- Step 4: Calculate the duration that falls within each period
-- This handles overnight sessions by clipping to period boundaries
session_with_period_duration AS (
  SELECT
    sp.*,
    -- Calculate duration within this period
    -- effective_start = MAX(session_start, period_start)
    -- effective_end = MIN(session_end or now(), period_end)
    -- period_duration = effective_end - effective_start
    GREATEST(
      0,
      EXTRACT(
        EPOCH
        FROM
          (
            LEAST(COALESCE(sp.end_time, NOW()), sp.period_end) - GREATEST(sp.start_time, sp.period_start)
          )
      )
    ) :: INTEGER AS period_duration_seconds
  FROM
    session_periods sp -- Filter out periods that don't overlap with the date filter
  WHERE
    (
      p_start_date IS NULL
      OR sp.period_key >= p_start_date
    )
    AND (
      p_end_date IS NULL
      OR sp.period_key <= p_end_date
    ) -- Only include periods where the session actually has time in that period
    AND (
      LEAST(COALESCE(sp.end_time, NOW()), sp.period_end) > GREATEST(sp.start_time, sp.period_start)
    )
),
-- Step 5: Group sessions by period and user
grouped_data AS (
  SELECT
    spd.period_key,
    spd.user_id,
    spd.display_name,
    spd.avatar_url,
    COUNT(DISTINCT spd.id) AS session_count,
    SUM(COALESCE(spd.duration_seconds, 0)) AS total_duration,
    SUM(spd.period_duration_seconds) AS period_duration,
    MIN(spd.start_time) AS first_start_time,
    MAX(spd.end_time) AS last_end_time,
    BOOL_OR(spd.is_running) AS has_running_session,
    CASE
      WHEN BOOL_OR(spd.is_running) THEN 'active'
      ELSE 'completed'
    END AS status,
    ARRAY_AGG(DISTINCT spd.title) FILTER (
      WHERE
        spd.title IS NOT NULL
    ) AS session_titles,
    JSON_AGG(
      DISTINCT JSONB_BUILD_OBJECT(
        'id',
        spd.id,
        'title',
        spd.title,
        'description',
        spd.description,
        'start_time',
        spd.start_time,
        'end_time',
        spd.end_time,
        'duration_seconds',
        spd.duration_seconds,
        'is_running',
        spd.is_running,
        'category',
        CASE
          WHEN spd.category_name IS NOT NULL THEN JSONB_BUILD_OBJECT(
            'name',
            spd.category_name,
            'color',
            spd.category_color
          )
          ELSE NULL
        END,
        'user',
        JSONB_BUILD_OBJECT(
          'display_name',
          spd.display_name,
          'avatar_url',
          spd.avatar_url
        )
      )
    ) AS sessions
  FROM
    session_with_period_duration spd
  GROUP BY
    spd.period_key,
    spd.user_id,
    spd.display_name,
    spd.avatar_url
),
-- Step 6: Get total count for pagination
count_data AS (
  SELECT
    COUNT(*) AS total
  FROM
    grouped_data
),
-- Step 7: Paginate the results
paginated_data AS (
  SELECT
    *
  FROM
    grouped_data
  ORDER BY
    period_key DESC,
    total_duration DESC
  LIMIT
    p_limit OFFSET v_offset
) -- Build final result
SELECT
  JSON_BUILD_OBJECT(
    'data',
    COALESCE(
      (
        SELECT
          JSON_AGG(
            JSON_BUILD_OBJECT(
              'title',
              COALESCE(pd.display_name, 'Unknown User') || ' - ' || pd.period_key :: TEXT,
              'category',
              NULL,
              'sessions',
              pd.sessions,
              'totalDuration',
              pd.total_duration,
              'periodDuration',
              pd.period_duration,
              'firstStartTime',
              pd.first_start_time,
              'lastEndTime',
              pd.last_end_time,
              'status',
              pd.status,
              'user',
              JSON_BUILD_OBJECT(
                'displayName',
                pd.display_name,
                'avatarUrl',
                pd.avatar_url
              ),
              'period',
              pd.period_key :: TEXT,
              'sessionCount',
              pd.session_count,
              'sessionTitles',
              pd.session_titles
            )
            ORDER BY
              pd.period_key DESC,
              pd.total_duration DESC
          )
        FROM
          paginated_data pd
      ),
      '[]' :: JSON
    ),
    'pagination',
    JSON_BUILD_OBJECT(
      'page',
      p_page,
      'limit',
      p_limit,
      'total',
      (
        SELECT
          total
        FROM
          count_data
      ),
      'pages',
      CEIL(
        (
          SELECT
            total
          FROM
            count_data
        ) :: FLOAT / p_limit
      )
    )
  ) INTO v_sessions_data;

RETURN v_sessions_data;

END;

$ $;

ALTER FUNCTION "public"."get_grouped_sessions_paginated"(
  "p_ws_id" "uuid",
  "p_period" "text",
  "p_page" integer,
  "p_limit" integer,
  "p_search" "text",
  "p_start_date" "date",
  "p_end_date" "date",
  "p_timezone" "text"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_grouped_sessions_paginated"(
  "p_ws_id" "uuid",
  "p_period" "text",
  "p_page" integer,
  "p_limit" integer,
  "p_search" "text",
  "p_start_date" "date",
  "p_end_date" "date",
  "p_timezone" "text"
) IS 'Returns paginated time tracking sessions grouped by period (day/week/month) and user.
Supports date range filtering with proper handling of overnight sessions that span multiple periods.
The periodDuration field contains the duration that falls within each specific period.
Overnight sessions are properly split and appear on EACH day they span.';

CREATE
OR REPLACE FUNCTION "public"."get_guest_user_leads"(
  "p_ws_id" "uuid",
  "p_threshold" integer DEFAULT 1,
  "p_search" "text" DEFAULT NULL :: "text",
  "p_page" integer DEFAULT 1,
  "p_page_size" integer DEFAULT 10
) RETURNS TABLE(
  "id" "uuid",
  "full_name" "text",
  "email" "text",
  "phone" "text",
  "gender" "text",
  "attendance_count" bigint,
  "group_id" "uuid",
  "group_name" "text",
  "has_lead_generation" boolean,
  "created_at" timestamp with time zone,
  "total_count" bigint
) LANGUAGE "plpgsql" AS $ $ DECLARE offset_count integer;

BEGIN -- Validate input parameters
IF p_page < 1 THEN RAISE EXCEPTION 'Page number must be >= 1, got %',
p_page;

END IF;

IF p_page_size < 1
OR p_page_size > 1000 THEN RAISE EXCEPTION 'Page size must be between 1 and 1000, got %',
p_page_size;

END IF;

IF p_threshold < 0 THEN RAISE EXCEPTION 'Threshold must be >= 0, got %',
p_threshold;

END IF;

-- Calculate offset for pagination
offset_count := (p_page - 1) * p_page_size;

-- Return optimized query with single database call
RETURN QUERY WITH eligible_users AS (
  SELECT
    DISTINCT wu.id,
    wu.full_name,
    wu.email,
    wu.phone,
    wu.gender,
    wu.created_at,
    wug.id as group_id,
    wug.name as group_name,
    -- Get attendance count efficiently
    COALESCE(
      (
        SELECT
          COUNT(*) :: bigint
        FROM
          user_group_attendance uga
        WHERE
          uga.user_id = wu.id
          AND uga.status IN ('PRESENT', 'LATE')
      ),
      0
    ) as attendance_count,
    -- Check if lead generation already exists
    EXISTS (
      SELECT
        1
      FROM
        guest_users_lead_generation gugl
      WHERE
        gugl.user_id = wu.id
        AND gugl.ws_id = p_ws_id
    ) as has_lead_generation
  FROM
    workspace_users wu
    INNER JOIN workspace_user_groups_users wugu ON wu.id = wugu.user_id
    INNER JOIN workspace_user_groups wug ON wugu.group_id = wug.id
  WHERE
    wu.ws_id = p_ws_id
    AND wu.archived = false
    AND wug.is_guest = true -- Apply search filter if provided
    AND (
      p_search IS NULL
      OR wu.full_name ILIKE '%' || p_search || '%'
      OR wu.email ILIKE '%' || p_search || '%'
    ) -- Check if user is actually a guest using the existing RPC
    AND is_user_guest(wu.id) = true
),
filtered_users AS (
  SELECT
    *
  FROM
    eligible_users eu
  WHERE
    eu.attendance_count >= p_threshold
    AND eu.has_lead_generation = false
),
paginated_users AS (
  SELECT
    *,
    COUNT(*) OVER () as total_count
  FROM
    filtered_users
  ORDER BY
    created_at DESC
  LIMIT
    p_page_size OFFSET offset_count
)
SELECT
  pu.id,
  pu.full_name,
  pu.email,
  pu.phone,
  pu.gender,
  pu.attendance_count,
  pu.group_id,
  pu.group_name,
  pu.has_lead_generation,
  pu.created_at,
  pu.total_count
FROM
  paginated_users pu;

END;

$ $;

ALTER FUNCTION "public"."get_guest_user_leads"(
  "p_ws_id" "uuid",
  "p_threshold" integer,
  "p_search" "text",
  "p_page" integer,
  "p_page_size" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_healthcare_checkups_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.healthcare_checkups
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_healthcare_checkups_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_healthcare_diagnoses_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.healthcare_diagnoses
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_healthcare_diagnoses_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_healthcare_vital_groups_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.healthcare_vital_groups
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_healthcare_vital_groups_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_healthcare_vitals_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.healthcare_vitals
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_healthcare_vitals_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_hourly_prompt_completion_tokens"("past_hours" integer DEFAULT 12) RETURNS TABLE(
  "hour" timestamp with time zone,
  "total_prompt_tokens" numeric,
  "total_completion_tokens" numeric
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH hour_series AS (
  SELECT
    generate_series(
      (
        date_trunc('hour', CURRENT_TIMESTAMP AT TIME ZONE 'UTC') - INTERVAL '1 hour' * (past_hours - 1)
      ) :: TIMESTAMP WITH TIME ZONE,
      (
        date_trunc('hour', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')
      ) :: TIMESTAMP WITH TIME ZONE,
      '1 hour' :: interval
    ) AS hour
),
hourly_ai_chat_messages AS (
  SELECT
    date_trunc('hour', acm.created_at) AT TIME ZONE 'UTC' AS hour,
    SUM(acm.prompt_tokens) :: NUMERIC AS prompt_tokens,
    SUM(acm.completion_tokens) :: NUMERIC AS completion_tokens
  FROM
    ai_chat_messages acm
  WHERE
    acm.created_at >= date_trunc('hour', CURRENT_TIMESTAMP AT TIME ZONE 'UTC') - INTERVAL '1 hour' * (past_hours - 1)
    AND acm.created_at <= CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
  GROUP BY
    date_trunc('hour', acm.created_at)
)
SELECT
  hs.hour,
  COALESCE(hcm.prompt_tokens, 0) :: NUMERIC AS total_prompt_tokens,
  COALESCE(hcm.completion_tokens, 0) :: NUMERIC AS total_completion_tokens
FROM
  hour_series hs
  LEFT JOIN hourly_ai_chat_messages hcm ON hs.hour = hcm.hour
ORDER BY
  hs.hour;

END;

$ $;

ALTER FUNCTION "public"."get_hourly_prompt_completion_tokens"("past_hours" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_batches_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.inventory_batches wb
  INNER JOIN public.inventory_warehouses ww ON wb.warehouse_id = ww.id
WHERE
  ww.ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_batches_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_product_categories_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.product_categories
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_product_categories_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_products"(
  "_category_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "_ws_id" "uuid" DEFAULT NULL :: "uuid",
  "_warehouse_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "_has_unit" boolean DEFAULT NULL :: boolean
) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "manufacturer" "text",
  "unit" "text",
  "unit_id" "uuid",
  "category" "text",
  "price" bigint,
  "amount" bigint,
  "ws_id" "uuid",
  "created_at" timestamp with time zone
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH inventory_products AS (
  SELECT
    *
  FROM
    inventory_products
  WHERE
    (warehouse_id = ANY(_warehouse_ids))
)
SELECT
  p.id,
  p.name,
  p.manufacturer,
  iu.name AS unit,
  ip.unit_id,
  pc.name AS category,
  ip.price,
  COALESCE(ip.amount, 0) AS amount,
  p.ws_id,
  p.created_at
FROM
  workspace_products p
  LEFT JOIN inventory_products ip ON ip.product_id = p.id
  AND (
    ip.warehouse_id = ANY(_warehouse_ids)
    AND (
      ip.unit_id IS NOT NULL
      OR _has_unit IS FALSE
    )
  )
  LEFT JOIN inventory_units iu ON ip.unit_id = iu.id
  LEFT JOIN product_categories pc ON p.category_id = pc.id
WHERE
  (
    _category_ids IS NULL
    OR p.category_id = ANY(_category_ids)
  )
  AND (
    _ws_id IS NULL
    OR p.ws_id = _ws_id
  )
  AND (
    _has_unit IS NULL
    OR ip.unit_id IS NOT NULL
  )
ORDER BY
  p.name ASC;

END;

$ $;

ALTER FUNCTION "public"."get_inventory_products"(
  "_category_ids" "uuid" [],
  "_ws_id" "uuid",
  "_warehouse_ids" "uuid" [],
  "_has_unit" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_products_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.inventory_products ip
  INNER JOIN public.workspace_products wp ON wp.id = ip.product_id
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_products_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_suppliers_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.inventory_suppliers
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_suppliers_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_units_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.inventory_units
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_units_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_inventory_warehouses_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.inventory_warehouses
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_inventory_warehouses_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_ip_block_level"("p_ip_address" "text") RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE max_level INTEGER;

BEGIN
SELECT
  COALESCE(MAX(block_level), 0) INTO max_level
FROM
  public.blocked_ips
WHERE
  ip_address = p_ip_address
  AND blocked_at > NOW() - INTERVAL '24 hours';

RETURN max_level;

END;

$ $;

ALTER FUNCTION "public"."get_ip_block_level"("p_ip_address" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_ip_block_level"("p_ip_address" "text") IS 'Returns the current progressive block level for an IP (0-4) based on blocks in last 24 hours';

CREATE
OR REPLACE FUNCTION "public"."get_joined_workspace_count"("user_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspace_members
WHERE
  user_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_joined_workspace_count"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_mau_count"() RETURNS bigint LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  COUNT(DISTINCT user_id)
FROM
  auth.sessions
WHERE
  updated_at >= CURRENT_DATE - INTERVAL '30 days';

$ $;

ALTER FUNCTION "public"."get_mau_count"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_mau_count"() IS 'Returns Monthly Active Users count';

CREATE
OR REPLACE FUNCTION "public"."get_monthly_income_expense"(
  "_ws_id" "uuid",
  "past_months" integer DEFAULT 12
) RETURNS TABLE(
  "month" "date",
  "total_income" numeric,
  "total_expense" numeric
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH month_series AS (
  SELECT
    generate_series(
      date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1),
      date_trunc('month', CURRENT_DATE),
      '1 month' :: interval
    ) :: DATE AS month
),
monthly_transactions AS (
  SELECT
    date_trunc('month', wt.taken_at :: timestamp) :: DATE AS month,
    SUM(
      CASE
        WHEN wt.amount > 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS income,
    SUM(
      CASE
        WHEN wt.amount < 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS expense
  FROM
    wallet_transactions wt
    INNER JOIN workspace_wallets ww ON wt.wallet_id = ww.id
  WHERE
    wt.taken_at >= date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1)
    AND wt.taken_at < date_trunc('month', CURRENT_DATE) + INTERVAL '1 month'
    AND ww.ws_id = _ws_id
  GROUP BY
    date_trunc('month', wt.taken_at :: timestamp) :: DATE
)
SELECT
  ms.month,
  COALESCE(mt.income, 0) :: NUMERIC AS total_income,
  ABS(COALESCE(mt.expense, 0)) :: NUMERIC AS total_expense
FROM
  month_series ms
  LEFT JOIN monthly_transactions mt ON ms.month = mt.month
ORDER BY
  ms.month;

END;

$ $;

ALTER FUNCTION "public"."get_monthly_income_expense"("_ws_id" "uuid", "past_months" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_monthly_income_expense"(
  "_ws_id" "uuid",
  "past_months" integer DEFAULT 12,
  "include_confidential" boolean DEFAULT true
) RETURNS TABLE(
  "month" "date",
  "total_income" numeric,
  "total_expense" numeric
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(_ws_id, auth.uid(), 'view_confidential_amount');

RETURN QUERY WITH month_series AS (
  SELECT
    generate_series(
      date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1),
      date_trunc('month', CURRENT_DATE),
      '1 month' :: interval
    ) :: DATE AS month
),
monthly_transactions AS (
  SELECT
    date_trunc('month', wt.taken_at :: timestamp) :: DATE AS month,
    SUM(
      CASE
        WHEN wt.amount > 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS income,
    SUM(
      CASE
        WHEN wt.amount < 0 THEN wt.amount
        ELSE 0
      END
    ) :: NUMERIC AS expense
  FROM
    wallet_transactions wt
    INNER JOIN workspace_wallets ww ON wt.wallet_id = ww.id
  WHERE
    wt.taken_at >= date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1)
    AND wt.taken_at < date_trunc('month', CURRENT_DATE) + INTERVAL '1 month'
    AND ww.ws_id = _ws_id -- Confidential filtering
    AND (
      (
        NOT include_confidential
        AND NOT wt.is_amount_confidential
      )
      OR (
        include_confidential
        AND (
          NOT wt.is_amount_confidential
          OR can_view_amount
        )
      )
    )
  GROUP BY
    date_trunc('month', wt.taken_at :: timestamp) :: DATE
)
SELECT
  ms.month,
  COALESCE(mt.income, 0) :: NUMERIC AS total_income,
  ABS(COALESCE(mt.expense, 0)) :: NUMERIC AS total_expense
FROM
  month_series ms
  LEFT JOIN monthly_transactions mt ON ms.month = mt.month
ORDER BY
  ms.month;

END;

$ $;

ALTER FUNCTION "public"."get_monthly_income_expense"(
  "_ws_id" "uuid",
  "past_months" integer,
  "include_confidential" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_monthly_income_expense"(
  "_ws_id" "uuid",
  "past_months" integer,
  "include_confidential" boolean
) IS 'Returns monthly income and expense totals. Set include_confidential=false to exclude confidential transactions.';

CREATE
OR REPLACE FUNCTION "public"."get_monthly_prompt_completion_tokens"("past_months" integer DEFAULT 12) RETURNS TABLE(
  "month" "date",
  "total_prompt_tokens" numeric,
  "total_completion_tokens" numeric
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH month_series AS (
  SELECT
    generate_series(
      date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1),
      date_trunc('month', CURRENT_DATE),
      '1 month' :: interval
    ) :: DATE AS month
),
monthly_ai_chat_messages AS (
  SELECT
    date_trunc('month', acm.created_at :: timestamp) :: DATE AS month,
    SUM(acm.prompt_tokens) :: NUMERIC AS prompt_tokens,
    SUM(acm.completion_tokens) :: NUMERIC AS completion_tokens
  FROM
    ai_chat_messages acm
  WHERE
    acm.created_at >= date_trunc('month', CURRENT_DATE) - INTERVAL '1 month' * (past_months - 1)
    AND acm.created_at < date_trunc('month', CURRENT_DATE) + INTERVAL '1 month'
  GROUP BY
    date_trunc('month', acm.created_at :: timestamp) :: DATE
)
SELECT
  ms.month,
  COALESCE(mcm.prompt_tokens, 0) :: NUMERIC AS total_prompt_tokens,
  COALESCE(mcm.completion_tokens, 0) :: NUMERIC AS total_completion_tokens
FROM
  month_series ms
  LEFT JOIN monthly_ai_chat_messages mcm ON ms.month = mcm.month
ORDER BY
  ms.month;

END;

$ $;

ALTER FUNCTION "public"."get_monthly_prompt_completion_tokens"("past_months" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_next_task_display_number"("p_board_id" "uuid") RETURNS integer LANGUAGE "plpgsql" AS $ $ DECLARE next_number INTEGER;

BEGIN -- Atomically increment and return the next task number for this board
-- This ensures the counter never resets, even if all tasks are deleted
UPDATE
  workspace_boards
SET
  next_task_number = next_task_number + 1
WHERE
  id = p_board_id RETURNING next_task_number - 1 INTO next_number;

RETURN next_number;

END;

$ $;

ALTER FUNCTION "public"."get_next_task_display_number"("p_board_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_notification_email_config"("p_notification_type" "text") RETURNS TABLE(
  "delivery_mode" "public"."notification_delivery_mode",
  "email_template" "text",
  "email_subject_template" "text",
  "priority_override" "public"."notification_priority",
  "batch_window_minutes" integer,
  "enabled" boolean
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  nec.delivery_mode,
  nec.email_template,
  nec.email_subject_template,
  nec.priority_override,
  nec.batch_window_minutes,
  nec.enabled
FROM
  public.notification_email_config nec
WHERE
  nec.notification_type = p_notification_type
  AND nec.enabled = true;

-- Return default config if no specific config found
IF NOT FOUND THEN RETURN QUERY
SELECT
  'batched' :: public.notification_delivery_mode,
  NULL :: TEXT,
  NULL :: TEXT,
  NULL :: public.notification_priority,
  10 :: INTEGER,
  true :: BOOLEAN;

END IF;

END;

$ $;

ALTER FUNCTION "public"."get_notification_email_config"("p_notification_type" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_notification_email_config"("p_notification_type" "text") IS 'Returns email configuration for a notification type, with defaults if not configured';

CREATE
OR REPLACE FUNCTION "public"."get_operating_systems"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("os" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.os, 'Unknown') AS os,
  COUNT(*) AS count
FROM
  link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  COALESCE(la.os, 'Unknown')
ORDER BY
  count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_operating_systems"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_or_create_external_calendar"(
  "p_ws_id" "uuid",
  "p_calendar_id" "text",
  "p_calendar_name" "text",
  "p_color" "text",
  "p_provider" "public"."calendar_provider"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public',
  'pg_temp' AS $ $ DECLARE v_calendar_id UUID;

v_caller_id UUID;

BEGIN -- Set explicit search_path for security
SET
  search_path = public,
  pg_temp;

-- Get the authenticated user
v_caller_id := auth.uid();

-- Validate caller is authenticated
IF v_caller_id IS NULL THEN RAISE EXCEPTION 'Unauthorized: No authenticated user';

END IF;

-- Validate caller is a member of the workspace
IF NOT public.is_org_member(v_caller_id, p_ws_id) THEN RAISE EXCEPTION 'Forbidden: User is not a member of this workspace';

END IF;

-- Try to find existing calendar
SELECT
  wc.id INTO v_calendar_id
FROM
  public.workspace_calendars wc
  JOIN public.calendar_connections cc ON cc.workspace_calendar_id = wc.id
WHERE
  cc.ws_id = p_ws_id
  AND cc.calendar_id = p_calendar_id
  AND cc.provider = p_provider :: TEXT
LIMIT
  1;

-- If not found, create one
IF v_calendar_id IS NULL THEN
INSERT INTO
  public.workspace_calendars (
    ws_id,
    name,
    color,
    calendar_type,
    is_system,
    position
  )
VALUES
  (
    p_ws_id,
    p_calendar_name,
    COALESCE(p_color, 'BLUE'),
    'custom',
    false,
    100
  ) RETURNING id INTO v_calendar_id;

-- Also create the calendar_connections entry so lookups via calendar_id work
INSERT INTO
  public.calendar_connections (
    ws_id,
    workspace_calendar_id,
    calendar_id,
    provider,
    is_enabled,
    created_at
  )
VALUES
  (
    p_ws_id,
    v_calendar_id,
    p_calendar_id,
    p_provider :: TEXT,
    true,
    NOW()
  );

END IF;

RETURN v_calendar_id;

END;

$ $;

ALTER FUNCTION "public"."get_or_create_external_calendar"(
  "p_ws_id" "uuid",
  "p_calendar_id" "text",
  "p_calendar_name" "text",
  "p_color" "text",
  "p_provider" "public"."calendar_provider"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer DEFAULT 10
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_batch_id UUID;

v_window_start TIMESTAMPTZ;

v_window_end TIMESTAMPTZ;

BEGIN -- Harden search_path to prevent privilege escalation
SET
  LOCAL search_path = pg_temp,
  public;

-- Try to find an existing pending batch within the window
SELECT
  id INTO v_batch_id
FROM
  public.notification_batches
WHERE
  ws_id = p_ws_id
  AND user_id = p_user_id
  AND channel = p_channel
  AND status = 'pending'
  AND window_end > now()
ORDER BY
  window_start DESC
LIMIT
  1;

-- If no batch found, create a new one
IF v_batch_id IS NULL THEN v_window_start := now();

v_window_end := now() + (p_window_minutes || ' minutes') :: interval;

INSERT INTO
  public.notification_batches (
    ws_id,
    user_id,
    channel,
    window_start,
    window_end
  )
VALUES
  (
    p_ws_id,
    p_user_id,
    p_channel,
    v_window_start,
    v_window_end
  ) RETURNING id INTO v_batch_id;

END IF;

RETURN v_batch_id;

END;

$ $;

ALTER FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer
) IS 'Gets an existing pending batch or creates a new one for smart batching';

CREATE
OR REPLACE FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer DEFAULT 10,
  "p_email" "text" DEFAULT NULL :: "text"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_batch_id UUID;

v_window_start TIMESTAMPTZ;

v_window_end TIMESTAMPTZ;

BEGIN -- Try to find an existing pending batch within the window
-- Match by user_id if provided, otherwise by email
IF p_user_id IS NOT NULL THEN
SELECT
  id INTO v_batch_id
FROM
  public.notification_batches
WHERE
  (
    ws_id = p_ws_id
    OR (
      ws_id IS NULL
      AND p_ws_id IS NULL
    )
  )
  AND user_id = p_user_id
  AND channel = p_channel
  AND status = 'pending'
  AND window_end > now()
ORDER BY
  window_start DESC
LIMIT
  1;

ELSIF p_email IS NOT NULL THEN
SELECT
  id INTO v_batch_id
FROM
  public.notification_batches
WHERE
  (
    ws_id = p_ws_id
    OR (
      ws_id IS NULL
      AND p_ws_id IS NULL
    )
  )
  AND email = p_email
  AND channel = p_channel
  AND status = 'pending'
  AND window_end > now()
ORDER BY
  window_start DESC
LIMIT
  1;

END IF;

-- If no batch found, create a new one
IF v_batch_id IS NULL THEN v_window_start := now();

v_window_end := now() + (p_window_minutes || ' minutes') :: interval;

INSERT INTO
  public.notification_batches (
    ws_id,
    user_id,
    email,
    channel,
    window_start,
    window_end
  )
VALUES
  (
    p_ws_id,
    p_user_id,
    p_email,
    p_channel,
    v_window_start,
    v_window_end
  ) RETURNING id INTO v_batch_id;

END IF;

RETURN v_batch_id;

END;

$ $;

ALTER FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer,
  "p_email" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer DEFAULT 10,
  "p_email" "text" DEFAULT NULL :: "text",
  "p_delivery_mode" "public"."notification_delivery_mode" DEFAULT 'batched' :: "public"."notification_delivery_mode"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_batch_id UUID;

v_window_start TIMESTAMPTZ;

v_window_end TIMESTAMPTZ;

BEGIN -- For immediate delivery, always create a new batch (no reuse)
IF p_delivery_mode = 'immediate' THEN v_window_start := now();

v_window_end := now();

-- Immediate batches have zero window
INSERT INTO
  public.notification_batches (
    ws_id,
    user_id,
    email,
    channel,
    window_start,
    window_end,
    delivery_mode
  )
VALUES
  (
    p_ws_id,
    p_user_id,
    p_email,
    p_channel,
    v_window_start,
    v_window_end,
    'immediate'
  ) RETURNING id INTO v_batch_id;

RETURN v_batch_id;

END IF;

-- For batched delivery, try to find existing pending batch within window
IF p_user_id IS NOT NULL THEN
SELECT
  id INTO v_batch_id
FROM
  public.notification_batches
WHERE
  (
    ws_id = p_ws_id
    OR (
      ws_id IS NULL
      AND p_ws_id IS NULL
    )
  )
  AND user_id = p_user_id
  AND channel = p_channel
  AND status = 'pending'
  AND delivery_mode = 'batched'
  AND window_end > now()
ORDER BY
  window_start DESC
LIMIT
  1;

ELSIF p_email IS NOT NULL THEN
SELECT
  id INTO v_batch_id
FROM
  public.notification_batches
WHERE
  (
    ws_id = p_ws_id
    OR (
      ws_id IS NULL
      AND p_ws_id IS NULL
    )
  )
  AND email = p_email
  AND channel = p_channel
  AND status = 'pending'
  AND delivery_mode = 'batched'
  AND window_end > now()
ORDER BY
  window_start DESC
LIMIT
  1;

END IF;

-- If no batch found, create a new one
IF v_batch_id IS NULL THEN v_window_start := now();

v_window_end := now() + (p_window_minutes || ' minutes') :: interval;

INSERT INTO
  public.notification_batches (
    ws_id,
    user_id,
    email,
    channel,
    window_start,
    window_end,
    delivery_mode
  )
VALUES
  (
    p_ws_id,
    p_user_id,
    p_email,
    p_channel,
    v_window_start,
    v_window_end,
    'batched'
  ) RETURNING id INTO v_batch_id;

END IF;

RETURN v_batch_id;

END;

$ $;

ALTER FUNCTION "public"."get_or_create_notification_batch"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_channel" "text",
  "p_window_minutes" integer,
  "p_email" "text",
  "p_delivery_mode" "public"."notification_delivery_mode"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_pending_event_participants"("_event_id" "uuid") RETURNS integer LANGUAGE "plpgsql" AS $ $ DECLARE participant_count integer;

BEGIN
SELECT
  COUNT(DISTINCT participant_id) INTO participant_count
FROM
  (
    SELECT
      p.participant_id
    FROM
      public.calendar_event_participants p
    WHERE
      p.event_id = _event_id
      AND (
        p.type <> 'user_group'
        AND p.going IS NULL
      )
    UNION
    ALL
    SELECT
      ugu.user_id
    FROM
      public.workspace_user_groups_users ugu
    WHERE
      ugu.group_id IN (
        SELECT
          wug.id
        FROM
          public.workspace_user_groups wug
          JOIN public.calendar_event_participants p ON wug.id = p.participant_id
        WHERE
          p.event_id = _event_id
          AND p.type = 'user_group'
          AND p.going IS NULL
      )
      AND NOT EXISTS (
        SELECT
          1
        FROM
          public.calendar_event_participants p
        WHERE
          p.event_id = _event_id
          AND p.participant_id = ugu.user_id
          AND p.type <> 'user_group'
      )
  ) AS subquery;

RETURN participant_count;

END;

$ $;

ALTER FUNCTION "public"."get_pending_event_participants"("_event_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_pending_invoices"(
  "p_ws_id" "uuid",
  "p_limit" integer DEFAULT NULL :: integer,
  "p_offset" integer DEFAULT 0
) RETURNS TABLE(
  "user_id" "uuid",
  "user_name" "text",
  "group_id" "uuid",
  "group_name" "text",
  "months_owed" "text",
  "attendance_days" integer,
  "total_sessions" integer,
  "potential_total" numeric
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ BEGIN RETURN QUERY WITH base_data AS (
  SELECT
    *
  FROM
    get_pending_invoices_base(p_ws_id)
),
session_counts AS (
  -- Count total sessions for each group-month
  SELECT
    bd.group_id,
    bd.month,
    COUNT(session_date) :: integer as total_sessions
  FROM
    base_data bd
    CROSS JOIN LATERAL unnest(bd.sessions) as session_date
  WHERE
    to_char(session_date :: date, 'YYYY-MM') = bd.month
  GROUP BY
    bd.group_id,
    bd.month
),
ranked_inventory AS (
  -- Rank inventory products by matching priority for each group linked product
  -- Priority: 1) exact unit+warehouse match, 2) unit-only match (prefer in-stock), 3) any product (prefer in-stock)
  SELECT
    uglp.group_id,
    uglp.product_id,
    uglp.unit_id,
    uglp.warehouse_id as desired_warehouse_id,
    ip.price,
    ip.amount as stock_amount,
    ROW_NUMBER() OVER (
      PARTITION BY uglp.group_id,
      uglp.product_id,
      uglp.unit_id,
      uglp.warehouse_id
      ORDER BY
        CASE
          -- Priority 1: Exact match (unit + warehouse)
          WHEN ip.unit_id = uglp.unit_id
          AND ip.warehouse_id = uglp.warehouse_id THEN 1 -- Priority 2: Unit match only, prefer in-stock
          WHEN ip.unit_id = uglp.unit_id THEN 2 -- Priority 3: Any product, prefer in-stock
          ELSE 3
        END,
        -- Within same priority, prefer items with stock
        CASE
          WHEN ip.amount IS NULL
          OR ip.amount > 0 THEN 0
          ELSE 1
        END,
        -- Tie-breaker: warehouse_id for consistent ordering
        ip.warehouse_id
    ) as rank
  FROM
    user_group_linked_products uglp
    LEFT JOIN inventory_products ip ON ip.product_id = uglp.product_id
),
group_product_prices AS (
  -- Select the best inventory match per group linked product
  SELECT
    ri.group_id,
    ri.product_id,
    ri.unit_id,
    ri.desired_warehouse_id as warehouse_id,
    COALESCE(ri.price, 0) as price,
    ri.stock_amount
  FROM
    ranked_inventory ri
  WHERE
    ri.rank = 1
),
combined_pending AS (
  -- Combine all pending months per user-group with aggregated attendance
  SELECT
    bd.user_id,
    bd.user_name,
    bd.group_id,
    bd.group_name,
    string_agg(
      bd.month,
      ', '
      ORDER BY
        bd.month
    ) as months_owed,
    SUM(bd.attendance_days) :: integer as total_attendance_days,
    SUM(COALESCE(sc.total_sessions, 0)) :: integer as total_sessions
  FROM
    base_data bd
    LEFT JOIN session_counts sc ON sc.group_id = bd.group_id
    AND sc.month = bd.month
  GROUP BY
    bd.user_id,
    bd.user_name,
    bd.group_id,
    bd.group_name
)
SELECT
  cp.user_id :: uuid,
  cp.user_name :: text,
  cp.group_id :: uuid,
  cp.group_name :: text,
  cp.months_owed :: text,
  cp.total_attendance_days :: integer as attendance_days,
  cp.total_sessions :: integer as total_sessions,
  -- Calculate potential total by respecting stock limits for each product individually
  -- For unlimited stock products: use full attendance_days
  -- For limited stock products: cap at available stock amount
  ROUND(
    COALESCE(
      (
        SELECT
          SUM(
            CASE
              WHEN gpp.stock_amount IS NULL THEN cp.total_attendance_days * gpp.price
              ELSE LEAST(cp.total_attendance_days, gpp.stock_amount) * gpp.price
            END
          )
        FROM
          group_product_prices gpp
        WHERE
          gpp.group_id = cp.group_id
      ),
      0
    )
  ) :: numeric as potential_total
FROM
  combined_pending cp
WHERE
  cp.total_attendance_days > 0 -- Only show users with attendance
ORDER BY
  cp.user_name,
  cp.group_name
LIMIT
  p_limit OFFSET p_offset;

END;

$ $;

ALTER FUNCTION "public"."get_pending_invoices"(
  "p_ws_id" "uuid",
  "p_limit" integer,
  "p_offset" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_pending_invoices_base"("p_ws_id" "uuid") RETURNS TABLE(
  "user_id" "uuid",
  "user_name" "text",
  "group_id" "uuid",
  "group_name" "text",
  "month" "text",
  "sessions" "date" [],
  "attendance_days" integer
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ BEGIN PERFORM set_config('statement_timeout', '5s', true);

-- tune as needed
-- Verify caller has access to the workspace
IF NOT is_org_member(auth.uid(), p_ws_id) THEN RAISE EXCEPTION 'Unauthorized: User does not have access to workspace %',
p_ws_id;

END IF;

RETURN QUERY WITH user_groups AS (
  -- Get all active user groups with students
  SELECT
    DISTINCT wugu.user_id,
    wu.full_name as user_name,
    wug.id as group_id,
    wug.name as group_name,
    wug.sessions,
    wug.starting_date,
    wug.ending_date
  FROM
    workspace_user_groups_users wugu
    JOIN workspace_users wu ON wu.id = wugu.user_id
    JOIN workspace_user_groups wug ON wug.id = wugu.group_id
  WHERE
    wug.ws_id = p_ws_id
    AND wugu.role = 'STUDENT'
    AND wu.ws_id = p_ws_id
),
latest_invoices AS (
  -- Get the latest subscription invoice for each user-group combination
  SELECT
    DISTINCT ON (fi.customer_id, fi.user_group_id) fi.customer_id,
    fi.user_group_id,
    fi.valid_until
  FROM
    finance_invoices fi
  WHERE
    fi.ws_id = p_ws_id
    AND fi.user_group_id IS NOT NULL
    AND fi.valid_until IS NOT NULL
  ORDER BY
    fi.customer_id,
    fi.user_group_id,
    fi.created_at DESC
),
pending_months AS (
  -- Generate months between valid_until and now that need invoices
  -- If valid_until is 2025-11-01, we start looking from 2025-11-01 onwards
  -- This means the October invoice (valid until Nov 1) is considered paid for October
  SELECT
    ug.user_id,
    ug.user_name,
    ug.group_id,
    ug.group_name,
    ug.sessions,
    to_char(month_date, 'YYYY-MM') as month,
    month_date
  FROM
    user_groups ug
    LEFT JOIN latest_invoices li ON li.customer_id = ug.user_id
    AND li.user_group_id = ug.group_id
    CROSS JOIN LATERAL generate_series(
      COALESCE(
        -- Start from valid_until date (which is first day of next unpaid month)
        date_trunc('month', li.valid_until),
        date_trunc(
          'month',
          COALESCE(ug.starting_date, CURRENT_DATE)
        )
      ),
      date_trunc(
        'month',
        LEAST(
          COALESCE(ug.ending_date, CURRENT_DATE),
          CURRENT_DATE
        )
      ),
      '1 month' :: interval
    ) as month_date
  WHERE
    month_date <= date_trunc('month', CURRENT_DATE) -- Include months from valid_until onwards (valid_until marks the START of unpaid period)
    AND (
      li.valid_until IS NULL
      OR month_date >= date_trunc('month', li.valid_until)
    )
),
attendance_counts AS (
  -- Count attendance for each user-group-month combination
  SELECT
    pm.user_id,
    pm.group_id,
    pm.month,
    COUNT(uga.date) :: integer as attendance_days
  FROM
    pending_months pm
    LEFT JOIN user_group_attendance uga ON uga.user_id = pm.user_id
    AND uga.group_id = pm.group_id
    AND to_char(uga.date, 'YYYY-MM') = pm.month
  GROUP BY
    pm.user_id,
    pm.group_id,
    pm.month
)
SELECT
  pm.user_id,
  pm.user_name,
  pm.group_id,
  pm.group_name,
  pm.month,
  pm.sessions,
  COALESCE(ac.attendance_days, 0) :: integer as attendance_days
FROM
  pending_months pm
  LEFT JOIN attendance_counts ac ON ac.user_id = pm.user_id
  AND ac.group_id = pm.group_id
  AND ac.month = pm.month
WHERE
  COALESCE(ac.attendance_days, 0) > 0;

-- Only include months with attendance
END;

$ $;

ALTER FUNCTION "public"."get_pending_invoices_base"("p_ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_pending_invoices_count"("p_ws_id" "uuid") RETURNS bigint LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE result_count bigint;

BEGIN WITH base_data AS (
  SELECT
    *
  FROM
    get_pending_invoices_base(p_ws_id)
),
combined_pending AS (
  -- Combine all pending months per user-group with aggregated attendance
  SELECT
    bd.user_id,
    bd.user_name,
    bd.group_id,
    bd.group_name,
    SUM(bd.attendance_days) :: integer as total_attendance_days
  FROM
    base_data bd
  GROUP BY
    bd.user_id,
    bd.user_name,
    bd.group_id,
    bd.group_name
)
SELECT
  COUNT(*) INTO result_count
FROM
  combined_pending
WHERE
  total_attendance_days > 0;

RETURN result_count;

END;

$ $;

ALTER FUNCTION "public"."get_pending_invoices_count"("p_ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_period_summary_stats"(
  "p_ws_id" "uuid",
  "p_period" "text" DEFAULT 'day' :: "text"
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE summary_data JSON;

period_key_expression TEXT;

BEGIN -- Set secure search path to prevent function hijacking
PERFORM set_config('search_path', 'public, pg_temp', true);

-- Validate input parameters
IF p_period NOT IN ('day', 'week', 'month') THEN RAISE EXCEPTION 'Period must be one of: day, week, month';

END IF;

-- Check workspace membership authorization
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: not a member of this workspace';

END IF;

-- Determine period key expression
CASE
  p_period
  WHEN 'day' THEN period_key_expression := 'date';

WHEN 'week' THEN period_key_expression := 'DATE_TRUNC(''week'', date)::DATE';

WHEN 'month' THEN period_key_expression := 'DATE_TRUNC(''month'', date)::DATE';

ELSE period_key_expression := 'date';

END CASE
;

-- Get period-based summary
EXECUTE FORMAT(
  'WITH period_summary AS (
            SELECT 
                %s as period_key,
                COUNT(DISTINCT user_id) as unique_users,
                COUNT(*) as total_sessions,
                SUM(COALESCE(duration_seconds, 0)) as total_duration,
                AVG(COALESCE(duration_seconds, 0)) as avg_duration,
                MIN(start_time) as earliest_session,
                MAX(COALESCE(end_time, start_time)) as latest_session,
                COUNT(CASE WHEN is_running THEN 1 END) as active_sessions
            FROM time_tracking_sessions
            WHERE ws_id = ''%s'' AND duration_seconds IS NOT NULL
            GROUP BY %s
            ORDER BY period_key DESC
            LIMIT 10
        )
        SELECT JSON_AGG(
            JSON_BUILD_OBJECT(
                ''period'', period_key::TEXT,
                ''uniqueUsers'', unique_users,
                ''totalSessions'', total_sessions,
                ''totalDuration'', total_duration,
                ''avgDuration'', ROUND(avg_duration),
                ''earliestSession'', earliest_session,
                ''latestSession'', latest_session,
                ''activeSessions'', active_sessions
            ) ORDER BY period_key DESC
        ) as summary
        FROM period_summary',
  period_key_expression,
  p_ws_id,
  period_key_expression
) INTO summary_data;

RETURN COALESCE(summary_data, '[]' :: JSON);

END;

$ $;

ALTER FUNCTION "public"."get_period_summary_stats"("p_ws_id" "uuid", "p_period" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_possible_excluded_groups"("_ws_id" "uuid", "included_groups" "uuid" []) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "ws_id" "uuid",
  "amount" bigint
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY WITH included_users AS (
  SELECT
    wugu.user_id
  FROM
    workspace_user_groups_users wugu
  WHERE
    wugu.group_id = ANY(included_groups)
),
amounts AS (
  SELECT
    wugu.group_id,
    COUNT(*) as amount
  FROM
    workspace_user_groups_users wugu
  WHERE
    wugu.user_id IN (
      SELECT
        user_id
      FROM
        included_users
    )
  GROUP BY
    wugu.group_id
)
SELECT
  DISTINCT ON (wug.id) wug.id,
  wug.name,
  wug.ws_id,
  am.amount
FROM
  workspace_user_groups wug
  JOIN workspace_user_groups_users wugu ON wug.id = wugu.group_id
  LEFT JOIN amounts am ON wug.id = am.group_id
WHERE
  wug.ws_id = _ws_id
  AND wugu.user_id IN (
    SELECT
      user_id
    FROM
      included_users
  )
  AND NOT (wug.id = ANY(included_groups));

END;

$ $;

ALTER FUNCTION "public"."get_possible_excluded_groups"("_ws_id" "uuid", "included_groups" "uuid" []) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_possible_excluded_tags"("_ws_id" "uuid", "included_tags" "uuid" []) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "ws_id" "uuid",
  "amount" bigint
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  DISTINCT ON (wugt.id) wugt.id,
  wugt.name,
  wugt.ws_id,
  (
    SELECT
      COUNT(*)
    FROM
      workspace_user_group_tag_groups ugtg
    WHERE
      ugtg.tag_id = wugt.id
      AND ugtg.group_id IN (
        SELECT
          ugtg.group_id
        FROM
          workspace_user_group_tag_groups ugtg
        WHERE
          ugtg.tag_id = ANY(included_tags)
      )
  ) AS amount
FROM
  workspace_user_group_tags wugt
  JOIN workspace_user_group_tag_groups ugtg ON wugt.id = ugtg.tag_id
WHERE
  wugt.ws_id = _ws_id
  AND ugtg.group_id IN (
    SELECT
      ugtg.group_id
    FROM
      workspace_user_group_tag_groups ugtg
    WHERE
      ugtg.tag_id = ANY(included_tags)
  )
  AND NOT (wugt.id = ANY(included_tags));

END;

$ $;

ALTER FUNCTION "public"."get_possible_excluded_tags"("_ws_id" "uuid", "included_tags" "uuid" []) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_power_users"("limit_count" integer DEFAULT 10) RETURNS TABLE(
  "user_id" "uuid",
  "username" "text",
  "action_count" bigint,
  "last_seen" timestamp with time zone
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH user_activity AS (
    SELECT
      (payload ->> 'actor_id') :: uuid as user_id,
      COUNT(*) as action_count,
      MAX(created_at) as last_seen
    FROM
      auth.audit_log_entries
    WHERE
      created_at >= NOW() - INTERVAL '30 days'
      AND (payload ->> 'actor_id') IS NOT NULL
    GROUP BY
      1
  ),
  ranked_users AS (
    SELECT
      user_id,
      action_count,
      last_seen,
      NTILE(100) OVER (
        ORDER BY
          action_count DESC
      ) as percentile
    FROM
      user_activity
  )
SELECT
  ru.user_id,
  u.raw_user_meta_data ->> 'name' as username,
  ru.action_count,
  ru.last_seen
FROM
  ranked_users ru
  JOIN auth.users u ON ru.user_id = u.id
WHERE
  ru.percentile <= 10 -- Top 10%
ORDER BY
  ru.action_count DESC
LIMIT
  limit_count;

$ $;

ALTER FUNCTION "public"."get_power_users"("limit_count" integer) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_power_users"("limit_count" integer) IS 'Identifies top 10% of users by activity in the last 30 days.';

CREATE
OR REPLACE FUNCTION "public"."get_recent_actions_summary"("limit_count" integer DEFAULT 100) RETURNS TABLE(
  "action" "text",
  "action_count" bigint,
  "last_occurrence" timestamp with time zone,
  "unique_users" bigint
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  payload ->> 'action' AS action,
  COUNT(*) AS action_count,
  MAX(created_at) AS last_occurrence,
  COUNT(DISTINCT (payload ->> 'actor_id') :: uuid) AS unique_users
FROM
  auth.audit_log_entries
WHERE
  created_at >= CURRENT_DATE - INTERVAL '30 days'
  AND payload ->> 'action' IS NOT NULL
GROUP BY
  payload ->> 'action'
ORDER BY
  action_count DESC
LIMIT
  limit_count;

$ $;

ALTER FUNCTION "public"."get_recent_actions_summary"("limit_count" integer) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_recent_actions_summary"("limit_count" integer) IS 'Returns summary of recent platform actions from audit logs';

CREATE
OR REPLACE FUNCTION "public"."get_recent_audit_logs"("limit_count" integer DEFAULT 50) RETURNS TABLE(
  "id" "uuid",
  "action" "text",
  "actor_id" "uuid",
  "actor_username" "text",
  "log_type" "text",
  "created_at" timestamp with time zone,
  "ip_address" character varying
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  id,
  payload ->> 'action' AS action,
  (payload ->> 'actor_id') :: uuid AS actor_id,
  payload ->> 'actor_username' AS actor_username,
  payload ->> 'log_type' AS log_type,
  created_at,
  ip_address
FROM
  auth.audit_log_entries
WHERE
  created_at >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY
  created_at DESC
LIMIT
  limit_count;

$ $;

ALTER FUNCTION "public"."get_recent_audit_logs"("limit_count" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_related_tasks"("p_task_id" "uuid") RETURNS TABLE("task_id" "uuid") LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $ -- Related tasks can be in either direction
SELECT
  target_task_id AS task_id
FROM
  public.task_relationships
WHERE
  source_task_id = p_task_id
  AND type = 'related'
UNION
SELECT
  source_task_id AS task_id
FROM
  public.task_relationships
WHERE
  target_task_id = p_task_id
  AND type = 'related';

$ $;

ALTER FUNCTION "public"."get_related_tasks"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_related_tasks"("p_task_id" "uuid") IS 'Returns all tasks related to the given task (bidirectional)';

CREATE
OR REPLACE FUNCTION "public"."get_retention_rate"("period" "text" DEFAULT 'weekly' :: "text") RETURNS TABLE(
  "cohort_period" "text",
  "cohort_size" bigint,
  "retained_users" bigint,
  "retention_rate" numeric
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE period_interval interval;

trunc_string text;

BEGIN -- Set period based on input
IF period = 'daily' THEN period_interval := '1 day' :: interval;

trunc_string := 'day';

ELSIF period = 'weekly' THEN period_interval := '7 days' :: interval;

trunc_string := 'week';

ELSE period_interval := '30 days' :: interval;

trunc_string := 'month';

END IF;

RETURN QUERY WITH cohorts AS (
  SELECT
    DATE_TRUNC(trunc_string, created_at) AS cohort_period_ts,
    id AS user_id
  FROM
    public.users
  WHERE
    created_at >= CURRENT_DATE - INTERVAL '6 months'
),
cohort_sizes AS (
  SELECT
    cohort_period_ts,
    COUNT(*) AS cohort_size
  FROM
    cohorts
  GROUP BY
    cohort_period_ts
),
retained AS (
  SELECT
    c.cohort_period_ts,
    COUNT(DISTINCT s.user_id) AS retained_users
  FROM
    cohorts c
    INNER JOIN auth.sessions s ON c.user_id = s.user_id
  WHERE
    s.created_at >= c.cohort_period_ts + period_interval
    AND s.created_at < c.cohort_period_ts + (period_interval * 2)
  GROUP BY
    c.cohort_period_ts
)
SELECT
  TO_CHAR(cs.cohort_period_ts, 'YYYY-MM-DD'),
  cs.cohort_size,
  COALESCE(r.retained_users, 0),
  CASE
    WHEN cs.cohort_size > 0 THEN ROUND(
      (
        COALESCE(r.retained_users, 0) :: numeric / cs.cohort_size :: numeric * 100
      ),
      2
    )
    ELSE 0
  END
FROM
  cohort_sizes cs
  LEFT JOIN retained r ON cs.cohort_period_ts = r.cohort_period_ts
ORDER BY
  cs.cohort_period_ts DESC;

END;

$ $;

ALTER FUNCTION "public"."get_retention_rate"("period" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_retention_rate"("period" "text") IS 'Returns retention rate analysis by period';

CREATE
OR REPLACE FUNCTION "public"."get_session_chain_root"("session_id_input" "uuid") RETURNS "uuid" LANGUAGE "plpgsql" STABLE AS $ $ declare "current_session_id" uuid := "session_id_input";

"parent_id" uuid;

"iteration_count" integer := 0;

"max_iterations" integer := 100;

-- Prevent infinite loops
begin -- Traverse up the chain to find root session
loop
select
  "parent_session_id" into "parent_id"
from
  "public"."time_tracking_sessions"
where
  "id" = "current_session_id";

-- If no parent, we've reached the root
if "parent_id" is null then return "current_session_id";

end if;

-- Move to parent
"current_session_id" := "parent_id";

-- Prevent infinite loops
"iteration_count" := "iteration_count" + 1;

if "iteration_count" >= "max_iterations" then raise exception 'Session chain depth exceeds maximum (possible circular reference)';

end if;

end loop;

end;

$ $;

ALTER FUNCTION "public"."get_session_chain_root"("session_id_input" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_session_chain_root"("session_id_input" "uuid") IS 'Traverses session chain to find the root session (first in work period). Used for threshold validation.';

CREATE
OR REPLACE FUNCTION "public"."get_session_chain_summary"("session_id_input" "uuid") RETURNS "jsonb" LANGUAGE "plpgsql" STABLE AS $ $ declare "root_session_id" uuid;

"chain_data" jsonb;

begin -- Get root session
"root_session_id" := "public"."get_session_chain_root"("session_id_input");

-- Build comprehensive chain summary
with recursive "session_chain" as (
  -- Start with root
  select
    "s"."id",
    "s"."parent_session_id",
    "s"."title",
    "s"."description",
    "s"."start_time",
    "s"."end_time",
    "s"."duration_seconds",
    "s"."category_id",
    "s"."task_id",
    1 as "chain_position"
  from
    "public"."time_tracking_sessions" as "s"
  where
    "s"."id" = "root_session_id"
  union
  all -- Recursively get children
  select
    "s"."id",
    "s"."parent_session_id",
    "s"."title",
    "s"."description",
    "s"."start_time",
    "s"."end_time",
    "s"."duration_seconds",
    "s"."category_id",
    "s"."task_id",
    "sc"."chain_position" + 1
  from
    "public"."time_tracking_sessions" as "s"
    inner join "session_chain" as "sc" on "s"."parent_session_id" = "sc"."id"
),
"breaks_data" as (
  -- Get all breaks for sessions in chain
  select
    "b"."id",
    "b"."session_id",
    "b"."break_type_name",
    "b"."break_start",
    "b"."break_end",
    "b"."break_duration_seconds",
    "bt"."name" as "break_type_name_resolved",
    "bt"."color" as "break_type_color",
    "bt"."icon" as "break_type_icon"
  from
    "public"."time_tracking_breaks" as "b"
    left join "public"."workspace_break_types" as "bt" on "bt"."id" = "b"."break_type_id"
  where
    "b"."session_id" in (
      select
        "id"
      from
        "session_chain"
    )
)
select
  jsonb_build_object(
    'root_session_id',
    "root_session_id",
    'sessions',
    (
      select
        jsonb_agg(
          jsonb_build_object(
            'id',
            "sc"."id",
            'title',
            "sc"."title",
            'description',
            "sc"."description",
            'start_time',
            "sc"."start_time",
            'end_time',
            "sc"."end_time",
            'duration_seconds',
            "sc"."duration_seconds",
            'category_id',
            "sc"."category_id",
            'task_id',
            "sc"."task_id",
            'chain_position',
            "sc"."chain_position"
          )
          order by
            "sc"."chain_position"
        )
      from
        "session_chain" as "sc"
    ),
    'breaks',
    (
      select
        jsonb_agg(
          jsonb_build_object(
            'id',
            "bd"."id",
            'session_id',
            "bd"."session_id",
            'break_type_name',
            coalesce(
              "bd"."break_type_name_resolved",
              "bd"."break_type_name",
              'Break'
            ),
            'break_start',
            "bd"."break_start",
            'break_end',
            "bd"."break_end",
            'break_duration_seconds',
            "bd"."break_duration_seconds",
            'break_type_color',
            "bd"."break_type_color",
            'break_type_icon',
            "bd"."break_type_icon"
          )
          order by
            "bd"."break_start"
        )
      from
        "breaks_data" as "bd"
    ),
    'total_work_seconds',
    (
      select
        coalesce(sum("duration_seconds"), 0)
      from
        "session_chain"
    ),
    'total_break_seconds',
    (
      select
        coalesce(sum("break_duration_seconds"), 0)
      from
        "breaks_data"
    ),
    'original_start_time',
    (
      select
        "start_time"
      from
        "session_chain"
      where
        "chain_position" = 1
    ),
    'chain_length',
    (
      select
        count(*)
      from
        "session_chain"
    )
  ) into "chain_data";

return "chain_data";

end;

$ $;

ALTER FUNCTION "public"."get_session_chain_summary"("session_id_input" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_session_chain_summary"("session_id_input" "uuid") IS 'Returns comprehensive summary of session chain including all sessions, breaks, and totals. Used for approval UI.';

CREATE
OR REPLACE FUNCTION "public"."get_session_statistics"() RETURNS TABLE(
  "total_count" bigint,
  "unique_users_count" bigint,
  "active_count" bigint,
  "completed_count" bigint,
  "latest_session_date" timestamp with time zone
) LANGUAGE "sql" STABLE AS $ $
SELECT
  COUNT(*) :: bigint as total_count,
  COUNT(DISTINCT user_id) :: bigint as unique_users_count,
  COUNT(*) FILTER (
    WHERE
      status = 'IN_PROGRESS'
  ) :: bigint as active_count,
  COUNT(*) FILTER (
    WHERE
      status = 'ENDED'
  ) :: bigint as completed_count,
  MAX(start_time) as latest_session_date
FROM
  nova_sessions;

$ $;

ALTER FUNCTION "public"."get_session_statistics"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_session_templates"(
  "workspace_id" "uuid",
  "user_id_param" "uuid",
  "limit_count" integer DEFAULT 10
) RETURNS TABLE(
  "title" "text",
  "description" "text",
  "category_id" "uuid",
  "task_id" "uuid",
  "tags" "text" [],
  "category_name" "text",
  "category_color" "text",
  "task_name" "text",
  "usage_count" bigint,
  "avg_duration" integer,
  "last_used" timestamp with time zone
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  tts.title,
  tts.description,
  tts.category_id,
  tts.task_id,
  tts.tags,
  ttc.name as category_name,
  ttc.color as category_color,
  t.name as task_name,
  COUNT(*) as usage_count,
  AVG(tts.duration_seconds) :: INTEGER as avg_duration,
  MAX(tts.created_at) as last_used
FROM
  time_tracking_sessions tts
  LEFT JOIN time_tracking_categories ttc ON tts.category_id = ttc.id
  LEFT JOIN tasks t ON tts.task_id = t.id
WHERE
  tts.ws_id = workspace_id
  AND tts.user_id = user_id_param
  AND tts.is_running = FALSE
  AND tts.duration_seconds IS NOT NULL
  AND tts.duration_seconds > 300 -- At least 5 minutes
GROUP BY
  tts.title,
  tts.description,
  tts.category_id,
  tts.task_id,
  tts.tags,
  ttc.name,
  ttc.color,
  t.name
HAVING
  COUNT(*) >= 2 -- Used at least twice
ORDER BY
  usage_count DESC,
  last_used DESC
LIMIT
  limit_count;

END;

$ $;

ALTER FUNCTION "public"."get_session_templates"(
  "workspace_id" "uuid",
  "user_id_param" "uuid",
  "limit_count" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_sessions_by_device"() RETURNS TABLE(
  "device_type" "text",
  "session_count" bigint,
  "percentage" numeric
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH device_counts AS (
    SELECT
      CASE
        WHEN user_agent ILIKE '%mobile%'
        OR user_agent ILIKE '%android%'
        OR user_agent ILIKE '%iphone%' THEN 'Mobile'
        WHEN user_agent ILIKE '%tablet%'
        OR user_agent ILIKE '%ipad%' THEN 'Tablet'
        WHEN user_agent ILIKE '%bot%'
        OR user_agent ILIKE '%crawler%' THEN 'Bot'
        WHEN user_agent IS NULL THEN 'Unknown'
        ELSE 'Desktop'
      END AS device_type,
      COUNT(*) AS session_count
    FROM
      auth.sessions
    WHERE
      created_at >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY
      1
  ),
  total AS (
    SELECT
      SUM(session_count) AS total_count
    FROM
      device_counts
  )
SELECT
  dc.device_type,
  dc.session_count,
  ROUND(
    (
      dc.session_count :: numeric / t.total_count :: numeric * 100
    ),
    2
  ) AS percentage
FROM
  device_counts dc,
  total t
ORDER BY
  dc.session_count DESC;

$ $;

ALTER FUNCTION "public"."get_sessions_by_device"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_sign_ins_by_provider"("days" integer DEFAULT 30) RETURNS TABLE(
  "date" "date",
  "provider" "text",
  "sign_in_count" bigint
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  DATE(i.last_sign_in_at) AS date,
  i.provider,
  COUNT(*) AS sign_in_count
FROM
  auth.identities i
WHERE
  i.last_sign_in_at >= CURRENT_DATE - (days || ' days') :: interval
GROUP BY
  DATE(i.last_sign_in_at),
  i.provider
ORDER BY
  date DESC,
  sign_in_count DESC;

$ $;

ALTER FUNCTION "public"."get_sign_ins_by_provider"("days" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_submission_statistics"() RETURNS TABLE(
  "total_count" bigint,
  "latest_submission_date" timestamp with time zone,
  "unique_users_count" bigint
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  (
    SELECT
      COUNT(*)
    FROM
      nova_submissions
  ) as total_count,
  (
    SELECT
      created_at
    FROM
      nova_submissions
    ORDER BY
      created_at DESC
    LIMIT
      1
  ) as latest_submission_date,
  (
    SELECT
      COUNT(DISTINCT user_id)
    FROM
      nova_submissions
    WHERE
      user_id IS NOT NULL
  ) as unique_users_count;

END;

$ $;

ALTER FUNCTION "public"."get_submission_statistics"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_task_children"("p_task_id" "uuid") RETURNS TABLE("task_id" "uuid", "depth" integer) LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $ WITH RECURSIVE children AS (
  -- Base case: direct children
  SELECT
    target_task_id AS task_id,
    1 AS depth
  FROM
    public.task_relationships
  WHERE
    source_task_id = p_task_id
    AND type = 'parent_child'
  UNION
  ALL -- Recursive case: children of children
  SELECT
    tr.target_task_id,
    c.depth + 1
  FROM
    public.task_relationships tr
    INNER JOIN children c ON tr.source_task_id = c.task_id
  WHERE
    tr.type = 'parent_child'
    AND c.depth < 100 -- Prevent infinite recursion
)
SELECT
  *
FROM
  children;

$ $;

ALTER FUNCTION "public"."get_task_children"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_children"("p_task_id" "uuid") IS 'Returns all descendant tasks (children, grandchildren, etc.) of a given task with their depth level';

CREATE
OR REPLACE FUNCTION "public"."get_task_details"("p_task_id" "uuid") RETURNS TABLE(
  "task_name" "text",
  "task_id" "uuid",
  "list_id" "uuid",
  "list_name" "text",
  "board_id" "uuid",
  "board_name" "text",
  "ws_id" "uuid",
  "creator_id" "uuid"
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Harden search_path to prevent privilege escalation
SET
  LOCAL search_path = pg_temp,
  public;

RETURN QUERY
SELECT
  t.name as task_name,
  t.id as task_id,
  tl.id as list_id,
  tl.name as list_name,
  wb.id as board_id,
  wb.name as board_name,
  wb.ws_id as ws_id,
  t.creator_id as creator_id
FROM
  public.tasks t
  JOIN public.task_lists tl ON t.list_id = tl.id
  JOIN public.workspace_boards wb ON tl.board_id = wb.id
WHERE
  t.id = p_task_id;

END;

$ $;

ALTER FUNCTION "public"."get_task_details"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_details"("p_task_id" "uuid") IS 'Gets comprehensive task details including board and workspace information';

CREATE
OR REPLACE FUNCTION "public"."get_task_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_limit" integer DEFAULT 50,
  "p_offset" integer DEFAULT 0,
  "p_change_type" "text" DEFAULT NULL :: "text",
  "p_field_name" "text" DEFAULT NULL :: "text"
) RETURNS TABLE(
  "id" "uuid",
  "task_id" "uuid",
  "task_name" "text",
  "changed_by" "uuid",
  "changed_at" timestamp with time zone,
  "change_type" "text",
  "field_name" "text",
  "old_value" "jsonb",
  "new_value" "jsonb",
  "metadata" "jsonb",
  "user_id" "uuid",
  "user_display_name" "text",
  "user_avatar_url" "text",
  "total_count" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ _ $ DECLARE v_has_access BOOLEAN;

v_task_ws_id UUID;

BEGIN -- Get the workspace ID for the task and verify it matches
SELECT
  wb.ws_id INTO v_task_ws_id
FROM
  public.tasks t
  JOIN public.task_lists tl ON t.list_id = tl.id
  JOIN public.workspace_boards wb ON tl.board_id = wb.id
WHERE
  t.id = p_task_id
  AND t.deleted_at IS NULL;

IF v_task_ws_id IS NULL THEN RAISE EXCEPTION 'Task not found';

END IF;

IF v_task_ws_id != p_ws_id THEN RAISE EXCEPTION 'Task does not belong to this workspace';

END IF;

-- Check if user has access to the workspace
SELECT
  EXISTS (
    SELECT
      1
    FROM
      public.workspace_members wm
    WHERE
      wm.ws_id = p_ws_id
      AND wm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspace_role_members wrm
      JOIN public.workspace_roles wr ON wrm.role_id = wr.id
    WHERE
      wr.ws_id = p_ws_id
      AND wrm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspaces w
    WHERE
      w.id = p_ws_id
      AND w.creator_id = auth.uid()
  ) INTO v_has_access;

IF NOT v_has_access THEN RAISE EXCEPTION 'Access denied to workspace';

END IF;

RETURN QUERY WITH task_info AS (
  SELECT
    t.name AS task_name
  FROM
    public.tasks t
  WHERE
    t.id = p_task_id
),
filtered_history AS (
  SELECT
    th.id,
    th.task_id,
    ti.task_name,
    th.changed_by,
    th.changed_at,
    th.change_type,
    th.field_name,
    th.old_value,
    th.new_value,
    th.metadata,
    COUNT(*) OVER() AS total_count
  FROM
    public.task_history th
    CROSS JOIN task_info ti
  WHERE
    th.task_id = p_task_id
    AND th.deleted_at IS NULL
    AND (
      p_change_type IS NULL
      OR th.change_type = p_change_type
    )
    AND (
      p_field_name IS NULL
      OR th.field_name = p_field_name
    )
  ORDER BY
    th.changed_at DESC,
    th.id DESC
  LIMIT
    p_limit OFFSET p_offset
),
enriched_history AS (
  SELECT
    fh.id,
    fh.task_id,
    fh.task_name,
    fh.changed_by,
    fh.changed_at,
    fh.change_type,
    fh.field_name,
    -- Enrich old_value
    CASE
      -- Project unlinked enrichment
      WHEN fh.change_type = 'project_unlinked'
      AND fh.old_value IS NOT NULL
      AND (
        fh.old_value ->> 'project_name' IS NULL
        OR fh.old_value ->> 'project_name' = ''
      ) THEN CASE
        WHEN fh.old_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
          fh.old_value,
          '{project_name}',
          COALESCE(
            to_jsonb(
              (
                SELECT
                  tp.name
                FROM
                  public.task_projects tp
                WHERE
                  tp.id = (fh.old_value ->> 'project_id') :: uuid
              )
            ),
            '"Unknown project"' :: jsonb
          )
        )
        WHEN fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
        jsonb_build_object(
          'project_id',
          fh.old_value #>> '{}', 'project_name',
          COALESCE(
            (
              SELECT
                tp.name
              FROM
                public.task_projects tp
              WHERE
                tp.id = (
                  fh.old_value #>> '{}')::uuid), 'Unknown project'))
                  ELSE fh.old_value
                END -- Label removed enrichment
                WHEN fh.change_type = 'label_removed'
                AND fh.old_value IS NOT NULL
                AND (
                  fh.old_value ->> 'name' IS NULL
                  OR fh.old_value ->> 'name' = ''
                ) THEN CASE
                  WHEN fh.old_value ->> 'id' IS NOT NULL THEN COALESCE(
                    (
                      SELECT
                        jsonb_build_object(
                          'id',
                          wtl.id,
                          'name',
                          wtl.name,
                          'color',
                          wtl.color
                        )
                      FROM
                        public.workspace_task_labels wtl
                      WHERE
                        wtl.id = (fh.old_value ->> 'id') :: uuid
                    ),
                    fh.old_value
                  )
                  WHEN fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                  COALESCE(
                    (
                      SELECT
                        jsonb_build_object(
                          'id',
                          wtl.id,
                          'name',
                          wtl.name,
                          'color',
                          wtl.color
                        )
                      FROM
                        public.workspace_task_labels wtl
                      WHERE
                        wtl.id = (
                          fh.old_value #>> '{}')::uuid),
                          jsonb_build_object(
                            'id',
                            fh.old_value #>> '{}', 'name', 'Unknown label'))
                            ELSE fh.old_value
                          END
                          ELSE fh.old_value
                        END AS old_value,
                        -- Enrich new_value
                        CASE
                          -- Project linked enrichment
                          WHEN fh.change_type = 'project_linked'
                          AND fh.new_value IS NOT NULL
                          AND (
                            fh.new_value ->> 'project_name' IS NULL
                            OR fh.new_value ->> 'project_name' = ''
                          ) THEN CASE
                            WHEN fh.new_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                              fh.new_value,
                              '{project_name}',
                              COALESCE(
                                to_jsonb(
                                  (
                                    SELECT
                                      tp.name
                                    FROM
                                      public.task_projects tp
                                    WHERE
                                      tp.id = (fh.new_value ->> 'project_id') :: uuid
                                  )
                                ),
                                '"Unknown project"' :: jsonb
                              )
                            )
                            WHEN fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                            jsonb_build_object(
                              'project_id',
                              fh.new_value #>> '{}', 'project_name',
                              COALESCE(
                                (
                                  SELECT
                                    tp.name
                                  FROM
                                    public.task_projects tp
                                  WHERE
                                    tp.id = (
                                      fh.new_value #>> '{}')::uuid), 'Unknown project'))
                                      ELSE fh.new_value
                                    END -- Label added enrichment
                                    WHEN fh.change_type = 'label_added'
                                    AND fh.new_value IS NOT NULL
                                    AND (
                                      fh.new_value ->> 'name' IS NULL
                                      OR fh.new_value ->> 'name' = ''
                                    ) THEN CASE
                                      WHEN fh.new_value ->> 'id' IS NOT NULL THEN COALESCE(
                                        (
                                          SELECT
                                            jsonb_build_object(
                                              'id',
                                              wtl.id,
                                              'name',
                                              wtl.name,
                                              'color',
                                              wtl.color
                                            )
                                          FROM
                                            public.workspace_task_labels wtl
                                          WHERE
                                            wtl.id = (fh.new_value ->> 'id') :: uuid
                                        ),
                                        fh.new_value
                                      )
                                      WHEN fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                      COALESCE(
                                        (
                                          SELECT
                                            jsonb_build_object(
                                              'id',
                                              wtl.id,
                                              'name',
                                              wtl.name,
                                              'color',
                                              wtl.color
                                            )
                                          FROM
                                            public.workspace_task_labels wtl
                                          WHERE
                                            wtl.id = (
                                              fh.new_value #>> '{}')::uuid),
                                              jsonb_build_object(
                                                'id',
                                                fh.new_value #>> '{}', 'name', 'Unknown label'))
                                                ELSE fh.new_value
                                              END
                                              ELSE fh.new_value
                                            END AS new_value,
                                            -- Enrich metadata
                                            CASE
                                              -- Project metadata enrichment
                                              WHEN fh.change_type IN ('project_linked', 'project_unlinked')
                                              AND (
                                                fh.metadata ->> 'project_name' IS NULL
                                                OR fh.metadata ->> 'project_name' = ''
                                              ) THEN CASE
                                                WHEN fh.change_type = 'project_linked'
                                                AND fh.new_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                  '{project_name}',
                                                  COALESCE(
                                                    to_jsonb(
                                                      (
                                                        SELECT
                                                          tp.name
                                                        FROM
                                                          public.task_projects tp
                                                        WHERE
                                                          tp.id = (fh.new_value ->> 'project_id') :: uuid
                                                      )
                                                    ),
                                                    '"Unknown project"' :: jsonb
                                                  )
                                                )
                                                WHEN fh.change_type = 'project_linked'
                                                AND fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                                jsonb_set(
                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                  '{project_name}',
                                                  COALESCE(
                                                    to_jsonb(
                                                      (
                                                        SELECT
                                                          tp.name
                                                        FROM
                                                          public.task_projects tp
                                                        WHERE
                                                          tp.id = (
                                                            fh.new_value #>> '{}')::uuid)), '"Unknown project"'::jsonb))
                                                            WHEN fh.change_type = 'project_unlinked'
                                                            AND fh.old_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                                                              COALESCE(fh.metadata, '{}' :: jsonb),
                                                              '{project_name}',
                                                              COALESCE(
                                                                to_jsonb(
                                                                  (
                                                                    SELECT
                                                                      tp.name
                                                                    FROM
                                                                      public.task_projects tp
                                                                    WHERE
                                                                      tp.id = (fh.old_value ->> 'project_id') :: uuid
                                                                  )
                                                                ),
                                                                '"Unknown project"' :: jsonb
                                                              )
                                                            )
                                                            WHEN fh.change_type = 'project_unlinked'
                                                            AND fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                                            jsonb_set(
                                                              COALESCE(fh.metadata, '{}' :: jsonb),
                                                              '{project_name}',
                                                              COALESCE(
                                                                to_jsonb(
                                                                  (
                                                                    SELECT
                                                                      tp.name
                                                                    FROM
                                                                      public.task_projects tp
                                                                    WHERE
                                                                      tp.id = (
                                                                        fh.old_value #>> '{}')::uuid)), '"Unknown project"'::jsonb))
                                                                        ELSE fh.metadata
                                                                      END -- Label metadata enrichment
                                                                      WHEN fh.change_type IN ('label_added', 'label_removed')
                                                                      AND (
                                                                        fh.metadata ->> 'label_name' IS NULL
                                                                        OR fh.metadata ->> 'label_name' = ''
                                                                      ) THEN CASE
                                                                        WHEN fh.change_type = 'label_added'
                                                                        AND fh.new_value ->> 'id' IS NOT NULL THEN COALESCE(
                                                                          (
                                                                            SELECT
                                                                              jsonb_set(
                                                                                jsonb_set(
                                                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                                                  '{label_name}',
                                                                                  COALESCE(to_jsonb(wtl.name), '"Unknown label"' :: jsonb)
                                                                                ),
                                                                                '{label_color}',
                                                                                COALESCE(to_jsonb(wtl.color), 'null' :: jsonb)
                                                                              )
                                                                            FROM
                                                                              public.workspace_task_labels wtl
                                                                            WHERE
                                                                              wtl.id = (fh.new_value ->> 'id') :: uuid
                                                                          ),
                                                                          fh.metadata
                                                                        )
                                                                        WHEN fh.change_type = 'label_removed'
                                                                        AND fh.old_value ->> 'id' IS NOT NULL THEN COALESCE(
                                                                          (
                                                                            SELECT
                                                                              jsonb_set(
                                                                                jsonb_set(
                                                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                                                  '{label_name}',
                                                                                  COALESCE(to_jsonb(wtl.name), '"Unknown label"' :: jsonb)
                                                                                ),
                                                                                '{label_color}',
                                                                                COALESCE(to_jsonb(wtl.color), 'null' :: jsonb)
                                                                              )
                                                                            FROM
                                                                              public.workspace_task_labels wtl
                                                                            WHERE
                                                                              wtl.id = (fh.old_value ->> 'id') :: uuid
                                                                          ),
                                                                          fh.metadata
                                                                        )
                                                                        ELSE fh.metadata
                                                                      END
                                                                      ELSE fh.metadata
                                                                  END AS metadata,
                                                                  fh.total_count
                                                                  FROM
                                                                    filtered_history fh
                                                                )
                                                                SELECT
                                                                  eh.id,
                                                                  eh.task_id,
                                                                  eh.task_name,
                                                                  eh.changed_by,
                                                                  eh.changed_at,
                                                                  eh.change_type,
                                                                  eh.field_name,
                                                                  eh.old_value,
                                                                  eh.new_value,
                                                                  eh.metadata,
                                                                  u.id AS user_id,
                                                                  u.display_name AS user_display_name,
                                                                  u.avatar_url AS user_avatar_url,
                                                                  eh.total_count
                                                                FROM
                                                                  enriched_history eh
                                                                  LEFT JOIN public.users u ON eh.changed_by = u.id;

END;

$ _ $;

ALTER FUNCTION "public"."get_task_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_limit" integer,
  "p_offset" integer,
  "p_change_type" "text",
  "p_field_name" "text"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_limit" integer,
  "p_offset" integer,
  "p_change_type" "text",
  "p_field_name" "text"
) IS 'Retrieves history for a specific task with pagination, filtering, user info, and dynamic lookup for project and label names when missing.';

CREATE
OR REPLACE FUNCTION "public"."get_task_parents"("p_task_id" "uuid") RETURNS TABLE("task_id" "uuid", "depth" integer) LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $ WITH RECURSIVE parents AS (
  -- Base case: direct parent
  SELECT
    source_task_id AS task_id,
    1 AS depth
  FROM
    public.task_relationships
  WHERE
    target_task_id = p_task_id
    AND type = 'parent_child'
  UNION
  ALL -- Recursive case: parent of parent
  SELECT
    tr.source_task_id,
    p.depth + 1
  FROM
    public.task_relationships tr
    INNER JOIN parents p ON tr.target_task_id = p.task_id
  WHERE
    tr.type = 'parent_child'
    AND p.depth < 100 -- Prevent infinite recursion
)
SELECT
  *
FROM
  parents;

$ $;

ALTER FUNCTION "public"."get_task_parents"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_parents"("p_task_id" "uuid") IS 'Returns all ancestor tasks (parent, grandparent, etc.) of a given task with their depth level';

CREATE
OR REPLACE FUNCTION "public"."get_task_relationships_at_snapshot"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) RETURNS "jsonb" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE v_target_changed_at TIMESTAMPTZ;

v_assignees JSONB := '[]' :: jsonb;

v_labels JSONB := '[]' :: jsonb;

v_projects JSONB := '[]' :: jsonb;

v_entry RECORD;

v_has_access BOOLEAN;

v_user_id UUID;

v_label_id UUID;

v_project_id UUID;

BEGIN -- Verify workspace access (same check as above)
SELECT
  EXISTS (
    SELECT
      1
    FROM
      public.workspace_members wm
    WHERE
      wm.ws_id = p_ws_id
      AND wm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspace_role_members wrm
      JOIN public.workspace_roles wr ON wrm.role_id = wr.id
    WHERE
      wr.ws_id = p_ws_id
      AND wrm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspaces w
    WHERE
      w.id = p_ws_id
      AND w.creator_id = auth.uid()
  ) INTO v_has_access;

IF NOT v_has_access THEN RAISE EXCEPTION 'Access denied to workspace';

END IF;

-- Get target timestamp
SELECT
  changed_at INTO v_target_changed_at
FROM
  task_history
WHERE
  id = p_history_id
  AND task_id = p_task_id
  AND deleted_at IS NULL;

IF v_target_changed_at IS NULL THEN RAISE EXCEPTION 'History entry not found';

END IF;

-- Start with current relationships
-- Get current assignees
SELECT
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id',
        u.id,
        'user_id',
        u.id,
        'display_name',
        u.display_name,
        'avatar_url',
        u.avatar_url
      )
    ),
    '[]' :: jsonb
  ) INTO v_assignees
FROM
  task_assignees ta
  JOIN users u ON ta.user_id = u.id
WHERE
  ta.task_id = p_task_id;

-- Get current labels
SELECT
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id',
        l.id,
        'name',
        l.name,
        'color',
        l.color
      )
    ),
    '[]' :: jsonb
  ) INTO v_labels
FROM
  task_labels tl
  JOIN workspace_task_labels l ON tl.label_id = l.id
WHERE
  tl.task_id = p_task_id;

-- Get current projects
SELECT
  COALESCE(
    jsonb_agg(
      jsonb_build_object(
        'id',
        p.id,
        'name',
        p.name
      )
    ),
    '[]' :: jsonb
  ) INTO v_projects
FROM
  task_project_tasks tpt
  JOIN task_projects p ON tpt.project_id = p.id
WHERE
  tpt.task_id = p_task_id;

-- Apply reverse relationship changes from newest to target point
FOR v_entry IN
SELECT
  th.change_type,
  th.old_value,
  th.new_value,
  th.metadata
FROM
  task_history th
WHERE
  th.task_id = p_task_id
  AND th.changed_at > v_target_changed_at
  AND th.change_type IN (
    'assignee_added',
    'assignee_removed',
    'label_added',
    'label_removed',
    'project_linked',
    'project_unlinked'
  )
  AND th.deleted_at IS NULL
ORDER BY
  th.changed_at DESC,
  th.id DESC LOOP CASE
    v_entry.change_type -- Assignee changes
    WHEN 'assignee_added' THEN -- Revert: remove this assignee from snapshot
    v_user_id := COALESCE(
      (v_entry.new_value ->> 'user_id') :: uuid,
      (v_entry.new_value ->> 'id') :: uuid,
      (v_entry.metadata ->> 'user_id') :: uuid
    );

IF v_user_id IS NOT NULL THEN v_assignees := (
  SELECT
    COALESCE(jsonb_agg(elem), '[]' :: jsonb)
  FROM
    jsonb_array_elements(v_assignees) elem
  WHERE
    (elem ->> 'id') :: uuid != v_user_id
    AND (elem ->> 'user_id') :: uuid != v_user_id
);

END IF;

WHEN 'assignee_removed' THEN -- Revert: add this assignee back to snapshot
IF v_entry.old_value IS NOT NULL
AND v_entry.old_value != 'null' :: jsonb THEN -- Check if already exists
v_user_id := COALESCE(
  (v_entry.old_value ->> 'user_id') :: uuid,
  (v_entry.old_value ->> 'id') :: uuid
);

IF v_user_id IS NOT NULL
AND NOT EXISTS (
  SELECT
    1
  FROM
    jsonb_array_elements(v_assignees) elem
  WHERE
    (elem ->> 'id') :: uuid = v_user_id
    OR (elem ->> 'user_id') :: uuid = v_user_id
) THEN v_assignees := v_assignees || jsonb_build_object(
  'id',
  v_user_id,
  'user_id',
  v_user_id,
  'display_name',
  COALESCE(
    v_entry.old_value ->> 'display_name',
    v_entry.old_value ->> 'user_name',
    v_entry.metadata ->> 'assignee_name',
    'Unknown'
  ),
  'avatar_url',
  COALESCE(
    v_entry.old_value ->> 'avatar_url',
    v_entry.metadata ->> 'avatar_url'
  )
);

END IF;

END IF;

-- Label changes
WHEN 'label_added' THEN -- Revert: remove this label from snapshot
v_label_id := COALESCE(
  (v_entry.new_value ->> 'id') :: uuid,
  (v_entry.metadata ->> 'label_id') :: uuid
);

IF v_label_id IS NOT NULL THEN v_labels := (
  SELECT
    COALESCE(jsonb_agg(elem), '[]' :: jsonb)
  FROM
    jsonb_array_elements(v_labels) elem
  WHERE
    (elem ->> 'id') :: uuid != v_label_id
);

END IF;

WHEN 'label_removed' THEN -- Revert: add this label back to snapshot
IF v_entry.old_value IS NOT NULL
AND v_entry.old_value != 'null' :: jsonb THEN v_label_id := (v_entry.old_value ->> 'id') :: uuid;

IF v_label_id IS NOT NULL
AND NOT EXISTS (
  SELECT
    1
  FROM
    jsonb_array_elements(v_labels) elem
  WHERE
    (elem ->> 'id') :: uuid = v_label_id
) THEN v_labels := v_labels || jsonb_build_object(
  'id',
  v_label_id,
  'name',
  COALESCE(
    v_entry.old_value ->> 'name',
    v_entry.metadata ->> 'label_name',
    'Unknown'
  ),
  'color',
  COALESCE(
    v_entry.old_value ->> 'color',
    v_entry.metadata ->> 'label_color'
  )
);

END IF;

END IF;

-- Project changes
WHEN 'project_linked' THEN -- Revert: remove this project from snapshot
v_project_id := COALESCE(
  (v_entry.new_value ->> 'id') :: uuid,
  (v_entry.new_value ->> 'project_id') :: uuid,
  (v_entry.metadata ->> 'project_id') :: uuid
);

IF v_project_id IS NOT NULL THEN v_projects := (
  SELECT
    COALESCE(jsonb_agg(elem), '[]' :: jsonb)
  FROM
    jsonb_array_elements(v_projects) elem
  WHERE
    (elem ->> 'id') :: uuid != v_project_id
);

END IF;

WHEN 'project_unlinked' THEN -- Revert: add this project back to snapshot
IF v_entry.old_value IS NOT NULL
AND v_entry.old_value != 'null' :: jsonb THEN v_project_id := (v_entry.old_value ->> 'id') :: uuid;

IF v_project_id IS NOT NULL
AND NOT EXISTS (
  SELECT
    1
  FROM
    jsonb_array_elements(v_projects) elem
  WHERE
    (elem ->> 'id') :: uuid = v_project_id
) THEN v_projects := v_projects || jsonb_build_object(
  'id',
  v_project_id,
  'name',
  COALESCE(
    v_entry.old_value ->> 'name',
    v_entry.old_value ->> 'project_name',
    v_entry.metadata ->> 'project_name',
    'Unknown'
  )
);

END IF;

END IF;

END CASE
;

END LOOP;

RETURN jsonb_build_object(
  'assignees',
  v_assignees,
  'labels',
  v_labels,
  'projects',
  v_projects
);

END;

$ $;

ALTER FUNCTION "public"."get_task_relationships_at_snapshot"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_relationships_at_snapshot"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) IS 'Reconstructs the relationship state (assignees, labels, projects) of a task at a
specific history entry point. Works in conjunction with get_task_snapshot_at_history.';

CREATE
OR REPLACE FUNCTION "public"."get_task_snapshot_at_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) RETURNS "jsonb" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE v_snapshot JSONB;

v_target_changed_at TIMESTAMPTZ;

v_has_access BOOLEAN;

v_current_task RECORD;

v_history_entry RECORD;

v_task_ws_id UUID;

BEGIN -- Verify workspace access
SELECT
  EXISTS (
    SELECT
      1
    FROM
      public.workspace_members wm
    WHERE
      wm.ws_id = p_ws_id
      AND wm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspace_role_members wrm
      JOIN public.workspace_roles wr ON wrm.role_id = wr.id
    WHERE
      wr.ws_id = p_ws_id
      AND wrm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspaces w
    WHERE
      w.id = p_ws_id
      AND w.creator_id = auth.uid()
  ) INTO v_has_access;

IF NOT v_has_access THEN RAISE EXCEPTION 'Access denied to workspace';

END IF;

-- Verify task belongs to workspace
SELECT
  wb.ws_id INTO v_task_ws_id
FROM
  tasks t
  JOIN task_lists tl ON t.list_id = tl.id
  JOIN workspace_boards wb ON tl.board_id = wb.id
WHERE
  t.id = p_task_id;

IF v_task_ws_id IS NULL THEN RAISE EXCEPTION 'Task not found';

END IF;

IF v_task_ws_id != p_ws_id THEN RAISE EXCEPTION 'Task does not belong to this workspace';

END IF;

-- Get target history entry timestamp
SELECT
  changed_at INTO v_target_changed_at
FROM
  task_history
WHERE
  id = p_history_id
  AND task_id = p_task_id
  AND deleted_at IS NULL;

IF v_target_changed_at IS NULL THEN RAISE EXCEPTION 'History entry not found';

END IF;

-- Get current task state (using completed_at instead of completed, removed archived)
SELECT
  t.id,
  t.name,
  t.description,
  t.priority,
  t.start_date,
  t.end_date,
  t.estimation_points,
  t.list_id,
  t.completed_at IS NOT NULL as completed,
  t.created_at,
  tl.name as list_name,
  tl.board_id INTO v_current_task
FROM
  tasks t
  JOIN task_lists tl ON t.list_id = tl.id
WHERE
  t.id = p_task_id;

-- Build initial snapshot from current task (removed archived field)
v_snapshot := jsonb_build_object(
  'id',
  v_current_task.id,
  'name',
  v_current_task.name,
  'description',
  v_current_task.description,
  'priority',
  v_current_task.priority,
  'start_date',
  v_current_task.start_date,
  'end_date',
  v_current_task.end_date,
  'estimation_points',
  v_current_task.estimation_points,
  'list_id',
  v_current_task.list_id,
  'list_name',
  v_current_task.list_name,
  'completed',
  v_current_task.completed,
  'created_at',
  v_current_task.created_at,
  'board_id',
  v_current_task.board_id
);

-- Apply reverse changes from newest to target point
-- This reconstructs the state at the target history entry
FOR v_history_entry IN
SELECT
  th.field_name,
  th.old_value,
  th.new_value,
  th.change_type,
  th.metadata
FROM
  task_history th
WHERE
  th.task_id = p_task_id
  AND th.changed_at > v_target_changed_at
  AND th.change_type = 'field_updated'
  AND th.field_name IS NOT NULL
  AND th.deleted_at IS NULL
ORDER BY
  th.changed_at DESC,
  th.id DESC LOOP -- Revert each field change by applying old_value
  -- Handle different field types appropriately
  CASE
    v_history_entry.field_name
    WHEN 'name' THEN v_snapshot := jsonb_set(
      v_snapshot,
      '{name}',
      COALESCE(
        to_jsonb(
          v_history_entry.old_value #>> '{}'), 'null'::jsonb));
          WHEN 'description' THEN v_snapshot := jsonb_set(
            v_snapshot,
            '{description}',
            COALESCE(v_history_entry.old_value, 'null' :: jsonb)
          );

WHEN 'priority' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{priority}',
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

WHEN 'start_date' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{start_date}',
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

WHEN 'end_date' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{end_date}',
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

WHEN 'estimation_points' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{estimation_points}',
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

WHEN 'list_id' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{list_id}',
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

-- Also update list_name from metadata if available
IF v_history_entry.metadata ? 'old_list_name' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{list_name}',
  to_jsonb(v_history_entry.metadata ->> 'old_list_name')
);

END IF;

WHEN 'completed' THEN v_snapshot := jsonb_set(
  v_snapshot,
  '{completed}',
  COALESCE(v_history_entry.old_value, 'false' :: jsonb)
);

ELSE -- For any other fields, apply the old value directly
v_snapshot := jsonb_set(
  v_snapshot,
  ARRAY [v_history_entry.field_name],
  COALESCE(v_history_entry.old_value, 'null' :: jsonb)
);

END CASE
;

END LOOP;

RETURN v_snapshot;

END;

$ $;

ALTER FUNCTION "public"."get_task_snapshot_at_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_snapshot_at_history"(
  "p_ws_id" "uuid",
  "p_task_id" "uuid",
  "p_history_id" "uuid"
) IS 'Reconstructs the state of a task at a specific history entry point by reverse-applying
all changes that occurred after that point. Returns core task fields as JSONB.';

CREATE
OR REPLACE FUNCTION "public"."get_task_workspace_id"("p_task_id" "uuid") RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_ws_id UUID;

BEGIN -- Harden search_path to prevent privilege escalation
SET
  LOCAL search_path = pg_temp,
  public;

SELECT
  wb.ws_id INTO v_ws_id
FROM
  public.tasks t
  JOIN public.task_lists tl ON t.list_id = tl.id
  JOIN public.workspace_boards wb ON tl.board_id = wb.id
WHERE
  t.id = p_task_id;

RETURN v_ws_id;

END;

$ $;

ALTER FUNCTION "public"."get_task_workspace_id"("p_task_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_task_workspace_id"("p_task_id" "uuid") IS 'Gets the workspace ID for a given task ID by traversing task -> list -> board -> workspace';

CREATE
OR REPLACE FUNCTION "public"."get_time_tracker_stats"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean DEFAULT false,
  "p_timezone" "text" DEFAULT 'UTC' :: "text"
) RETURNS TABLE(
  "today_time" bigint,
  "week_time" bigint,
  "month_time" bigint,
  "streak" integer,
  "daily_activity" "jsonb"
) LANGUAGE "plpgsql" STABLE AS $ $ DECLARE v_start_of_week DATE;

v_start_of_month DATE;

v_current_date DATE;

BEGIN -- Calculate current date in the user's timezone
v_current_date := (CURRENT_TIMESTAMP AT TIME ZONE p_timezone) :: DATE;

-- Calculate start of week (Monday) in user's timezone
v_start_of_week := DATE_TRUNC('week', v_current_date :: TIMESTAMP) :: DATE;

-- Calculate start of month in user's timezone
v_start_of_month := DATE_TRUNC('month', v_current_date :: TIMESTAMP) :: DATE;

RETURN QUERY WITH timezone_sessions AS (
  -- For each session, generate a row for each day it spans IN THE USER'S TIMEZONE
  SELECT
    s.id,
    s.user_id,
    s.ws_id,
    s.start_time,
    s.end_time,
    s.duration_seconds,
    day_series.activity_date,
    -- Calculate how much of the session falls on this day in user's timezone
    CASE
      -- Session starts and ends on the same day in user's timezone
      WHEN (s.start_time AT TIME ZONE p_timezone) :: DATE = (
        COALESCE(s.end_time, s.start_time) AT TIME ZONE p_timezone
      ) :: DATE THEN s.duration_seconds -- Session spans multiple days - calculate duration for this specific day
      ELSE EXTRACT(
        EPOCH
        FROM
          (
            LEAST(
              -- End of this day in user's timezone (converted back to UTC for comparison)
              (day_series.activity_date + INTERVAL '1 day') :: TIMESTAMP AT TIME ZONE p_timezone,
              COALESCE(s.end_time, CURRENT_TIMESTAMP)
            ) - GREATEST(
              -- Start of this day in user's timezone (converted back to UTC for comparison)
              day_series.activity_date :: TIMESTAMP AT TIME ZONE p_timezone,
              s.start_time
            )
          )
      ) :: BIGINT
    END AS day_duration
  FROM
    time_tracking_sessions s
    CROSS JOIN LATERAL generate_series(
      (s.start_time AT TIME ZONE p_timezone) :: DATE,
      (
        COALESCE(s.end_time, s.start_time) AT TIME ZONE p_timezone
      ) :: DATE,
      '1 day' :: INTERVAL
    ) AS day_series(activity_date)
  WHERE
    s.user_id = p_user_id
    AND (
      p_is_personal
      OR s.ws_id = p_ws_id
    )
    AND s.duration_seconds IS NOT NULL
    AND (s.start_time AT TIME ZONE p_timezone) :: DATE >= v_current_date - INTERVAL '1 year'
),
daily_aggregates AS (
  SELECT
    activity_date,
    SUM(day_duration) AS total_duration,
    COUNT(DISTINCT id) AS session_count
  FROM
    timezone_sessions
  WHERE
    day_duration > 0
  GROUP BY
    activity_date
),
stats AS (
  SELECT
    -- Today's total duration (in user's timezone)
    COALESCE(
      SUM(
        CASE
          WHEN activity_date = v_current_date THEN total_duration
          ELSE 0
        END
      ),
      0
    ) :: BIGINT AS today_duration,
    -- This week's total duration (in user's timezone)
    COALESCE(
      SUM(
        CASE
          WHEN activity_date >= v_start_of_week THEN total_duration
          ELSE 0
        END
      ),
      0
    ) :: BIGINT AS week_duration,
    -- This month's total duration (in user's timezone)
    COALESCE(
      SUM(
        CASE
          WHEN activity_date >= v_start_of_month THEN total_duration
          ELSE 0
        END
      ),
      0
    ) :: BIGINT AS month_duration,
    -- Daily activity as JSON array (last year of data)
    COALESCE(
      JSONB_AGG(
        JSONB_BUILD_OBJECT(
          'date',
          activity_date :: TEXT,
          'duration',
          total_duration,
          'sessions',
          session_count
        )
        ORDER BY
          activity_date DESC
      ),
      '[]' :: JSONB
    ) AS daily_data
  FROM
    daily_aggregates
)
SELECT
  stats.today_duration,
  stats.week_duration,
  stats.month_duration,
  calculate_time_tracker_streak(p_user_id, p_ws_id, p_is_personal),
  stats.daily_data
FROM
  stats;

END;

$ $;

ALTER FUNCTION "public"."get_time_tracker_stats"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean,
  "p_timezone" "text"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_time_tracker_stats"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_is_personal" boolean,
  "p_timezone" "text"
) IS 'Returns timezone-aware time tracking statistics for a user in a workspace. Calculates today, week, month totals, streak, and daily activity data based on the specified timezone. Sessions that cross days are properly split based on the user''s local timezone.';

CREATE
OR REPLACE FUNCTION "public"."get_time_tracking_daily_activity"(
  "p_ws_id" "uuid",
  "p_days_back" integer DEFAULT 30,
  "p_user_id" "uuid" DEFAULT NULL :: "uuid"
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE activity_data json;

user_filter text := '';

BEGIN -- Check if user has access to the workspace
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: user is not a member of this workspace';

END IF;

-- If specific user requested, ensure it's either the current user or user has admin access
IF p_user_id IS NOT NULL
AND p_user_id != auth.uid() THEN IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
    AND public.has_workspace_permission(p_ws_id, auth.uid(), 'manage_workspace_members')
) THEN RAISE EXCEPTION 'Access denied: insufficient permissions to view other users data';

END IF;

END IF;

-- Add user filter if specified
IF p_user_id IS NOT NULL THEN user_filter := FORMAT(' AND user_id = ''%s''', p_user_id);

END IF;

-- Get daily activity data
EXECUTE FORMAT(
  'SELECT JSON_AGG(
            JSON_BUILD_OBJECT(
                ''date'', date::TEXT,
                ''duration'', total_duration,
                ''sessions'', session_count,
                ''users'', unique_users
            ) ORDER BY date
        ) as activity
        FROM (
            SELECT 
                date,
                SUM(COALESCE(duration_seconds, 0)) as total_duration,
                COUNT(*) as session_count,
                COUNT(DISTINCT user_id) as unique_users
            FROM time_tracking_sessions
            WHERE ws_id = ''%s''%s 
                AND date >= CURRENT_DATE - INTERVAL ''%s days''
                AND duration_seconds IS NOT NULL
            GROUP BY date
            ORDER BY date
        ) daily_stats',
  p_ws_id,
  user_filter,
  p_days_back
) INTO activity_data;

RETURN COALESCE(activity_data, '[]' :: JSON);

END;

$ $;

ALTER FUNCTION "public"."get_time_tracking_daily_activity"(
  "p_ws_id" "uuid",
  "p_days_back" integer,
  "p_user_id" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_time_tracking_sessions_paginated"(
  "p_ws_id" "uuid",
  "p_period" "text" DEFAULT 'day' :: "text",
  "p_page" integer DEFAULT 1,
  "p_limit" integer DEFAULT 50,
  "p_search" "text" DEFAULT NULL :: "text"
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE offset_value INTEGER;

total_count INTEGER;

sessions_data JSON;

period_key_expression TEXT;

where_clause TEXT := '';

search_clause TEXT := '';

BEGIN -- Set secure search path to prevent function hijacking
PERFORM set_config('search_path', 'public, pg_temp', true);

-- Validate input parameters
IF p_page < 1 THEN RAISE EXCEPTION 'Page must be >= 1';

END IF;

IF p_limit <= 0
OR p_limit > 200 THEN RAISE EXCEPTION 'Limit must be between 1 and 200';

END IF;

IF p_period NOT IN ('day', 'week', 'month') THEN RAISE EXCEPTION 'Period must be one of: day, week, month';

END IF;

-- Check workspace membership authorization
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: not a member of this workspace';

END IF;

-- Calculate offset
offset_value := (p_page - 1) * p_limit;

-- Determine period key expression based on period type
CASE
  p_period
  WHEN 'day' THEN period_key_expression := 'date';

WHEN 'week' THEN -- Use ISO week starting Monday (standard PostgreSQL approach)
period_key_expression := 'DATE_TRUNC(''week'', date)::DATE';

WHEN 'month' THEN period_key_expression := 'DATE_TRUNC(''month'', date)::DATE';

ELSE period_key_expression := 'date';

END CASE
;

-- Build search clause if search term provided
IF p_search IS NOT NULL
AND LENGTH(p_search) > 0 THEN search_clause := ' AND (u.display_name ILIKE ' || quote_literal('%' || p_search || '%') || ' OR tts.title ILIKE ' || quote_literal('%' || p_search || '%') || ' OR ttc.name ILIKE ' || quote_literal('%' || p_search || '%') || ')';

END IF;

-- Build complete WHERE clause
where_clause := FORMAT(
  'WHERE tts.ws_id = ''%s''%s',
  p_ws_id,
  search_clause
);

-- Get total count for pagination metadata
-- Using ROW constructor for better performance than string concatenation
EXECUTE FORMAT(
  'SELECT COUNT(DISTINCT ROW((%s), tts.user_id)) 
         FROM time_tracking_sessions tts
         LEFT JOIN users u ON u.id = tts.user_id
         LEFT JOIN time_tracking_categories ttc ON ttc.id = tts.category_id
         %s',
  period_key_expression,
  where_clause
) INTO total_count;

-- Get grouped sessions data
EXECUTE FORMAT(
  'WITH grouped_sessions AS (
            SELECT 
                %s as period_key,
                tts.user_id,
                u.display_name,
                u.avatar_url,
                COUNT(tts.id) as session_count,
                SUM(COALESCE(tts.duration_seconds, 0)) as total_duration,
                MIN(tts.start_time) as first_start_time,
                MAX(tts.end_time) as last_end_time,
                BOOL_OR(tts.is_running) as has_running_session,
                CASE 
                    WHEN BOOL_OR(tts.is_running) THEN ''active''
                    WHEN COUNT(CASE WHEN tts.end_time IS NULL THEN 1 END) > 0 THEN ''paused''
                    ELSE ''completed''
                END as status,
                ARRAY_AGG(DISTINCT tts.title) FILTER (WHERE tts.title IS NOT NULL) as session_titles,
                JSON_AGG(
                    JSON_BUILD_OBJECT(
                        ''id'', tts.id,
                        ''title'', tts.title,
                        ''description'', tts.description,
                        ''start_time'', tts.start_time,
                        ''end_time'', tts.end_time,
                        ''duration_seconds'', tts.duration_seconds,
                        ''is_running'', tts.is_running,
                        ''category'', CASE WHEN ttc.id IS NOT NULL THEN 
                            JSON_BUILD_OBJECT(''name'', ttc.name, ''color'', ttc.color) 
                            ELSE NULL END
                    ) ORDER BY tts.start_time DESC
                ) as sessions
            FROM time_tracking_sessions tts
            LEFT JOIN users u ON u.id = tts.user_id
            LEFT JOIN time_tracking_categories ttc ON ttc.id = tts.category_id
            %s
            GROUP BY %s, tts.user_id, u.display_name, u.avatar_url
            ORDER BY period_key DESC, total_duration DESC
            LIMIT %s OFFSET %s
        )
        SELECT JSON_AGG(
            JSON_BUILD_OBJECT(
                ''title'', COALESCE(display_name, ''Unknown User'') || '' - '' || period_key::TEXT,
                ''category'', NULL,
                ''sessions'', sessions,
                ''totalDuration'', total_duration,
                ''firstStartTime'', first_start_time,
                ''lastEndTime'', last_end_time,
                ''status'', status,
                ''user'', JSON_BUILD_OBJECT(
                    ''displayName'', display_name,
                    ''avatarUrl'', avatar_url
                ),
                ''period'', period_key::TEXT,
                ''sessionCount'', session_count,
                ''sessionTitles'', session_titles
            )
        ) as data
        FROM grouped_sessions',
  period_key_expression,
  where_clause,
  period_key_expression,
  p_limit,
  offset_value
) INTO sessions_data;

-- Return paginated result with metadata
RETURN JSON_BUILD_OBJECT(
  'data',
  COALESCE(sessions_data, '[]' :: JSON),
  'pagination',
  JSON_BUILD_OBJECT(
    'page',
    p_page,
    'limit',
    p_limit,
    'total',
    total_count,
    'pages',
    CEIL(total_count :: FLOAT / p_limit)
  )
);

END;

$ $;

ALTER FUNCTION "public"."get_time_tracking_sessions_paginated"(
  "p_ws_id" "uuid",
  "p_period" "text",
  "p_page" integer,
  "p_limit" integer,
  "p_search" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_time_tracking_stats"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT NULL :: "uuid"
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE stats_data json;

user_filter text := '';

BEGIN -- Check if user has access to the workspace
IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
) THEN RAISE EXCEPTION 'Access denied: user is not a member of this workspace';

END IF;

-- If specific user requested, ensure it's either the current user or user has admin access
IF p_user_id IS NOT NULL
AND p_user_id != auth.uid() THEN IF NOT EXISTS (
  SELECT
    1
  FROM
    workspace_members wm
  WHERE
    wm.ws_id = p_ws_id
    AND wm.user_id = auth.uid()
    AND public.has_workspace_permission(p_ws_id, auth.uid(), 'manage_workspace_members')
) THEN RAISE EXCEPTION 'Access denied: insufficient permissions to view other users data';

END IF;

END IF;

-- Add user filter if specified
IF p_user_id IS NOT NULL THEN user_filter := FORMAT(' AND user_id = ''%s''', p_user_id);

END IF;

-- Calculate comprehensive stats
EXECUTE FORMAT(
  'WITH date_ranges AS (
            SELECT 
                CURRENT_DATE as today,
                DATE_TRUNC(''week'', CURRENT_DATE)::DATE as week_start,
                DATE_TRUNC(''month'', CURRENT_DATE)::DATE as month_start
        ),
        session_stats AS (
            SELECT 
                COUNT(*) as total_sessions,
                COUNT(CASE WHEN is_running THEN 1 END) as active_sessions,
                COUNT(DISTINCT user_id) as active_users,
                SUM(CASE WHEN date = dr.today THEN COALESCE(duration_seconds, 0) ELSE 0 END) as today_time,
                SUM(CASE WHEN date >= dr.week_start THEN COALESCE(duration_seconds, 0) ELSE 0 END) as week_time,
                SUM(CASE WHEN date >= dr.month_start THEN COALESCE(duration_seconds, 0) ELSE 0 END) as month_time,
                COUNT(CASE WHEN date = dr.today THEN 1 END) as today_sessions,
                COUNT(CASE WHEN date >= dr.week_start THEN 1 END) as week_sessions,
                COUNT(CASE WHEN date >= dr.month_start THEN 1 END) as month_sessions
            FROM time_tracking_sessions tts
            CROSS JOIN date_ranges dr
            WHERE tts.ws_id = ''%s''%s AND duration_seconds IS NOT NULL
        ),
        activity_streak AS (
            WITH daily_activity AS (
                SELECT date
                FROM time_tracking_sessions tts
                WHERE tts.ws_id = ''%s''%s AND duration_seconds IS NOT NULL
                GROUP BY date
                HAVING SUM(duration_seconds) > 0
                ORDER BY date DESC
            ),
            consecutive_days AS (
                SELECT date, 
                       ROW_NUMBER() OVER (ORDER BY date DESC) as rn,
                       date - (ROW_NUMBER() OVER (ORDER BY date DESC) * INTERVAL ''1 day'') as streak_group
                FROM daily_activity
                WHERE date <= CURRENT_DATE
            ),
            current_streak AS (
                SELECT COUNT(*) as days
                FROM consecutive_days
                WHERE streak_group = (
                    SELECT streak_group 
                    FROM consecutive_days 
                    WHERE date = CURRENT_DATE
                    LIMIT 1
                )
            )
            SELECT COALESCE(MAX(days), 0) as streak
            FROM current_streak
        )
        SELECT JSON_BUILD_OBJECT(
            ''total_sessions'', COALESCE(ss.total_sessions, 0),
            ''active_sessions'', COALESCE(ss.active_sessions, 0),
            ''active_users'', COALESCE(ss.active_users, 0),
            ''today_time'', COALESCE(ss.today_time, 0),
            ''week_time'', COALESCE(ss.week_time, 0),
            ''month_time'', COALESCE(ss.month_time, 0),
            ''today_sessions'', COALESCE(ss.today_sessions, 0),
            ''week_sessions'', COALESCE(ss.week_sessions, 0),
            ''month_sessions'', COALESCE(ss.month_sessions, 0),
            ''current_streak'', COALESCE(ast.streak, 0)
        ) as stats
        FROM session_stats ss
        CROSS JOIN activity_streak ast',
  p_ws_id,
  user_filter,
  p_ws_id,
  user_filter
) INTO stats_data;

RETURN COALESCE(stats_data, '{}' :: JSON);

END;

$ $;

ALTER FUNCTION "public"."get_time_tracking_stats"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_top_cities"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("city" "text", "country" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.city, 'Unknown') AS city,
  COALESCE(la.country, 'Unknown') AS country,
  COUNT(*) AS count
FROM
  link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  COALESCE(la.city, 'Unknown'),
  COALESCE(la.country, 'Unknown')
ORDER BY
  count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_top_cities"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_top_countries"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("country" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.country, 'Unknown') as country,
  COUNT(*) as click_count
FROM
  public.link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  la.country
ORDER BY
  click_count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_top_countries"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_top_referrers"("p_link_id" "uuid", "p_limit" integer DEFAULT 10) RETURNS TABLE("domain" "text", "count" bigint) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(la.referrer_domain, 'Direct') as domain,
  COUNT(*) as click_count
FROM
  public.link_analytics la
WHERE
  la.link_id = p_link_id
GROUP BY
  la.referrer_domain
ORDER BY
  click_count DESC
LIMIT
  p_limit;

END;

$ $;

ALTER FUNCTION "public"."get_top_referrers"("p_link_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_transaction_categories_with_amount_by_workspace"("p_ws_id" "uuid") RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "is_expense" boolean,
  "ws_id" "uuid",
  "created_at" timestamp with time zone,
  "amount" numeric,
  "transaction_count" bigint
) LANGUAGE "sql" STABLE AS $ $
SELECT
  tc.id,
  tc.name,
  tc.is_expense,
  tc.ws_id,
  tc.created_at,
  COALESCE(SUM(ABS(wt.amount)), 0) as amount,
  COUNT(wt.id) as transaction_count
FROM
  transaction_categories tc
  LEFT JOIN wallet_transactions wt ON wt.category_id = tc.id
  LEFT JOIN workspace_wallets ww ON wt.wallet_id = ww.id
  AND ww.ws_id = p_ws_id
WHERE
  tc.ws_id = p_ws_id
GROUP BY
  tc.id,
  tc.name,
  tc.is_expense,
  tc.ws_id,
  tc.created_at
ORDER BY
  tc.name ASC $ $;

ALTER FUNCTION "public"."get_transaction_categories_with_amount_by_workspace"("p_ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_transaction_count_by_tag"("_ws_id" "uuid") RETURNS TABLE(
  "tag_id" "uuid",
  "tag_name" "text",
  "tag_color" "text",
  "transaction_count" bigint
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  tt.id,
  tt.name,
  tt.color,
  COUNT(wtt.transaction_id) AS transaction_count
FROM
  transaction_tags tt
  LEFT JOIN wallet_transaction_tags wtt ON tt.id = wtt.tag_id
WHERE
  tt.ws_id = _ws_id
GROUP BY
  tt.id,
  tt.name,
  tt.color
ORDER BY
  transaction_count DESC,
  tt.name;

END;

$ $;

ALTER FUNCTION "public"."get_transaction_count_by_tag"("_ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_upcoming_recurring_transactions"("_ws_id" "uuid", "days_ahead" integer DEFAULT 30) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "amount" numeric,
  "frequency" "public"."recurring_frequency",
  "next_occurrence" "date",
  "wallet_name" "text",
  "category_name" "text"
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  rt.id,
  rt.name,
  rt.amount,
  rt.frequency,
  rt.next_occurrence,
  ww.name AS wallet_name,
  tc.name AS category_name
FROM
  recurring_transactions rt
  JOIN workspace_wallets ww ON rt.wallet_id = ww.id
  LEFT JOIN transaction_categories tc ON rt.category_id = tc.id
WHERE
  rt.ws_id = _ws_id
  AND rt.is_active = true
  AND rt.next_occurrence <= CURRENT_DATE + days_ahead
ORDER BY
  rt.next_occurrence ASC;

END;

$ $;

ALTER FUNCTION "public"."get_upcoming_recurring_transactions"("_ws_id" "uuid", "days_ahead" integer) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_user_accessible_tasks"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid" DEFAULT NULL :: "uuid",
  "p_include_deleted" boolean DEFAULT false,
  "p_list_statuses" "public"."task_board_status" [] DEFAULT ARRAY ['not_started'::"public"."task_board_status", 'active'::"public"."task_board_status"]
) RETURNS TABLE(
  "task_id" "uuid",
  "task_name" "text",
  "task_description" "text",
  "task_creator_id" "uuid",
  "task_list_id" "uuid",
  "task_start_date" timestamp with time zone,
  "task_end_date" timestamp with time zone,
  "task_priority" "public"."task_priority",
  "task_completed_at" timestamp with time zone,
  "task_closed_at" timestamp with time zone,
  "task_deleted_at" timestamp with time zone,
  "task_estimation_points" smallint,
  "task_created_at" timestamp with time zone
) LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE v_personal_ws_id UUID;

v_is_personal BOOLEAN;

BEGIN -- Get user's personal workspace if not specified
IF p_ws_id IS NULL THEN
SELECT
  w.id INTO v_personal_ws_id
FROM
  public.workspaces w
  INNER JOIN public.workspace_members wm ON wm.ws_id = w.id
WHERE
  w.personal = TRUE
  AND wm.user_id = p_user_id
LIMIT
  1;

ELSE v_personal_ws_id := p_ws_id;

END IF;

-- Check if the specified workspace is personal
SELECT
  w.personal INTO v_is_personal
FROM
  public.workspaces w
WHERE
  w.id = v_personal_ws_id;

-- If workspace is personal, return tasks assigned to user + tasks in personal workspace boards
IF v_is_personal THEN RETURN QUERY
SELECT
  DISTINCT t.id,
  t.name,
  t.description,
  t.creator_id,
  t.list_id,
  t.start_date,
  t.end_date,
  t.priority,
  t.completed_at,
  t.closed_at,
  t.deleted_at,
  t.estimation_points,
  t.created_at
FROM
  public.tasks t
  INNER JOIN public.task_lists tl ON tl.id = t.list_id
  INNER JOIN public.workspace_boards wb ON wb.id = tl.board_id
WHERE
  (
    -- Tasks assigned to the user (across all workspaces)
    EXISTS (
      SELECT
        1
      FROM
        public.task_assignees ta
      WHERE
        ta.task_id = t.id
        AND ta.user_id = p_user_id
    ) -- OR tasks in personal workspace boards
    OR wb.ws_id = v_personal_ws_id
  )
  AND (
    p_include_deleted
    OR t.deleted_at IS NULL
  )
  AND (
    p_list_statuses IS NULL
    OR tl.status = ANY(p_list_statuses)
  )
  AND wb.deleted_at IS NULL -- Filter out deleted boards
  AND wb.archived_at IS NULL;

-- Filter out archived boards
ELSE -- If workspace is not personal, only return tasks from that workspace assigned to user
RETURN QUERY
SELECT
  DISTINCT t.id,
  t.name,
  t.description,
  t.creator_id,
  t.list_id,
  t.start_date,
  t.end_date,
  t.priority,
  t.completed_at,
  t.closed_at,
  t.deleted_at,
  t.estimation_points,
  t.created_at
FROM
  public.tasks t
  INNER JOIN public.task_lists tl ON tl.id = t.list_id
  INNER JOIN public.workspace_boards wb ON wb.id = tl.board_id
  INNER JOIN public.task_assignees ta ON ta.task_id = t.id
WHERE
  ta.user_id = p_user_id
  AND wb.ws_id = v_personal_ws_id
  AND (
    p_include_deleted
    OR t.deleted_at IS NULL
  )
  AND (
    p_list_statuses IS NULL
    OR tl.status = ANY(p_list_statuses)
  )
  AND wb.deleted_at IS NULL -- Filter out deleted boards
  AND wb.archived_at IS NULL;

-- Filter out archived boards
END IF;

END;

$ $;

ALTER FUNCTION "public"."get_user_accessible_tasks"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_include_deleted" boolean,
  "p_list_statuses" "public"."task_board_status" []
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_user_accessible_tasks"(
  "p_user_id" "uuid",
  "p_ws_id" "uuid",
  "p_include_deleted" boolean,
  "p_list_statuses" "public"."task_board_status" []
) IS 'Returns all tasks accessible by a user. Filters out tasks from deleted/archived boards. For personal workspaces, includes tasks assigned to user across all workspaces plus tasks in personal workspace boards. For non-personal workspaces, only returns tasks from that workspace assigned to the user. Scheduling settings are stored per-user in task_user_scheduling_settings.';

CREATE
OR REPLACE FUNCTION "public"."get_user_activity_cohorts"() RETURNS TABLE(
  "cohort_name" "text",
  "user_count" bigint,
  "percentage" numeric
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH user_activity AS (
    SELECT
      u.id,
      u.created_at AS signup_date,
      MAX(s.updated_at) AS last_active
    FROM
      public.users u
      LEFT JOIN auth.sessions s ON u.id = s.user_id
    GROUP BY
      u.id,
      u.created_at
  ),
  cohorts AS (
    SELECT
      CASE
        WHEN signup_date >= CURRENT_DATE - INTERVAL '7 days' THEN 'New Users (< 7 days)'
        WHEN last_active >= CURRENT_DATE - INTERVAL '7 days' THEN 'Active (< 7 days)'
        WHEN last_active >= CURRENT_DATE - INTERVAL '30 days' THEN 'Casual (7-30 days)'
        WHEN last_active >= CURRENT_DATE - INTERVAL '90 days' THEN 'At Risk (30-90 days)'
        WHEN last_active IS NULL THEN 'Never Logged In'
        ELSE 'Churned (> 90 days)'
      END AS cohort_name,
      COUNT(*) AS user_count
    FROM
      user_activity
    GROUP BY
      1
  ),
  total AS (
    SELECT
      SUM(user_count) AS total_users
    FROM
      cohorts
  )
SELECT
  c.cohort_name,
  c.user_count,
  ROUND(
    (
      c.user_count :: numeric / t.total_users :: numeric * 100
    ),
    2
  ) AS percentage
FROM
  cohorts c,
  total t
ORDER BY
  c.user_count DESC;

$ $;

ALTER FUNCTION "public"."get_user_activity_cohorts"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_user_activity_cohorts"() IS 'Returns user lifecycle cohort distribution';

CREATE
OR REPLACE FUNCTION "public"."get_user_email"("p_user_id" "uuid") RETURNS "text" LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ BEGIN RETURN (
  SELECT
    email
  FROM
    auth.users
  WHERE
    id = p_user_id
);

END;

$ $;

ALTER FUNCTION "public"."get_user_email"("p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_user_email"("p_user_id" "uuid") IS 'Helper function to get user email from auth.users - used in RLS policies (SECURITY DEFINER to access auth schema)';

CREATE
OR REPLACE FUNCTION "public"."get_user_growth_comparison"() RETURNS TABLE(
  "total_users" bigint,
  "users_today" bigint,
  "users_this_week" bigint,
  "users_this_month" bigint,
  "growth_rate_weekly" numeric,
  "growth_rate_monthly" numeric
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH counts AS (
    SELECT
      COUNT(*) AS total_users,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE
      ) AS users_today,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '7 days'
      ) AS users_this_week,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '30 days'
      ) AS users_this_month,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '14 days'
          AND created_at < CURRENT_DATE - INTERVAL '7 days'
      ) AS users_prev_week,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '60 days'
          AND created_at < CURRENT_DATE - INTERVAL '30 days'
      ) AS users_prev_month
    FROM
      public.users
  )
SELECT
  total_users,
  users_today,
  users_this_week,
  users_this_month,
  CASE
    WHEN users_prev_week > 0 THEN ROUND(
      (
        (
          users_this_week :: numeric - users_prev_week :: numeric
        ) / users_prev_week :: numeric * 100
      ),
      2
    )
    ELSE NULL
  END AS growth_rate_weekly,
  CASE
    WHEN users_prev_month > 0 THEN ROUND(
      (
        (
          users_this_month :: numeric - users_prev_month :: numeric
        ) / users_prev_month :: numeric * 100
      ),
      2
    )
    ELSE NULL
  END AS growth_rate_monthly
FROM
  counts;

$ $;

ALTER FUNCTION "public"."get_user_growth_comparison"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_user_growth_stats"("time_period" "text" DEFAULT 'daily' :: "text") RETURNS TABLE(
  "period" "text",
  "new_users" bigint,
  "cumulative_users" bigint
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ BEGIN RETURN QUERY WITH user_registrations AS (
    SELECT
      created_at,
      ROW_NUMBER() OVER (
        ORDER BY
          created_at
      ) AS cumulative_count
    FROM
      public.users
    WHERE
      created_at IS NOT NULL
  )
SELECT
  CASE
    WHEN time_period = 'daily' THEN TO_CHAR(DATE(created_at), 'YYYY-MM-DD')
    WHEN time_period = 'weekly' THEN TO_CHAR(DATE_TRUNC('week', created_at), 'YYYY-MM-DD')
    WHEN time_period = 'monthly' THEN TO_CHAR(DATE_TRUNC('month', created_at), 'YYYY-MM-DD')
    ELSE TO_CHAR(DATE(created_at), 'YYYY-MM-DD')
  END AS period,
  COUNT(*) :: bigint AS new_users,
  MAX(cumulative_count) :: bigint AS cumulative_users
FROM
  user_registrations
GROUP BY
  1
ORDER BY
  period;

END;

$ $;

ALTER FUNCTION "public"."get_user_growth_stats"("time_period" "text") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_user_growth_stats"("time_period" "text") IS 'Returns user growth statistics by time period';

CREATE
OR REPLACE FUNCTION "public"."get_user_session_stats"("user_id" "uuid") RETURNS TABLE(
  "total_sessions" integer,
  "active_sessions" integer,
  "current_session_age" interval
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE current_session_id text;

BEGIN -- Check if user is requesting their own stats
IF auth.uid() != user_id THEN RAISE EXCEPTION 'Unauthorized access to session stats';

END IF;

current_session_id := auth.jwt() ->> 'session_id';

RETURN QUERY
SELECT
  COUNT(*) :: integer as total_sessions,
  COUNT(
    CASE
      WHEN s.updated_at > NOW() - INTERVAL '1 hour' THEN 1
    END
  ) :: integer as active_sessions,
  CASE
    WHEN current_session_id IS NOT NULL
    AND current_session_id != '' THEN NOW() - (
      SELECT
        created_at
      FROM
        auth.sessions
      WHERE
        id :: text = current_session_id
    )
    ELSE INTERVAL '0'
  END as current_session_age
FROM
  auth.sessions s
WHERE
  s.user_id = get_user_session_stats.user_id
  AND s.updated_at > NOW() - INTERVAL '30 days';

END;

$ $;

ALTER FUNCTION "public"."get_user_session_stats"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_user_sessions"("user_id" "uuid") RETURNS TABLE(
  "session_id" "text",
  "created_at" timestamp with time zone,
  "updated_at" timestamp with time zone,
  "user_agent" "text",
  "ip" "text",
  "is_current" boolean
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Check if user is requesting their own sessions
IF auth.uid() != user_id THEN RAISE EXCEPTION 'Unauthorized access to sessions';

END IF;

-- Return session information from auth.sessions
-- Note: This is a simplified version as Supabase's auth.sessions schema may vary
RETURN QUERY
SELECT
  s.id :: text as session_id,
  s.created_at,
  s.updated_at,
  COALESCE(s.user_agent, 'Unknown') as user_agent,
  COALESCE(s.ip :: text, 'Unknown') as ip,
  (
    s.id :: text = COALESCE(auth.jwt() ->> 'session_id', '')
  ) :: boolean as is_current
FROM
  auth.sessions s
WHERE
  s.user_id = get_user_sessions.user_id
ORDER BY
  s.updated_at DESC;

END;

$ $;

ALTER FUNCTION "public"."get_user_sessions"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_user_tasks"("_board_id" "uuid") RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "description" "text",
  "priority" smallint,
  "completed" boolean,
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "list_id" "uuid",
  "board_id" "uuid"
) LANGUAGE "plpgsql" AS $ $ begin return query
select
  t.id,
  t.name,
  t.description,
  t.priority,
  t.completed,
  t.start_date,
  t.end_date,
  t.list_id,
  l.board_id
from
  tasks t,
  task_lists l,
  task_assignees a
where
  auth.uid() = a.user_id
  and l.board_id = _board_id
  and t.list_id = l.id
  and t.id = a.task_id
  and t.completed = false
order by
  t.priority DESC,
  t.end_date ASC NULLS LAST;

end;

$ $;

ALTER FUNCTION "public"."get_user_tasks"("_board_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_user_whitelist_status"("user_id_param" "uuid") RETURNS TABLE(
  "is_whitelisted" boolean,
  "enabled" boolean,
  "allow_challenge_management" boolean,
  "allow_manage_all_challenges" boolean,
  "allow_role_management" boolean
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN QUERY
SELECT
  COALESCE(pur.enabled, false) as is_whitelisted,
  COALESCE(pur.enabled, false) as enabled,
  COALESCE(pur.allow_challenge_management, false) as allow_challenge_management,
  COALESCE(pur.allow_manage_all_challenges, false) as allow_manage_all_challenges,
  COALESCE(pur.allow_role_management, false) as allow_role_management
FROM
  public.platform_user_roles pur
WHERE
  pur.user_id = user_id_param;

-- If no record exists, return false for all
IF NOT FOUND THEN RETURN QUERY
SELECT
  false,
  false,
  false,
  false,
  false;

END IF;

END;

$ $;

ALTER FUNCTION "public"."get_user_whitelist_status"("user_id_param" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_wallet_expense_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"()
) RETURNS bigint LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result bigint;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Count expense transactions
-- Only include transactions that are:
-- 1. Negative amount (expense)
-- 2. Either non-confidential OR user has permission to view confidential amounts
SELECT
  COUNT(*) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount < 0
  AND (
    NOT wt.is_amount_confidential
    OR can_view_amount
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_expense_count"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_expense_count"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns the count of expense transactions (amount < 0) for a workspace, respecting confidential amount permissions. Excludes confidential transactions if user lacks view_confidential_amount permission.';

CREATE
OR REPLACE FUNCTION "public"."get_wallet_expense_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"(),
  "p_include_confidential" boolean DEFAULT true
) RETURNS bigint LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result bigint;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Count expense transactions
SELECT
  COUNT(*) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount < 0
  AND (
    (
      NOT p_include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR (
      p_include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_expense_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_include_confidential" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_wallet_expense_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"()
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Calculate sum of expense transactions
-- Only include amounts that are:
-- 1. Negative (expense)
-- 2. Either non-confidential OR user has permission to view confidential amounts
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount < 0
  AND (
    NOT wt.is_amount_confidential
    OR can_view_amount
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_expense_sum"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_expense_sum"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns the sum of all expense transactions (amount < 0) for a workspace, respecting confidential amount permissions. Excludes confidential amounts if user lacks view_confidential_amount permission.';

CREATE
OR REPLACE FUNCTION "public"."get_wallet_expense_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"(),
  "p_include_confidential" boolean DEFAULT true
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Calculate sum of expense transactions
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount < 0
  AND (
    (
      NOT p_include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR (
      p_include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_expense_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_include_confidential" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_wallet_income_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"()
) RETURNS bigint LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result bigint;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Count income transactions
-- Only include transactions that are:
-- 1. Positive amount (income)
-- 2. Either non-confidential OR user has permission to view confidential amounts
SELECT
  COUNT(*) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount > 0
  AND (
    NOT wt.is_amount_confidential
    OR can_view_amount
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_income_count"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_income_count"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns the count of income transactions (amount > 0) for a workspace, respecting confidential amount permissions. Excludes confidential transactions if user lacks view_confidential_amount permission.';

CREATE
OR REPLACE FUNCTION "public"."get_wallet_income_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"(),
  "p_include_confidential" boolean DEFAULT true
) RETURNS bigint LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result bigint;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Count income transactions
SELECT
  COUNT(*) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount > 0
  AND (
    (
      NOT p_include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR (
      p_include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_income_count"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_include_confidential" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_wallet_income_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"()
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Calculate sum of income transactions
-- Only include amounts that are:
-- 1. Positive (income)
-- 2. Either non-confidential OR user has permission to view confidential amounts
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount > 0
  AND (
    NOT wt.is_amount_confidential
    OR can_view_amount
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_income_sum"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_income_sum"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns the sum of all income transactions (amount > 0) for a workspace, respecting confidential amount permissions. Excludes confidential amounts if user lacks view_confidential_amount permission.';

CREATE
OR REPLACE FUNCTION "public"."get_wallet_income_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"(),
  "p_include_confidential" boolean DEFAULT true
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

-- Calculate sum of income transactions
-- If include_confidential = false, exclude ALL confidential transactions
-- If include_confidential = true, respect permissions (existing behavior)
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND wt.amount > 0
  AND (
    -- If excluding confidential, only include non-confidential
    (
      NOT p_include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR -- If including confidential, respect permissions
    (
      p_include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  );

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_wallet_income_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_include_confidential" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_income_sum"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_include_confidential" boolean
) IS 'Returns the sum of income transactions. Set include_confidential=false to exclude confidential transactions even if user has permission.';

CREATE
OR REPLACE FUNCTION "public"."get_wallet_transactions_with_permissions"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid" DEFAULT "auth"."uid"(),
  "p_transaction_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "p_wallet_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "p_category_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "p_creator_ids" "uuid" [] DEFAULT NULL :: "uuid" [],
  "p_search_query" "text" DEFAULT NULL :: "text",
  "p_start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_order_by" "text" DEFAULT 'taken_at' :: "text",
  "p_order_direction" "text" DEFAULT 'DESC' :: "text",
  "p_limit" integer DEFAULT NULL :: integer,
  "p_offset" integer DEFAULT 0,
  "p_cursor_taken_at" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_cursor_created_at" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_include_count" boolean DEFAULT false
) RETURNS TABLE(
  "id" "uuid",
  "amount" numeric,
  "category_id" "uuid",
  "created_at" timestamp with time zone,
  "creator_id" "uuid",
  "description" "text",
  "invoice_id" "uuid",
  "report_opt_in" boolean,
  "taken_at" timestamp with time zone,
  "wallet_id" "uuid",
  "is_amount_confidential" boolean,
  "is_description_confidential" boolean,
  "is_category_confidential" boolean,
  "total_count" bigint
) LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ _ $ DECLARE can_view_amount boolean;

can_view_description boolean;

can_view_category boolean;

v_total_count bigint := NULL;

v_order_clause text;

BEGIN -- Check user's permissions for viewing confidential fields
can_view_amount := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_amount');

can_view_description := public.has_workspace_permission(
  p_ws_id,
  p_user_id,
  'view_confidential_description'
);

can_view_category := public.has_workspace_permission(p_ws_id, p_user_id, 'view_confidential_category');

-- Validate order_by parameter
IF p_order_by NOT IN ('taken_at', 'created_at', 'amount') THEN p_order_by := 'taken_at';

END IF;

-- Validate order_direction parameter
IF p_order_direction NOT IN ('ASC', 'DESC') THEN p_order_direction := 'DESC';

END IF;

-- Build ORDER BY clause
-- For taken_at, add created_at as secondary sort for deterministic ordering
IF p_order_by = 'taken_at' THEN v_order_clause := format(
  'wt.taken_at %s, wt.created_at %s',
  p_order_direction,
  p_order_direction
);

ELSIF p_order_by = 'created_at' THEN v_order_clause := format('wt.created_at %s', p_order_direction);

ELSIF p_order_by = 'amount' THEN v_order_clause := format(
  'wt.amount %s, wt.taken_at %s',
  p_order_direction,
  p_order_direction
);

END IF;

-- Get total count if requested (before pagination)
IF p_include_count THEN
SELECT
  COUNT(*) INTO v_total_count
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = p_ws_id
  AND (
    p_transaction_ids IS NULL
    OR wt.id = ANY(p_transaction_ids)
  )
  AND (
    p_wallet_ids IS NULL
    OR wt.wallet_id = ANY(p_wallet_ids)
  )
  AND (
    p_category_ids IS NULL
    OR wt.category_id = ANY(p_category_ids)
  )
  AND (
    p_creator_ids IS NULL
    OR wt.creator_id = ANY(p_creator_ids)
  )
  AND (
    p_start_date IS NULL
    OR wt.taken_at >= p_start_date
  )
  AND (
    p_end_date IS NULL
    OR wt.taken_at <= p_end_date
  )
  AND (
    p_search_query IS NULL
    OR wt.description ILIKE '%' || p_search_query || '%'
  ) -- Cursor-based pagination filter (for "has more" check)
  AND (
    p_cursor_taken_at IS NULL
    OR p_cursor_created_at IS NULL
    OR (
      wt.taken_at < p_cursor_taken_at
      OR (
        wt.taken_at = p_cursor_taken_at
        AND wt.created_at < p_cursor_created_at
      )
    )
  );

END IF;

-- Return query with all filters and pagination
RETURN QUERY EXECUTE format(
  '
    SELECT
      wt.id,
      -- Redact amount if confidential and user lacks permission
      CASE 
        WHEN wt.is_amount_confidential AND NOT $1 THEN NULL
        ELSE wt.amount
      END AS amount,
      -- Redact category if confidential and user lacks permission
      CASE 
        WHEN wt.is_category_confidential AND NOT $2 THEN NULL
        ELSE wt.category_id
      END AS category_id,
      wt.created_at,
      wt.creator_id,
      -- Redact description if confidential and user lacks permission
      CASE 
        WHEN wt.is_description_confidential AND NOT $3 THEN ''[CONFIDENTIAL]''
        ELSE wt.description
      END AS description,
      wt.invoice_id,
      wt.report_opt_in,
      wt.taken_at,
      wt.wallet_id,
      -- Always include confidentiality flags so UI knows to show redaction indicators
      wt.is_amount_confidential,
      wt.is_description_confidential,
      wt.is_category_confidential,
      $4::bigint AS total_count
    FROM public.wallet_transactions wt
    JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
    WHERE ww.ws_id = $5
      AND ($6::uuid[] IS NULL OR wt.id = ANY($6))
      AND ($7::uuid[] IS NULL OR wt.wallet_id = ANY($7))
      AND ($8::uuid[] IS NULL OR wt.category_id = ANY($8))
      AND ($9::uuid[] IS NULL OR wt.creator_id = ANY($9))
      AND ($10::timestamp with time zone IS NULL OR wt.taken_at >= $10)
      AND ($11::timestamp with time zone IS NULL OR wt.taken_at <= $11)
      AND (
        $12::text IS NULL 
        OR wt.description ILIKE ''%%'' || $12 || ''%%''
      )
      -- Cursor-based pagination filter
      AND (
        $13::timestamp with time zone IS NULL 
        OR $14::timestamp with time zone IS NULL
        OR (
          wt.taken_at < $13
          OR (wt.taken_at = $13 AND wt.created_at < $14)
        )
      )
    ORDER BY %s
    LIMIT $15
    OFFSET $16
  ',
  v_order_clause
) USING can_view_amount,
-- $1
can_view_category,
-- $2
can_view_description,
-- $3
v_total_count,
-- $4
p_ws_id,
-- $5
p_transaction_ids,
-- $6
p_wallet_ids,
-- $7
p_category_ids,
-- $8
p_creator_ids,
-- $9
p_start_date,
-- $10
p_end_date,
-- $11
p_search_query,
-- $12
p_cursor_taken_at,
-- $13
p_cursor_created_at,
-- $14
p_limit,
-- $15
p_offset;

-- $16
END;

$ _ $;

ALTER FUNCTION "public"."get_wallet_transactions_with_permissions"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_transaction_ids" "uuid" [],
  "p_wallet_ids" "uuid" [],
  "p_category_ids" "uuid" [],
  "p_creator_ids" "uuid" [],
  "p_search_query" "text",
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_order_by" "text",
  "p_order_direction" "text",
  "p_limit" integer,
  "p_offset" integer,
  "p_cursor_taken_at" timestamp with time zone,
  "p_cursor_created_at" timestamp with time zone,
  "p_include_count" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wallet_transactions_with_permissions"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_transaction_ids" "uuid" [],
  "p_wallet_ids" "uuid" [],
  "p_category_ids" "uuid" [],
  "p_creator_ids" "uuid" [],
  "p_search_query" "text",
  "p_start_date" timestamp with time zone,
  "p_end_date" timestamp with time zone,
  "p_order_by" "text",
  "p_order_direction" "text",
  "p_limit" integer,
  "p_offset" integer,
  "p_cursor_taken_at" timestamp with time zone,
  "p_cursor_created_at" timestamp with time zone,
  "p_include_count" boolean
) IS 'Optimized function that returns wallet transactions with confidential fields redacted based on user permissions. Supports comprehensive filtering, sorting (taken_at/created_at/amount), and both offset-based and cursor-based pagination. Set p_include_count=TRUE to get total count (may impact performance).';

CREATE
OR REPLACE FUNCTION "public"."get_wau_count"() RETURNS bigint LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
SELECT
  COUNT(DISTINCT user_id)
FROM
  auth.sessions
WHERE
  updated_at >= CURRENT_DATE - INTERVAL '7 days';

$ $;

ALTER FUNCTION "public"."get_wau_count"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_wau_count"() IS 'Returns Weekly Active Users count';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_drive_size"("ws_id" "uuid") RETURNS bigint LANGUAGE "plpgsql" AS $ $ DECLARE total_size BIGINT;

BEGIN -- REMOVED: AND owner IS NOT NULL filter
SELECT
  COALESCE(SUM(COALESCE((metadata ->> 'size') :: BIGINT, 0)), 0) INTO total_size
FROM
  storage.objects
WHERE
  bucket_id = 'workspaces'
  AND split_part(name, '/', 1) :: uuid = ws_id;

RETURN total_size;

END;

$ $;

ALTER FUNCTION "public"."get_workspace_drive_size"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_member_count"("p_ws_id" "uuid") RETURNS integer LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
select
  coalesce(
    (
      select
        count(*) :: int
      from
        public.workspace_members wm
      where
        wm.ws_id = p_ws_id
    ),
    0
  );

$ $;

ALTER FUNCTION "public"."get_workspace_member_count"("p_ws_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_member_count"("p_ws_id" "uuid") IS 'Returns the number of rows in workspace_members for the given workspace id.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_member_distribution"() RETURNS TABLE(
  "member_range" "text",
  "workspace_count" bigint,
  "percentage" numeric
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH member_counts AS (
    SELECT
      w.id,
      COUNT(DISTINCT wm.user_id) AS member_count
    FROM
      public.workspaces w
      LEFT JOIN public.workspace_members wm ON w.id = wm.ws_id
    WHERE
      w.deleted = false
    GROUP BY
      w.id
  ),
  grouped_counts AS (
    SELECT
      CASE
        WHEN member_count = 0 THEN '0 members'
        WHEN member_count = 1 THEN '1 member'
        WHEN member_count BETWEEN 2
        AND 5 THEN '2-5 members'
        WHEN member_count BETWEEN 6
        AND 10 THEN '6-10 members'
        WHEN member_count BETWEEN 11
        AND 25 THEN '11-25 members'
        WHEN member_count BETWEEN 26
        AND 50 THEN '26-50 members'
        ELSE '50+ members'
      END AS member_range,
      COUNT(*) AS workspace_count
    FROM
      member_counts
    GROUP BY
      1
  ),
  total AS (
    SELECT
      SUM(workspace_count) as total_workspaces
    FROM
      grouped_counts
  )
SELECT
  gc.member_range,
  gc.workspace_count,
  ROUND(
    (
      gc.workspace_count :: numeric / t.total_workspaces :: numeric * 100
    ),
    2
  ) AS percentage
FROM
  grouped_counts gc,
  total t
ORDER BY
  CASE
    WHEN gc.member_range = '0 members' THEN 0
    WHEN gc.member_range = '1 member' THEN 1
    WHEN gc.member_range = '2-5 members' THEN 2
    WHEN gc.member_range = '6-10 members' THEN 3
    WHEN gc.member_range = '11-25 members' THEN 4
    WHEN gc.member_range = '26-50 members' THEN 5
    ELSE 6
  END;

$ $;

ALTER FUNCTION "public"."get_workspace_member_distribution"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_products_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspace_products
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_workspace_products_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_statistics"() RETURNS TABLE(
  "total_workspaces" bigint,
  "active_workspaces" bigint,
  "avg_members_per_workspace" numeric,
  "median_members_per_workspace" numeric,
  "empty_workspace_count" bigint,
  "workspaces_created_today" bigint,
  "workspaces_created_this_week" bigint,
  "workspaces_created_this_month" bigint
) LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ WITH active_workspaces_with_members AS (
    SELECT
      w.id,
      COUNT(DISTINCT wm.user_id) as member_count
    FROM
      public.workspaces w
      LEFT JOIN public.workspace_members wm ON w.id = wm.ws_id
    WHERE
      w.deleted = false
    GROUP BY
      w.id
  ),
  workspace_creation_stats AS (
    SELECT
      COUNT(*) AS total_workspaces,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE
      ) AS workspaces_created_today,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '7 days'
      ) AS workspaces_created_this_week,
      COUNT(*) FILTER (
        WHERE
          created_at >= CURRENT_DATE - INTERVAL '30 days'
      ) AS workspaces_created_this_month
    FROM
      public.workspaces
  )
SELECT
  wcs.total_workspaces,
  (
    SELECT
      COUNT(*)
    FROM
      active_workspaces_with_members
  ) AS active_workspaces,
  ROUND(AVG(awm.member_count), 2) AS avg_members_per_workspace,
  PERCENTILE_CONT(0.5) WITHIN GROUP (
    ORDER BY
      awm.member_count
  ) AS median_members_per_workspace,
  COUNT(*) FILTER (
    WHERE
      awm.member_count = 0
  ) AS empty_workspace_count,
  wcs.workspaces_created_today,
  wcs.workspaces_created_this_week,
  wcs.workspaces_created_this_month
FROM
  active_workspaces_with_members awm,
  workspace_creation_stats wcs
GROUP BY
  wcs.total_workspaces,
  wcs.workspaces_created_today,
  wcs.workspaces_created_this_week,
  wcs.workspaces_created_this_month;

$ $;

ALTER FUNCTION "public"."get_workspace_statistics"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_statistics"() IS 'Returns comprehensive workspace statistics, including median member count and empty workspace count.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_storage_limit"("ws_id" "uuid") RETURNS bigint LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE limit_value TEXT;

storage_limit BIGINT;

BEGIN -- Try to get storage_limit from workspace_secrets
SELECT
  value INTO limit_value
FROM
  public.workspace_secrets
WHERE
  workspace_secrets.ws_id = get_workspace_storage_limit.ws_id
  AND name = 'STORAGE_LIMIT_BYTES'
LIMIT
  1;

-- If found, parse as BIGINT, otherwise use 100MB default
IF limit_value IS NOT NULL THEN BEGIN storage_limit := limit_value :: BIGINT;

EXCEPTION
WHEN OTHERS THEN -- If parsing fails, use default
storage_limit := 104857600;

-- 100MB
END;

ELSE storage_limit := 104857600;

-- 100MB default
END IF;

RETURN storage_limit;

END;

$ $;

ALTER FUNCTION "public"."get_workspace_storage_limit"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_task_history"(
  "p_ws_id" "uuid",
  "p_page" integer DEFAULT 1,
  "p_page_size" integer DEFAULT 20,
  "p_change_type" "text" DEFAULT NULL :: "text",
  "p_field_name" "text" DEFAULT NULL :: "text",
  "p_board_id" "uuid" DEFAULT NULL :: "uuid",
  "p_search" "text" DEFAULT NULL :: "text",
  "p_from" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "p_to" timestamp with time zone DEFAULT NULL :: timestamp with time zone
) RETURNS TABLE(
  "id" "uuid",
  "task_id" "uuid",
  "task_name" "text",
  "task_deleted_at" timestamp with time zone,
  "task_permanently_deleted" boolean,
  "board_id" "uuid",
  "board_name" "text",
  "changed_by" "uuid",
  "changed_at" timestamp with time zone,
  "change_type" "text",
  "field_name" "text",
  "old_value" "jsonb",
  "new_value" "jsonb",
  "metadata" "jsonb",
  "user_id" "uuid",
  "user_display_name" "text",
  "user_avatar_url" "text",
  "total_count" bigint
) LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ _ $ DECLARE v_offset INT;

v_has_access BOOLEAN;

BEGIN -- Calculate offset
v_offset := (p_page - 1) * p_page_size;

-- Check if user has access to the workspace
SELECT
  EXISTS (
    SELECT
      1
    FROM
      public.workspace_members wm
    WHERE
      wm.ws_id = p_ws_id
      AND wm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspace_role_members wrm
      JOIN public.workspace_roles wr ON wrm.role_id = wr.id
    WHERE
      wr.ws_id = p_ws_id
      AND wrm.user_id = auth.uid()
    UNION
    ALL
    SELECT
      1
    FROM
      public.workspaces w
    WHERE
      w.id = p_ws_id
      AND w.creator_id = auth.uid()
  ) INTO v_has_access;

IF NOT v_has_access THEN RAISE EXCEPTION 'Access denied to workspace';

END IF;

RETURN QUERY WITH filtered_history AS (
  -- Start from task_history and LEFT JOIN to tasks
  -- This allows us to include history for permanently deleted tasks
  SELECT
    th.id,
    th.task_id,
    -- Task name: from tasks table if exists, otherwise from metadata, otherwise 'Deleted Task'
    COALESCE(
      t.name,
      th.metadata ->> 'task_name',
      CASE
        WHEN th.change_type = 'task_created' THEN th.new_value #>> '{}'
        ELSE 'Deleted Task'
      END
    ) :: TEXT AS task_name,
    -- Task deleted_at: from tasks table if exists
    t.deleted_at AS task_deleted_at,
    -- Is the task permanently deleted? (not in tasks table)
    (t.id IS NULL) AS task_permanently_deleted,
    -- Board ID: from task's list if exists, otherwise from metadata
    COALESCE(wb.id, (th.metadata ->> 'board_id') :: UUID) AS board_id,
    -- Board name: from workspace_boards if exists, otherwise from metadata
    COALESCE(
      wb.name,
      th.metadata ->> 'board_name',
      'Deleted Board'
    ) :: TEXT AS board_name,
    th.changed_by,
    th.changed_at,
    th.change_type,
    th.field_name,
    th.old_value,
    th.new_value,
    th.metadata,
    COUNT(*) OVER() AS total_count
  FROM
    public.task_history th -- LEFT JOIN to tasks - allows NULL when task is permanently deleted
    LEFT JOIN public.tasks t ON th.task_id = t.id -- LEFT JOIN through task_lists to workspace_boards
    LEFT JOIN public.task_lists tl ON t.list_id = tl.id
    LEFT JOIN public.workspace_boards wb ON tl.board_id = wb.id
  WHERE
    th.deleted_at IS NULL -- Filter by workspace: either through the board, or through metadata for deleted tasks
    -- FIX: metadata stores 'workspace_id', not 'ws_id'
    AND (
      wb.ws_id = p_ws_id
      OR (
        t.id IS NULL
        AND (th.metadata ->> 'workspace_id') :: UUID = p_ws_id
      )
    ) -- Filter by board if specified
    AND (
      p_board_id IS NULL
      OR wb.id = p_board_id
      OR (
        t.id IS NULL
        AND (th.metadata ->> 'board_id') :: UUID = p_board_id
      )
    ) -- Filter by change type
    AND (
      p_change_type IS NULL
      OR th.change_type = p_change_type
    ) -- Filter by field name
    AND (
      p_field_name IS NULL
      OR th.field_name = p_field_name
    ) -- Filter by date range
    AND (
      p_from IS NULL
      OR th.changed_at >= p_from
    )
    AND (
      p_to IS NULL
      OR th.changed_at <= p_to
    ) -- Search filter: search in task name from tasks table or metadata
    AND (
      p_search IS NULL
      OR t.name ILIKE '%' || p_search || '%'
      OR th.metadata ->> 'task_name' ILIKE '%' || p_search || '%'
      OR (
        th.change_type = 'task_created'
        AND th.new_value #>> '{}' ILIKE '%' || p_search || '%')
      )
      ORDER BY
        th.changed_at DESC,
        th.id DESC
      LIMIT
        p_page_size OFFSET v_offset
    ),
    enriched_history AS (
      SELECT
        fh.id,
        fh.task_id,
        fh.task_name,
        fh.task_deleted_at,
        fh.task_permanently_deleted,
        fh.board_id,
        fh.board_name,
        fh.changed_by,
        fh.changed_at,
        fh.change_type,
        fh.field_name,
        -- Enrich old_value
        CASE
          -- Project unlinked enrichment
          WHEN fh.change_type = 'project_unlinked'
          AND fh.old_value IS NOT NULL
          AND (
            fh.old_value ->> 'project_name' IS NULL
            OR fh.old_value ->> 'project_name' = ''
          ) THEN CASE
            WHEN fh.old_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
              fh.old_value,
              '{project_name}',
              COALESCE(
                to_jsonb(
                  (
                    SELECT
                      tp.name
                    FROM
                      public.task_projects tp
                    WHERE
                      tp.id = (fh.old_value ->> 'project_id') :: uuid
                  )
                ),
                '"Unknown project"' :: jsonb
              )
            )
            WHEN fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
            jsonb_build_object(
              'project_id',
              fh.old_value #>> '{}', 'project_name',
              COALESCE(
                (
                  SELECT
                    tp.name
                  FROM
                    public.task_projects tp
                  WHERE
                    tp.id = (
                      fh.old_value #>> '{}')::uuid), 'Unknown project'))
                      ELSE fh.old_value
                    END -- Label removed enrichment
                    WHEN fh.change_type = 'label_removed'
                    AND fh.old_value IS NOT NULL
                    AND (
                      fh.old_value ->> 'name' IS NULL
                      OR fh.old_value ->> 'name' = ''
                    ) THEN CASE
                      WHEN fh.old_value ->> 'id' IS NOT NULL THEN COALESCE(
                        (
                          SELECT
                            jsonb_build_object(
                              'id',
                              wtl.id,
                              'name',
                              wtl.name,
                              'color',
                              wtl.color
                            )
                          FROM
                            public.workspace_task_labels wtl
                          WHERE
                            wtl.id = (fh.old_value ->> 'id') :: uuid
                        ),
                        fh.old_value
                      )
                      WHEN fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                      COALESCE(
                        (
                          SELECT
                            jsonb_build_object(
                              'id',
                              wtl.id,
                              'name',
                              wtl.name,
                              'color',
                              wtl.color
                            )
                          FROM
                            public.workspace_task_labels wtl
                          WHERE
                            wtl.id = (
                              fh.old_value #>> '{}')::uuid),
                              jsonb_build_object(
                                'id',
                                fh.old_value #>> '{}', 'name', 'Unknown label'))
                                ELSE fh.old_value
                              END
                              ELSE fh.old_value
                            END AS old_value,
                            -- Enrich new_value
                            CASE
                              -- Project linked enrichment
                              WHEN fh.change_type = 'project_linked'
                              AND fh.new_value IS NOT NULL
                              AND (
                                fh.new_value ->> 'project_name' IS NULL
                                OR fh.new_value ->> 'project_name' = ''
                              ) THEN CASE
                                WHEN fh.new_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                                  fh.new_value,
                                  '{project_name}',
                                  COALESCE(
                                    to_jsonb(
                                      (
                                        SELECT
                                          tp.name
                                        FROM
                                          public.task_projects tp
                                        WHERE
                                          tp.id = (fh.new_value ->> 'project_id') :: uuid
                                      )
                                    ),
                                    '"Unknown project"' :: jsonb
                                  )
                                )
                                WHEN fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                jsonb_build_object(
                                  'project_id',
                                  fh.new_value #>> '{}', 'project_name',
                                  COALESCE(
                                    (
                                      SELECT
                                        tp.name
                                      FROM
                                        public.task_projects tp
                                      WHERE
                                        tp.id = (
                                          fh.new_value #>> '{}')::uuid), 'Unknown project'))
                                          ELSE fh.new_value
                                        END -- Label added enrichment
                                        WHEN fh.change_type = 'label_added'
                                        AND fh.new_value IS NOT NULL
                                        AND (
                                          fh.new_value ->> 'name' IS NULL
                                          OR fh.new_value ->> 'name' = ''
                                        ) THEN CASE
                                          WHEN fh.new_value ->> 'id' IS NOT NULL THEN COALESCE(
                                            (
                                              SELECT
                                                jsonb_build_object(
                                                  'id',
                                                  wtl.id,
                                                  'name',
                                                  wtl.name,
                                                  'color',
                                                  wtl.color
                                                )
                                              FROM
                                                public.workspace_task_labels wtl
                                              WHERE
                                                wtl.id = (fh.new_value ->> 'id') :: uuid
                                            ),
                                            fh.new_value
                                          )
                                          WHEN fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                          COALESCE(
                                            (
                                              SELECT
                                                jsonb_build_object(
                                                  'id',
                                                  wtl.id,
                                                  'name',
                                                  wtl.name,
                                                  'color',
                                                  wtl.color
                                                )
                                              FROM
                                                public.workspace_task_labels wtl
                                              WHERE
                                                wtl.id = (
                                                  fh.new_value #>> '{}')::uuid),
                                                  jsonb_build_object(
                                                    'id',
                                                    fh.new_value #>> '{}', 'name', 'Unknown label'))
                                                    ELSE fh.new_value
                                                  END
                                                  ELSE fh.new_value
                                                END AS new_value,
                                                -- Enrich metadata
                                                CASE
                                                  -- Project metadata enrichment
                                                  WHEN fh.change_type IN ('project_linked', 'project_unlinked')
                                                  AND (
                                                    fh.metadata ->> 'project_name' IS NULL
                                                    OR fh.metadata ->> 'project_name' = ''
                                                  ) THEN CASE
                                                    WHEN fh.change_type = 'project_linked'
                                                    AND fh.new_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                                                      COALESCE(fh.metadata, '{}' :: jsonb),
                                                      '{project_name}',
                                                      COALESCE(
                                                        to_jsonb(
                                                          (
                                                            SELECT
                                                              tp.name
                                                            FROM
                                                              public.task_projects tp
                                                            WHERE
                                                              tp.id = (fh.new_value ->> 'project_id') :: uuid
                                                          )
                                                        ),
                                                        '"Unknown project"' :: jsonb
                                                      )
                                                    )
                                                    WHEN fh.change_type = 'project_linked'
                                                    AND fh.new_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                                    jsonb_set(
                                                      COALESCE(fh.metadata, '{}' :: jsonb),
                                                      '{project_name}',
                                                      COALESCE(
                                                        to_jsonb(
                                                          (
                                                            SELECT
                                                              tp.name
                                                            FROM
                                                              public.task_projects tp
                                                            WHERE
                                                              tp.id = (
                                                                fh.new_value #>> '{}')::uuid)), '"Unknown project"'::jsonb))
                                                                WHEN fh.change_type = 'project_unlinked'
                                                                AND fh.old_value ->> 'project_id' IS NOT NULL THEN jsonb_set(
                                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                                  '{project_name}',
                                                                  COALESCE(
                                                                    to_jsonb(
                                                                      (
                                                                        SELECT
                                                                          tp.name
                                                                        FROM
                                                                          public.task_projects tp
                                                                        WHERE
                                                                          tp.id = (fh.old_value ->> 'project_id') :: uuid
                                                                      )
                                                                    ),
                                                                    '"Unknown project"' :: jsonb
                                                                  )
                                                                )
                                                                WHEN fh.change_type = 'project_unlinked'
                                                                AND fh.old_value #>> '{}' ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
                                                                jsonb_set(
                                                                  COALESCE(fh.metadata, '{}' :: jsonb),
                                                                  '{project_name}',
                                                                  COALESCE(
                                                                    to_jsonb(
                                                                      (
                                                                        SELECT
                                                                          tp.name
                                                                        FROM
                                                                          public.task_projects tp
                                                                        WHERE
                                                                          tp.id = (
                                                                            fh.old_value #>> '{}')::uuid)), '"Unknown project"'::jsonb))
                                                                            ELSE fh.metadata
                                                                          END -- Label metadata enrichment
                                                                          WHEN fh.change_type IN ('label_added', 'label_removed')
                                                                          AND (
                                                                            fh.metadata ->> 'label_name' IS NULL
                                                                            OR fh.metadata ->> 'label_name' = ''
                                                                          ) THEN CASE
                                                                            WHEN fh.change_type = 'label_added'
                                                                            AND fh.new_value ->> 'id' IS NOT NULL THEN COALESCE(
                                                                              (
                                                                                SELECT
                                                                                  jsonb_set(
                                                                                    jsonb_set(
                                                                                      COALESCE(fh.metadata, '{}' :: jsonb),
                                                                                      '{label_name}',
                                                                                      COALESCE(to_jsonb(wtl.name), '"Unknown label"' :: jsonb)
                                                                                    ),
                                                                                    '{label_color}',
                                                                                    COALESCE(to_jsonb(wtl.color), 'null' :: jsonb)
                                                                                  )
                                                                                FROM
                                                                                  public.workspace_task_labels wtl
                                                                                WHERE
                                                                                  wtl.id = (fh.new_value ->> 'id') :: uuid
                                                                              ),
                                                                              fh.metadata
                                                                            )
                                                                            WHEN fh.change_type = 'label_removed'
                                                                            AND fh.old_value ->> 'id' IS NOT NULL THEN COALESCE(
                                                                              (
                                                                                SELECT
                                                                                  jsonb_set(
                                                                                    jsonb_set(
                                                                                      COALESCE(fh.metadata, '{}' :: jsonb),
                                                                                      '{label_name}',
                                                                                      COALESCE(to_jsonb(wtl.name), '"Unknown label"' :: jsonb)
                                                                                    ),
                                                                                    '{label_color}',
                                                                                    COALESCE(to_jsonb(wtl.color), 'null' :: jsonb)
                                                                                  )
                                                                                FROM
                                                                                  public.workspace_task_labels wtl
                                                                                WHERE
                                                                                  wtl.id = (fh.old_value ->> 'id') :: uuid
                                                                              ),
                                                                              fh.metadata
                                                                            )
                                                                            ELSE fh.metadata
                                                                          END
                                                                          ELSE fh.metadata
                                                                      END AS metadata,
                                                                      fh.total_count
                                                                      FROM
                                                                        filtered_history fh
                                                                    )
                                                                    SELECT
                                                                      eh.id,
                                                                      eh.task_id,
                                                                      eh.task_name,
                                                                      eh.task_deleted_at,
                                                                      eh.task_permanently_deleted,
                                                                      eh.board_id,
                                                                      eh.board_name,
                                                                      eh.changed_by,
                                                                      eh.changed_at,
                                                                      eh.change_type,
                                                                      eh.field_name,
                                                                      eh.old_value,
                                                                      eh.new_value,
                                                                      eh.metadata,
                                                                      u.id AS user_id,
                                                                      u.display_name AS user_display_name,
                                                                      u.avatar_url AS user_avatar_url,
                                                                      eh.total_count
                                                                    FROM
                                                                      enriched_history eh
                                                                      LEFT JOIN public.users u ON eh.changed_by = u.id;

END;

$ _ $;

ALTER FUNCTION "public"."get_workspace_task_history"(
  "p_ws_id" "uuid",
  "p_page" integer,
  "p_page_size" integer,
  "p_change_type" "text",
  "p_field_name" "text",
  "p_board_id" "uuid",
  "p_search" "text",
  "p_from" timestamp with time zone,
  "p_to" timestamp with time zone
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_task_history"(
  "p_ws_id" "uuid",
  "p_page" integer,
  "p_page_size" integer,
  "p_change_type" "text",
  "p_field_name" "text",
  "p_board_id" "uuid",
  "p_search" "text",
  "p_from" timestamp with time zone,
  "p_to" timestamp with time zone
) IS 'Retrieves task history for a workspace with pagination, filtering, user info, project/label enrichment. Includes both soft-deleted and permanently deleted tasks. Uses workspace_id from metadata for permanently deleted tasks.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_time_tracking_stats"(
  "p_workspace_id" "uuid",
  "p_target_date" timestamp with time zone DEFAULT "now"()
) RETURNS "jsonb" LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ DECLARE v_start_of_day timestamptz;

v_start_of_yesterday timestamptz;

v_start_of_week timestamptz;

v_start_of_month timestamptz;

v_result jsonb;

BEGIN -- Calculate time boundaries using GMT+7 timezone
v_start_of_day := date_trunc(
  'day',
  p_target_date AT TIME ZONE 'Asia/Ho_Chi_Minh'
) AT TIME ZONE 'Asia/Ho_Chi_Minh';

v_start_of_yesterday := v_start_of_day - INTERVAL '1 day';

v_start_of_week := date_trunc('week', v_start_of_day);

v_start_of_month := date_trunc('month', v_start_of_day);

-- Aggregate time tracking stats for all workspace members
SELECT
  jsonb_build_object(
    'aggregated',
    COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'user',
          jsonb_build_object(
            'platform_user_id',
            u.id,
            'display_name',
            u.display_name,
            'handle',
            u.handle
          ),
          'stats',
          jsonb_build_object(
            'todayTime',
            COALESCE(user_stats.today_time, 0),
            'yesterdayTime',
            COALESCE(user_stats.yesterday_time, 0),
            'weekTime',
            COALESCE(user_stats.week_time, 0),
            'monthTime',
            COALESCE(user_stats.month_time, 0)
          )
        )
      ),
      '[]' :: jsonb
    ),
    'members',
    COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'platform_user_id',
          u.id,
          'display_name',
          u.display_name,
          'handle',
          u.handle
        )
      ),
      '[]' :: jsonb
    )
  ) INTO v_result
FROM
  workspace_members wm
  INNER JOIN users u ON u.id = wm.user_id
  LEFT JOIN LATERAL (
    SELECT
      -- Today's time (sessions starting today)
      SUM(
        CASE
          WHEN tts.start_time >= v_start_of_day THEN tts.duration_seconds
          ELSE 0
        END
      ) AS today_time,
      -- Yesterday's time
      SUM(
        CASE
          WHEN tts.start_time >= v_start_of_yesterday
          AND tts.start_time < v_start_of_day THEN tts.duration_seconds
          ELSE 0
        END
      ) AS yesterday_time,
      -- Week's time
      SUM(
        CASE
          WHEN tts.start_time >= v_start_of_week THEN tts.duration_seconds
          ELSE 0
        END
      ) AS week_time,
      -- Month's time
      SUM(
        CASE
          WHEN tts.start_time >= v_start_of_month THEN tts.duration_seconds
          ELSE 0
        END
      ) AS month_time
    FROM
      time_tracking_sessions tts
    WHERE
      tts.user_id = u.id
      AND tts.ws_id = p_workspace_id
      AND tts.start_time >= v_start_of_month
      AND tts.duration_seconds IS NOT NULL
  ) user_stats ON true
WHERE
  wm.ws_id = p_workspace_id;

RETURN v_result;

END;

$ $;

ALTER FUNCTION "public"."get_workspace_time_tracking_stats"(
  "p_workspace_id" "uuid",
  "p_target_date" timestamp with time zone
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_time_tracking_stats"(
  "p_workspace_id" "uuid",
  "p_target_date" timestamp with time zone
) IS 'Aggregates time tracking statistics for all members of a workspace. Returns today, yesterday, week, and month totals for each user. Used by Discord daily report generation.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_transaction_categories_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.transaction_categories
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_workspace_transaction_categories_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_transactions_count"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone
) RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = $ 1
  AND (
    (
      start_date IS NULL
      AND end_date IS NULL
    )
    OR (
      start_date IS NULL
      AND wt.taken_at <= $ 3
    )
    OR (
      end_date IS NULL
      AND wt.taken_at >= $ 2
    )
    OR (
      wt.taken_at BETWEEN $ 2
      AND $ 3
    )
  ) $ _ $;

ALTER FUNCTION "public"."get_workspace_transactions_count"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_user_groups"(
  "_ws_id" "uuid",
  "included_tags" "uuid" [],
  "excluded_tags" "uuid" [],
  "search_query" "text"
) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "notes" "text",
  "ws_id" "uuid",
  "tags" "uuid" [],
  "tag_count" bigint,
  "created_at" timestamp with time zone
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  ug.id,
  ug.name,
  ug.notes,
  ug.ws_id,
  ARRAY(
    SELECT
      json_array_elements_text(ug.tags) :: UUID
  ) AS tags,
  ug.tag_count,
  ug.created_at
FROM
  user_groups_with_tags ug
WHERE
  ug.ws_id = _ws_id
  AND (
    search_query IS NULL
    OR (ug.name ILIKE '%' || search_query || '%')
  )
  AND (
    (
      included_tags IS NULL
      OR included_tags = ARRAY [] :: uuid []
      OR ARRAY(
        SELECT
          json_array_elements_text(ug.tags) :: UUID
      ) & & included_tags
    )
    AND (
      excluded_tags IS NULL
      OR excluded_tags = ARRAY [] :: uuid []
      OR NOT (
        ARRAY(
          SELECT
            json_array_elements_text(ug.tags) :: UUID
        ) & & excluded_tags
      )
    )
  );

END;

$ $;

ALTER FUNCTION "public"."get_workspace_user_groups"(
  "_ws_id" "uuid",
  "included_tags" "uuid" [],
  "excluded_tags" "uuid" [],
  "search_query" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_user_groups_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspace_user_groups
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_workspace_user_groups_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_user_with_details"("p_ws_id" "uuid", "p_user_id" "uuid") RETURNS json LANGUAGE "plpgsql" AS $ $ DECLARE result json;

BEGIN -- Main query to get workspace user with all related data
SELECT
  json_build_object(
    'id',
    wu.id,
    'ws_id',
    wu.ws_id,
    'display_name',
    wu.display_name,
    'full_name',
    wu.full_name,
    'email',
    wu.email,
    'phone',
    wu.phone,
    'avatar_url',
    wu.avatar_url,
    'birthday',
    wu.birthday,
    'gender',
    wu.gender,
    'created_at',
    wu.created_at,
    'updated_at',
    wu.updated_at,
    'archived',
    wu.archived,
    'note',
    wu.note,
    'referred_by',
    wu.referred_by,
    'linked_users',
    COALESCE(
      (
        SELECT
          json_agg(
            json_build_object(
              'platform_user_id',
              wulu.platform_user_id,
              'users',
              json_build_object(
                'display_name',
                u.display_name
              )
            )
          )
        FROM
          workspace_user_linked_users wulu
          JOIN users u ON u.id = wulu.platform_user_id
          JOIN workspace_members wm ON wm.user_id = u.id
          AND wm.ws_id = p_ws_id
        WHERE
          wulu.virtual_user_id = wu.id
          AND wulu.ws_id = p_ws_id
      ),
      '[]' :: json
    ),
    'referrer',
    CASE
      WHEN wu.referred_by IS NOT NULL THEN json_build_object(
        'id',
        ref_wu.id,
        'display_name',
        ref_wu.display_name,
        'full_name',
        ref_wu.full_name,
        'ws_id',
        ref_wu.ws_id
      )
      ELSE NULL
    END
  ) INTO result
FROM
  workspace_users wu
  LEFT JOIN workspace_users ref_wu ON ref_wu.id = wu.referred_by
WHERE
  wu.ws_id = p_ws_id
  AND wu.id = p_user_id;

-- Return the result
RETURN result;

END;

$ $;

ALTER FUNCTION "public"."get_workspace_user_with_details"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_user_with_details"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Retrieves a workspace user with their linked platform users and referrer information. 
Parameters: workspace_id, user_id. 
Returns: JSON object with user details, linked_users array, and referrer object.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_users"(
  "_ws_id" "uuid",
  "included_groups" "uuid" [],
  "excluded_groups" "uuid" [],
  "search_query" "text"
) RETURNS TABLE(
  "id" "uuid",
  "avatar_url" "text",
  "full_name" "text",
  "display_name" "text",
  "email" "text",
  "phone" "text",
  "gender" "text",
  "birthday" "date",
  "ethnicity" "text",
  "guardian" "text",
  "address" "text",
  "national_id" "text",
  "note" "text",
  "balance" bigint,
  "ws_id" "uuid",
  "groups" "uuid" [],
  "group_count" bigint,
  "linked_users" json,
  "archived" boolean,
  "archived_until" timestamp with time zone,
  "created_at" timestamp with time zone,
  "updated_at" timestamp with time zone
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  wu.id,
  wu.avatar_url,
  wu.full_name,
  wu.display_name,
  wu.email,
  wu.phone,
  wu.gender,
  wu.birthday,
  wu.ethnicity,
  wu.guardian,
  wu.address,
  wu.national_id,
  wu.note,
  wu.balance,
  wu.ws_id,
  ARRAY(
    SELECT
      json_array_elements_text(wu.groups) :: UUID
  ) AS groups,
  wu.group_count,
  wu.linked_users,
  wu.archived,
  wu.archived_until,
  wu.created_at,
  wu.updated_at
FROM
  workspace_users_with_groups wu
WHERE
  wu.ws_id = _ws_id
  AND (
    search_query IS NULL
    OR (
      wu.full_name ILIKE '%' || search_query || '%'
      OR wu.display_name ILIKE '%' || search_query || '%'
    )
  )
  AND (
    (
      included_groups IS NULL
      OR included_groups = ARRAY [] :: uuid []
      OR ARRAY(
        SELECT
          json_array_elements_text(wu.groups) :: UUID
      ) & & included_groups
    )
    AND (
      excluded_groups IS NULL
      OR excluded_groups = ARRAY [] :: uuid []
      OR NOT (
        ARRAY(
          SELECT
            json_array_elements_text(wu.groups) :: UUID
        ) & & excluded_groups
      )
    )
  );

END;

$ $;

ALTER FUNCTION "public"."get_workspace_users"(
  "_ws_id" "uuid",
  "included_groups" "uuid" [],
  "excluded_groups" "uuid" [],
  "search_query" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_users_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspace_users
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_workspace_users_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_wallets_count"("ws_id" "uuid") RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  COUNT(*)
FROM
  public.workspace_wallets
WHERE
  ws_id = $ 1 $ _ $;

ALTER FUNCTION "public"."get_workspace_wallets_count"("ws_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_wallets_expense"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone
) RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  SUM(amount)
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = $ 1
  AND wt.report_opt_in = true
  AND ww.report_opt_in = true
  AND wt.amount < 0
  AND (
    (
      start_date IS NULL
      AND end_date IS NULL
    )
    OR (
      start_date IS NULL
      AND wt.taken_at <= $ 3
    )
    OR (
      end_date IS NULL
      AND wt.taken_at >= $ 2
    )
    OR (
      wt.taken_at BETWEEN $ 2
      AND $ 3
    )
  ) $ _ $;

ALTER FUNCTION "public"."get_workspace_wallets_expense"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_wallets_expense"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "include_confidential" boolean DEFAULT true
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ _ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(ws_id, auth.uid(), 'view_confidential_amount');

-- Calculate sum of expense transactions with date filtering
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = $ 1
  AND wt.report_opt_in = true
  AND ww.report_opt_in = true
  AND wt.amount < 0
  AND (
    -- Confidential filtering
    (
      NOT include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR (
      include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  )
  AND (
    -- Date filtering (existing logic)
    (
      start_date IS NULL
      AND end_date IS NULL
    )
    OR (
      start_date IS NULL
      AND wt.taken_at <= $ 3
    )
    OR (
      end_date IS NULL
      AND wt.taken_at >= $ 2
    )
    OR (
      wt.taken_at BETWEEN $ 2
      AND $ 3
    )
  );

RETURN result;

END;

$ _ $;

ALTER FUNCTION "public"."get_workspace_wallets_expense"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "include_confidential" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_wallets_expense"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "include_confidential" boolean
) IS 'Returns the sum of expense transactions for a workspace with date filtering. Set include_confidential=false to exclude confidential transactions.';

CREATE
OR REPLACE FUNCTION "public"."get_workspace_wallets_income"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone
) RETURNS numeric LANGUAGE "sql" AS $ _ $
SELECT
  SUM(amount)
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = $ 1
  AND wt.report_opt_in = true
  AND ww.report_opt_in = true
  AND wt.amount > 0
  AND (
    (
      start_date IS NULL
      AND end_date IS NULL
    )
    OR (
      start_date IS NULL
      AND wt.taken_at <= $ 3
    )
    OR (
      end_date IS NULL
      AND wt.taken_at >= $ 2
    )
    OR (
      wt.taken_at BETWEEN $ 2
      AND $ 3
    )
  ) $ _ $;

ALTER FUNCTION "public"."get_workspace_wallets_income"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."get_workspace_wallets_income"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "end_date" timestamp with time zone DEFAULT NULL :: timestamp with time zone,
  "include_confidential" boolean DEFAULT true
) RETURNS numeric LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ _ $ DECLARE can_view_amount boolean;

result numeric;

BEGIN -- Check if user has permission to view confidential amounts
can_view_amount := public.has_workspace_permission(ws_id, auth.uid(), 'view_confidential_amount');

-- Calculate sum of income transactions with date filtering
SELECT
  COALESCE(SUM(wt.amount), 0) INTO result
FROM
  public.wallet_transactions wt
  JOIN public.workspace_wallets ww ON wt.wallet_id = ww.id
WHERE
  ww.ws_id = $ 1
  AND wt.report_opt_in = true
  AND ww.report_opt_in = true
  AND wt.amount > 0
  AND (
    -- Confidential filtering
    (
      NOT include_confidential
      AND NOT wt.is_amount_confidential
    )
    OR (
      include_confidential
      AND (
        NOT wt.is_amount_confidential
        OR can_view_amount
      )
    )
  )
  AND (
    -- Date filtering (existing logic)
    (
      start_date IS NULL
      AND end_date IS NULL
    )
    OR (
      start_date IS NULL
      AND wt.taken_at <= $ 3
    )
    OR (
      end_date IS NULL
      AND wt.taken_at >= $ 2
    )
    OR (
      wt.taken_at BETWEEN $ 2
      AND $ 3
    )
  );

RETURN result;

END;

$ _ $;

ALTER FUNCTION "public"."get_workspace_wallets_income"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "include_confidential" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."get_workspace_wallets_income"(
  "ws_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "include_confidential" boolean
) IS 'Returns the sum of income transactions for a workspace with date filtering. Set include_confidential=false to exclude confidential transactions.';

CREATE
OR REPLACE FUNCTION "public"."handle_request_status_change"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ BEGIN -- Only process if status changed
  IF OLD.approval_status = NEW.approval_status THEN RETURN NEW;

END IF;

-- If request has a linked session
IF NEW.linked_session_id IS NOT NULL THEN IF NEW.approval_status = 'APPROVED' THEN -- On approval, clear the pending_approval flag so session appears in history
UPDATE
  time_tracking_sessions
SET
  pending_approval = false,
  updated_at = NOW()
WHERE
  id = NEW.linked_session_id;

ELSIF NEW.approval_status = 'REJECTED' THEN -- On rejection, delete the linked session (cascade will delete breaks)
DELETE FROM
  time_tracking_sessions
WHERE
  id = NEW.linked_session_id;

-- Clear the reference since session is deleted
NEW.linked_session_id := NULL;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."handle_request_status_change"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."hard_delete_soft_deleted_items"() RETURNS "void" LANGUAGE "plpgsql" AS $ $ BEGIN -- Hard delete tasks that were soft-deleted more than 30 days ago
DELETE FROM
  public.tasks
WHERE
  deleted_at IS NOT NULL
  AND deleted_at < (now() AT TIME ZONE 'UTC' - interval '30 days');

-- Hard delete boards that were soft-deleted more than 30 days ago
DELETE FROM
  public.workspace_boards
WHERE
  deleted_at IS NOT NULL
  AND deleted_at < (now() AT TIME ZONE 'UTC' - interval '30 days');

END;

$ $;

ALTER FUNCTION "public"."hard_delete_soft_deleted_items"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."hard_delete_soft_deleted_items"() IS 'Hard deletes tasks and boards that were soft-deleted more than 30 days ago. Runs hourly via pg_cron.';

CREATE
OR REPLACE FUNCTION "public"."has_workspace_permission"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_permission" "text"
) RETURNS boolean LANGUAGE "plpgsql" STABLE SECURITY DEFINER AS $ $ begin -- First check if user is the workspace creator
-- If so, they automatically have all permissions
if exists (
  select
    1
  from
    workspaces
  where
    id = p_ws_id
    and creator_id = p_user_id
) then return true;

end if;

-- Otherwise, check role-based and default permissions as before
return exists (
  -- Check if user has permission via role membership
  select
    1
  from
    workspace_role_members wrm
    join workspace_role_permissions wrp on wrp.role_id = wrm.role_id
    and wrp.ws_id = p_ws_id
  where
    wrm.user_id = p_user_id
    and wrp.permission = p_permission :: "public"."workspace_role_permission"
    and wrp.enabled = true
  union
  -- Also check workspace-wide default permissions
  select
    1
  from
    workspace_default_permissions wdp
  where
    wdp.ws_id = p_ws_id
    and wdp.permission = p_permission :: "public"."workspace_role_permission"
    and wdp.enabled = true
);

end;

$ $;

ALTER FUNCTION "public"."has_workspace_permission"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_permission" "text"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."has_workspace_permission"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_permission" "text"
) IS 'Checks if a user has a specific permission in a workspace. Workspace creators automatically have all permissions. For other users, checks both role-based permissions and workspace-wide default permissions.';

CREATE
OR REPLACE FUNCTION "public"."has_workspace_secret"("ws_id" "uuid", "secret_name" "text") RETURNS boolean LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN EXISTS (
  SELECT
    1
  FROM
    public.workspace_secrets ws
  WHERE
    ws.ws_id = has_workspace_secret.ws_id
    AND ws.name = has_workspace_secret.secret_name
    AND ws.value = 'true'
    AND public.is_org_member(auth.uid(), has_workspace_secret.ws_id)
);

END;

$ $;

ALTER FUNCTION "public"."has_workspace_secret"("ws_id" "uuid", "secret_name" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."insert_ai_chat_message"(
  "message" "text",
  "chat_id" "uuid",
  "source" "text"
) RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
INSERT INTO
  ai_chat_messages (chat_id, content, creator_id, role, metadata)
VALUES
  (
    chat_id,
    message,
    auth.uid(),
    'USER',
    jsonb_build_object('source', COALESCE(source, 'Unknown'))
  );

END;

$ $;

ALTER FUNCTION "public"."insert_ai_chat_message"(
  "message" "text",
  "chat_id" "uuid",
  "source" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."insert_task_history"(
  "p_task_id" "uuid",
  "p_change_type" "text",
  "p_field_name" "text" DEFAULT NULL :: "text",
  "p_old_value" "jsonb" DEFAULT NULL :: "jsonb",
  "p_new_value" "jsonb" DEFAULT NULL :: "jsonb",
  "p_metadata" "jsonb" DEFAULT '{}' :: "jsonb"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_history_id UUID;

BEGIN
INSERT INTO
  public.task_history (
    task_id,
    changed_by,
    change_type,
    field_name,
    old_value,
    new_value,
    metadata
  )
VALUES
  (
    p_task_id,
    auth.uid(),
    p_change_type,
    p_field_name,
    p_old_value,
    p_new_value,
    p_metadata
  ) RETURNING id INTO v_history_id;

RETURN v_history_id;

END;

$ $;

ALTER FUNCTION "public"."insert_task_history"(
  "p_task_id" "uuid",
  "p_change_type" "text",
  "p_field_name" "text",
  "p_old_value" "jsonb",
  "p_new_value" "jsonb",
  "p_metadata" "jsonb"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."insert_task_history"(
  "p_task_id" "uuid",
  "p_change_type" "text",
  "p_field_name" "text",
  "p_old_value" "jsonb",
  "p_new_value" "jsonb",
  "p_metadata" "jsonb"
) IS 'Helper function to insert task history records with proper structure';

SET
  default_tablespace = '';

SET
  default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."time_tracking_sessions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "task_id" "uuid",
  "category_id" "uuid",
  "title" "text" NOT NULL,
  "description" "text",
  "start_time" timestamp with time zone NOT NULL,
  "end_time" timestamp with time zone,
  "duration_seconds" integer,
  "is_running" boolean DEFAULT false,
  "tags" "text" [],
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "productivity_score" integer DEFAULT 0,
  "was_resumed" boolean DEFAULT false NOT NULL,
  "date" "date" GENERATED ALWAYS AS (
    (("start_time" AT TIME ZONE 'UTC' :: "text")) :: "date"
  ) STORED,
  "parent_session_id" "uuid",
  "pending_approval" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."time_tracking_sessions" OWNER TO "postgres";

COMMENT ON COLUMN "public"."time_tracking_sessions"."was_resumed" IS 'DEPRECATED: Indicates this session was resumed from a pause. Replaced by parent_session_id chain tracking. Kept for backwards compatibility during migration.';

COMMENT ON COLUMN "public"."time_tracking_sessions"."parent_session_id" IS 'Links resumed sessions to their paused predecessor, creating session chains. NULL for root sessions (start of work period).';

COMMENT ON COLUMN "public"."time_tracking_sessions"."pending_approval" IS 'True when session has a pending approval request. Sessions with pending_approval=true should not appear in session history until approved.';

CREATE
OR REPLACE FUNCTION "public"."insert_time_tracking_session_bypassed"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_title" "text",
  "p_description" "text",
  "p_start_time" timestamp with time zone,
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer,
  "p_category_id" "uuid" DEFAULT NULL :: "uuid",
  "p_task_id" "uuid" DEFAULT NULL :: "uuid"
) RETURNS "public"."time_tracking_sessions" LANGUAGE "plpgsql" AS $ $ DECLARE inserted_row time_tracking_sessions;

BEGIN -- 1. Set the bypass flag
PERFORM set_config('time_tracking.bypass_insert_limit', 'on', true);

-- 2. Execute the insert, which will now ignore the trigger
INSERT INTO
  time_tracking_sessions (
    ws_id,
    user_id,
    title,
    description,
    category_id,
    task_id,
    start_time,
    end_time,
    duration_seconds,
    is_running
  )
VALUES
  (
    p_ws_id,
    p_user_id,
    p_title,
    p_description,
    p_category_id,
    p_task_id,
    p_start_time,
    p_end_time,
    p_duration_seconds,
    false
  ) RETURNING * INTO inserted_row;

-- 3. Unset the bypass flag (optional but good practice)
PERFORM set_config('time_tracking.bypass_insert_limit', 'off', true);

RETURN inserted_row;

END;

$ $;

ALTER FUNCTION "public"."insert_time_tracking_session_bypassed"(
  "p_ws_id" "uuid",
  "p_user_id" "uuid",
  "p_title" "text",
  "p_description" "text",
  "p_start_time" timestamp with time zone,
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer,
  "p_category_id" "uuid",
  "p_task_id" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_list_accessible"("_list_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      task_lists tl
    WHERE
      tl.id = _list_id
  );

$ $;

ALTER FUNCTION "public"."is_list_accessible"("_list_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_member_invited"("_user_id" "uuid", "_org_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      workspace_invites wsi
    WHERE
      wsi.ws_id = _org_id
      AND wsi.user_id = _user_id
  );

$ $;

ALTER FUNCTION "public"."is_member_invited"("_user_id" "uuid", "_org_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_nova_challenge_manager"() RETURNS boolean LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ begin return exists (
  select
    1
  from
    public.platform_user_roles
  where
    (
      select
        auth.uid()
    ) = user_id
    and allow_challenge_management = true
);

end;

$ $;

ALTER FUNCTION "public"."is_nova_challenge_manager"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_nova_role_manager"() RETURNS boolean LANGUAGE "plpgsql" AS $ $ begin return exists (
  select
    1
  from
    public.platform_user_roles
  where
    (
      select
        auth.uid()
    ) = user_id
    and allow_role_management = true
);

end;

$ $;

ALTER FUNCTION "public"."is_nova_role_manager"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_nova_user_email_in_team"("_user_email" "text", "_team_id" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ begin return exists(
  select
    1
  from
    public.nova_team_emails
  where
    _user_email = email
    and _team_id = team_id
);

end;

$ $;

ALTER FUNCTION "public"."is_nova_user_email_in_team"("_user_email" "text", "_team_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_nova_user_id_in_team"("_user_id" "uuid", "_team_id" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ begin return exists(
  select
    1
  from
    public.nova_team_members
  where
    _user_id = user_id
    and _team_id = team_id
);

end;

$ $;

ALTER FUNCTION "public"."is_nova_user_id_in_team"("_user_id" "uuid", "_team_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_org_member"("_user_id" "uuid", "_org_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      workspace_members wsm
    WHERE
      wsm.ws_id = _org_id
      AND wsm.user_id = _user_id
  );

$ $;

ALTER FUNCTION "public"."is_org_member"("_user_id" "uuid", "_org_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_personal_workspace"("p_ws_id" "uuid") RETURNS boolean LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
select
  coalesce(
    (
      select
        personal
      from
        public.workspaces
      where
        id = p_ws_id
    ),
    false
  );

$ $;

ALTER FUNCTION "public"."is_personal_workspace"("p_ws_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."is_personal_workspace"("p_ws_id" "uuid") IS 'Returns true if the workspace with the given id is marked as personal; false otherwise.';

CREATE
OR REPLACE FUNCTION "public"."is_project_member"("_project_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      projects
    WHERE
      id = _project_id
  );

$ $;

ALTER FUNCTION "public"."is_project_member"("_project_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_task_accessible"("_task_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      tasks
    WHERE
      tasks.id = _task_id
  );

$ $;

ALTER FUNCTION "public"."is_task_accessible"("_task_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_task_board_member"("_user_id" "uuid", "_board_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      workspace_boards
    WHERE
      id = _board_id
  );

$ $;

ALTER FUNCTION "public"."is_task_board_member"("_user_id" "uuid", "_board_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_tuturuuu_email"("user_email" "text") RETURNS boolean LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ _ $
select
  user_email ~ '^[^\s@]+@(tuturuuu\.com|xwf\.tuturuuu\.com)$';

$ _ $;

ALTER FUNCTION "public"."is_tuturuuu_email"("user_email" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_user_guest"("user_uuid" "uuid") RETURNS boolean LANGUAGE "plpgsql" AS $ $ BEGIN RETURN EXISTS (
  SELECT
    1
  FROM
    workspace_users_with_groups wu,
    LATERAL jsonb_array_elements_text(wu.groups :: jsonb) AS user_group_element
    JOIN workspace_user_groups wug ON user_group_element :: uuid = wug.id
  WHERE
    wu.id = user_uuid
    AND wug.is_guest = TRUE
);

END;

$ $;

ALTER FUNCTION "public"."is_user_guest"("user_uuid" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_user_task_in_board"("_user_id" "uuid", "_task_id" "uuid") RETURNS boolean LANGUAGE "sql" SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      tasks,
      task_lists lists
    WHERE
      tasks.id = _task_id
      AND lists.id = tasks.list_id
  );

$ $;

ALTER FUNCTION "public"."is_user_task_in_board"("_user_id" "uuid", "_task_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_user_whitelisted"("user_id_param" "uuid") RETURNS boolean LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN RETURN EXISTS (
  SELECT
    1
  FROM
    public.platform_user_roles
  WHERE
    user_id = user_id_param
    AND enabled = true
);

END;

$ $;

ALTER FUNCTION "public"."is_user_whitelisted"("user_id_param" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."is_workspace_owner"("p_ws_id" "uuid", "p_user_id" "uuid") RETURNS boolean LANGUAGE "sql" STABLE SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $
select
  exists (
    select
      1
    from
      public.workspaces w
    where
      w.id = p_ws_id
      and w.creator_id = p_user_id
  );

$ $;

ALTER FUNCTION "public"."is_workspace_owner"("p_ws_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

COMMENT ON FUNCTION "public"."is_workspace_owner"("p_ws_id" "uuid", "p_user_id" "uuid") IS 'Returns true if p_user_id is the creator of workspace p_ws_id; false otherwise.';

CREATE
OR REPLACE FUNCTION "public"."match_tasks"(
  "query_embedding" "extensions"."vector",
  "query_text" "text",
  "match_threshold" double precision DEFAULT 0.3,
  "match_count" integer DEFAULT 50,
  "filter_ws_id" "uuid" DEFAULT NULL :: "uuid",
  "filter_deleted" boolean DEFAULT false
) RETURNS TABLE(
  "id" "uuid",
  "name" "text",
  "description" "text",
  "list_id" "uuid",
  "list_name" "text",
  "list_status" "public"."task_board_status",
  "board_id" "uuid",
  "board_name" "text",
  "priority" "public"."task_priority",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "completed_at" timestamp with time zone,
  "closed_at" timestamp with time zone,
  "created_at" timestamp with time zone,
  "similarity" double precision
) LANGUAGE "plpgsql" AS $ $ #variable_conflict use_column
BEGIN RETURN QUERY WITH semantic_search AS (
  SELECT
    tasks.id,
    (1.0 - (tasks.embedding <= > query_embedding)) as semantic_similarity,
    row_number() over (
      order by
        tasks.embedding <= > query_embedding
    ) as semantic_rank
  FROM
    tasks
    INNER JOIN task_lists ON tasks.list_id = task_lists.id
    INNER JOIN workspace_boards ON task_lists.board_id = workspace_boards.id
  WHERE
    tasks.embedding IS NOT NULL
    AND (
      filter_ws_id IS NULL
      OR workspace_boards.ws_id = filter_ws_id
    )
    AND (
      filter_deleted
      OR tasks.deleted_at IS NULL
    )
  ORDER BY
    tasks.embedding <= > query_embedding
  LIMIT
    least(match_count * 3, 150)
), keyword_search AS (
  SELECT
    tasks.id,
    ts_rank_cd(
      tasks.fts,
      websearch_to_tsquery('english', query_text)
    ) as keyword_score,
    row_number() over (
      order by
        ts_rank_cd(
          tasks.fts,
          websearch_to_tsquery('english', query_text)
        ) desc
    ) as keyword_rank
  FROM
    tasks
    INNER JOIN task_lists ON tasks.list_id = task_lists.id
    INNER JOIN workspace_boards ON task_lists.board_id = workspace_boards.id
  WHERE
    tasks.fts @ @ websearch_to_tsquery('english', query_text)
    AND (
      filter_ws_id IS NULL
      OR workspace_boards.ws_id = filter_ws_id
    )
    AND (
      filter_deleted
      OR tasks.deleted_at IS NULL
    )
  ORDER BY
    ts_rank_cd(
      tasks.fts,
      websearch_to_tsquery('english', query_text)
    ) desc
  LIMIT
    least(match_count * 3, 150)
), combined_results AS (
  SELECT
    coalesce(s.id, k.id) as id,
    coalesce(s.semantic_similarity, 0.0) as semantic_similarity,
    coalesce(k.keyword_score, 0.0) as keyword_score,
    -- Heavily weight keyword matches (70%) over semantic (30%)
    -- This ensures exact matches rank higher
    (
      coalesce(k.keyword_score, 0.0) * 0.7 + coalesce(s.semantic_similarity, 0.0) * 0.3
    ) as combined_score
  FROM
    semantic_search s FULL
    OUTER JOIN keyword_search k ON s.id = k.id
),
ranked_results AS (
  SELECT
    tasks.id,
    tasks.name,
    tasks.description,
    tasks.list_id,
    task_lists.name as list_name,
    task_lists.status as list_status,
    workspace_boards.id as board_id,
    workspace_boards.name as board_name,
    tasks.priority,
    tasks.start_date,
    tasks.end_date,
    tasks.completed_at,
    tasks.closed_at,
    tasks.created_at,
    cr.combined_score,
    -- Status priority: active/not_started = 1.0, done/closed = 0.5
    -- This boosts active tasks by ~15% in final ranking
    CASE
      WHEN task_lists.status IN ('active', 'not_started') THEN 1.0
      ELSE 0.5
    END as status_boost,
    -- Final score combines relevance with status boost
    (
      cr.combined_score * 0.85 + CASE
        WHEN task_lists.status IN ('active', 'not_started') THEN 0.15
        ELSE 0.0
      END
    ) as final_score
  FROM
    combined_results cr
    INNER JOIN tasks ON tasks.id = cr.id
    INNER JOIN task_lists ON tasks.list_id = task_lists.id
    INNER JOIN workspace_boards ON task_lists.board_id = workspace_boards.id
  WHERE
    (
      filter_ws_id IS NULL
      OR workspace_boards.ws_id = filter_ws_id
    )
    AND (
      filter_deleted
      OR tasks.deleted_at IS NULL
    )
)
SELECT
  id,
  name,
  description,
  list_id,
  list_name,
  list_status,
  board_id,
  board_name,
  priority,
  start_date,
  end_date,
  completed_at,
  closed_at,
  created_at,
  combined_score :: float as similarity
FROM
  ranked_results
ORDER BY
  final_score desc
LIMIT
  least(match_count, 200);

END;

$ $;

ALTER FUNCTION "public"."match_tasks"(
  "query_embedding" "extensions"."vector",
  "query_text" "text",
  "match_threshold" double precision,
  "match_count" integer,
  "filter_ws_id" "uuid",
  "filter_deleted" boolean
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."match_tasks"(
  "query_embedding" "extensions"."vector",
  "query_text" "text",
  "match_threshold" double precision,
  "match_count" integer,
  "filter_ws_id" "uuid",
  "filter_deleted" boolean
) IS 'Hybrid semantic and keyword search for tasks. Returns task details including list and board information, priority, timestamps (completed_at, closed_at, created_at), and list status. Results are ranked by weighted combination of semantic similarity (30%) and keyword relevance (70%).';

CREATE
OR REPLACE FUNCTION "public"."migrate_email_notifications_on_login"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Update all notifications with matching email to add user_id
UPDATE
  public.notifications
SET
  user_id = NEW.id
WHERE
  email = NEW.email
  AND (
    user_id IS NULL
    OR user_id != NEW.id
  );

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."migrate_email_notifications_on_login"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."migrate_email_notifications_on_signup"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Update all notifications with matching email to add user_id
UPDATE
  public.notifications
SET
  user_id = NEW.id
WHERE
  email = NEW.email
  AND user_id IS NULL;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."migrate_email_notifications_on_signup"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."migrate_email_notifications_on_signup"() IS 'Automatically migrates email-based notifications to user_id when a user signs up';

CREATE
OR REPLACE FUNCTION "public"."normalize_related_relationship"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Only check for related relationships
IF NEW.type = 'related' THEN -- Check if the inverse relationship already exists
IF EXISTS (
  SELECT
    1
  FROM
    public.task_relationships
  WHERE
    source_task_id = NEW.target_task_id
    AND target_task_id = NEW.source_task_id
    AND type = 'related'
) THEN RAISE EXCEPTION 'Related relationship already exists between tasks % and %. Related relationships are bidirectional.',
NEW.source_task_id,
NEW.target_task_id;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."normalize_related_relationship"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."normalize_task_sort_keys"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE list_record RECORD;

task_record RECORD;

new_sort_key BIGINT;

task_counter INTEGER;

BEGIN -- Process each list separately
FOR list_record IN
SELECT
  DISTINCT list_id
FROM
  tasks
WHERE
  deleted_at IS NULL LOOP task_counter := 0;

-- Update sort_keys for all tasks in this list
-- Only update if tasks are too close together (< 100000 apart) or have nulls
FOR task_record IN
SELECT
  id,
  sort_key,
  ROW_NUMBER() OVER (
    ORDER BY
      sort_key NULLS LAST,
      created_at
  ) as row_num
FROM
  tasks
WHERE
  list_id = list_record.list_id
  AND deleted_at IS NULL
ORDER BY
  sort_key NULLS LAST,
  created_at LOOP task_counter := task_counter + 1;

new_sort_key := task_counter * 1000000;

-- 1000 * 1000 spacing
-- Only update if the sort_key is null or significantly different
IF task_record.sort_key IS NULL
OR ABS(task_record.sort_key - new_sort_key) > 100000 THEN
UPDATE
  tasks
SET
  sort_key = new_sort_key
WHERE
  id = task_record.id;

END IF;

END LOOP;

END LOOP;

END;

$ $;

ALTER FUNCTION "public"."normalize_task_sort_keys"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."normalize_task_sort_keys"() IS 'Normalizes task sort_keys to maintain minimum 1000000-unit spacing between tasks within each list. Runs hourly via pg_cron. Uses deleted_at IS NULL instead of deleted = false.';

CREATE
OR REPLACE FUNCTION "public"."notify_task_assigned"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task_details RECORD;

v_assigner_name TEXT;

v_assigner_id UUID;

v_notification_id UUID;

BEGIN -- Get the actual assigner (the person performing the assignment action)
v_assigner_id := auth.uid();

-- Skip notification if user is assigning themselves (no need to notify yourself)
IF v_assigner_id IS NOT NULL
AND v_assigner_id = NEW.user_id THEN RETURN NEW;

END IF;

-- Skip if this is a system operation (no authenticated user)
IF v_assigner_id IS NULL THEN RETURN NEW;

END IF;

-- Get task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(NEW.task_id);

-- Get assigner name (if available) - only display_name exists in users table
SELECT
  COALESCE(display_name, 'Unknown user') INTO v_assigner_name
FROM
  public.users
WHERE
  id = v_assigner_id;

-- Create notification for the assignee
v_notification_id := public.create_notification(
  p_ws_id := v_task_details.ws_id,
  p_user_id := NEW.user_id,
  p_type := 'task_assigned',
  p_title := 'You have been assigned to a task',
  p_description := v_assigner_name || ' assigned you to "' || v_task_details.task_name || '"',
  p_data := jsonb_build_object(
    'task_id',
    NEW.task_id,
    'task_name',
    v_task_details.task_name,
    'board_id',
    v_task_details.board_id,
    'board_name',
    v_task_details.board_name,
    'list_id',
    v_task_details.list_id,
    'list_name',
    v_task_details.list_name,
    'assigned_by',
    v_assigner_id,
    'assigned_by_name',
    v_assigner_name
  ),
  p_entity_type := 'task',
  p_entity_id := NEW.task_id,
  p_created_by := v_assigner_id
);

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_assigned"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_assigned"() IS 'Trigger function to create notifications when a task is assigned to a user. Uses auth.uid() to identify the actual assigner (not the task creator). Skips notification if user assigns themselves.';

CREATE
OR REPLACE FUNCTION "public"."notify_task_assignee_added"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task RECORD;

v_task_details RECORD;

v_assigned_user RECORD;

v_other_assignee_id UUID;

v_updater_name TEXT;

BEGIN -- Only for INSERT operations
IF TG_OP != 'INSERT' THEN RETURN NEW;

END IF;

-- Get task details
SELECT
  * INTO v_task
FROM
  public.tasks
WHERE
  id = NEW.task_id;

IF v_task IS NULL THEN RETURN NEW;

END IF;

-- Get assigned user details
SELECT
  * INTO v_assigned_user
FROM
  public.users
WHERE
  id = NEW.user_id;

-- Get comprehensive task details (board, workspace, etc.)
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(NEW.task_id);

-- Get updater name (person who assigned)
SELECT
  COALESCE(display_name, handle, 'Unknown') INTO v_updater_name
FROM
  public.users
WHERE
  id = auth.uid();

-- Insert history record with full assignee info
PERFORM public.insert_task_history(
  NEW.task_id,
  'assignee_added',
  NULL,
  NULL,
  jsonb_build_object(
    'user_id',
    v_assigned_user.id,
    'user_name',
    COALESCE(
      v_assigned_user.display_name,
      v_assigned_user.handle,
      'Unknown'
    ),
    'avatar_url',
    v_assigned_user.avatar_url
  ),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'assignee_name',
    COALESCE(
      v_assigned_user.display_name,
      v_assigned_user.handle,
      'Unknown'
    )
  )
);

-- Notify the assigned user (if not self-assigning)
IF NEW.user_id != COALESCE(
  auth.uid(),
  '00000000-0000-0000-0000-000000000000' :: uuid
) THEN PERFORM public.create_notification(
  p_ws_id := v_task_details.ws_id,
  p_user_id := NEW.user_id,
  p_type := 'task_assignee_added',
  p_title := 'Assigned to task',
  p_description := v_updater_name || ' assigned you to "' || v_task.name || '"',
  p_data := jsonb_build_object(
    'task_id',
    NEW.task_id,
    'task_name',
    v_task.name,
    'board_id',
    v_task_details.board_id,
    'assigned_by',
    auth.uid(),
    'assigned_by_name',
    v_updater_name,
    'action_url',
    '/' || v_task_details.ws_id || '/tasks/' || NEW.task_id
  ),
  p_entity_type := 'task',
  p_entity_id := NEW.task_id,
  p_scope := 'workspace'
);

END IF;

-- Notify other existing assignees
FOR v_other_assignee_id IN
SELECT
  user_id
FROM
  public.task_assignees
WHERE
  task_id = NEW.task_id
  AND user_id != COALESCE(
    auth.uid(),
    '00000000-0000-0000-0000-000000000000' :: uuid
  )
  AND user_id != NEW.user_id LOOP PERFORM public.create_notification(
    p_ws_id := v_task_details.ws_id,
    p_user_id := v_other_assignee_id,
    p_type := 'task_assignee_added',
    p_title := 'New assignee added to task',
    p_description := v_updater_name || ' assigned ' || COALESCE(
      v_assigned_user.display_name,
      v_assigned_user.handle,
      'Unknown'
    ) || ' to "' || v_task.name || '"',
    p_data := jsonb_build_object(
      'task_id',
      NEW.task_id,
      'task_name',
      v_task.name,
      'assigned_user_id',
      NEW.user_id,
      'assigned_user_name',
      COALESCE(
        v_assigned_user.display_name,
        v_assigned_user.handle,
        'Unknown'
      ),
      'board_id',
      v_task_details.board_id,
      'assigned_by',
      auth.uid(),
      'assigned_by_name',
      v_updater_name,
      'action_url',
      '/' || v_task_details.ws_id || '/tasks/' || NEW.task_id
    ),
    p_entity_type := 'task',
    p_entity_id := NEW.task_id,
    p_scope := 'workspace'
  );

END LOOP;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_assignee_added"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_assignee_added"() IS 'Trigger function that creates a task_history entry when a user is assigned to a task, capturing the assignee details including name and avatar URL. Also notifies the assigned user and other existing assignees.';

CREATE
OR REPLACE FUNCTION "public"."notify_task_assignee_removed"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task_details RECORD;

v_user_info RECORD;

v_task_exists BOOLEAN;

BEGIN -- Check if this is being called due to a cascade delete (task being hard deleted)
-- If the task doesn't exist, skip logging as it's being permanently deleted
SELECT
  EXISTS(
    SELECT
      1
    FROM
      public.tasks
    WHERE
      id = OLD.task_id
  ) INTO v_task_exists;

IF NOT v_task_exists THEN RETURN OLD;

END IF;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(OLD.task_id);

IF v_task_details IS NULL
OR v_task_details.board_id IS NULL THEN RETURN OLD;

END IF;

-- Get user info for better display
SELECT
  id,
  display_name,
  avatar_url INTO v_user_info
FROM
  public.users
WHERE
  id = OLD.user_id;

-- Log the assignee removal to task_history (SECURITY DEFINER bypasses RLS)
PERFORM public.insert_task_history(
  OLD.task_id,
  'assignee_removed',
  NULL,
  jsonb_build_object(
    'user_id',
    OLD.user_id,
    'user_name',
    COALESCE(v_user_info.display_name, 'Unknown user'),
    'avatar_url',
    v_user_info.avatar_url
  ),
  NULL,
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'assignee_name',
    COALESCE(v_user_info.display_name, 'Unknown user')
  )
);

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."notify_task_assignee_removed"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_assignee_removed"() IS 'Logs assignee removals to task_history. Skips logging when task is being permanently deleted (cascade delete scenario).';

CREATE
OR REPLACE FUNCTION "public"."notify_task_created"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_board_id UUID;

v_ws_id UUID;

v_list_name TEXT;

BEGIN -- Get the board_id and workspace_id for metadata
SELECT
  tl.board_id,
  wb.ws_id,
  tl.name INTO v_board_id,
  v_ws_id,
  v_list_name
FROM
  public.task_lists tl
  JOIN public.workspace_boards wb ON tl.board_id = wb.id
WHERE
  tl.id = NEW.list_id;

INSERT INTO
  public.task_history (
    task_id,
    changed_by,
    changed_at,
    change_type,
    field_name,
    old_value,
    new_value,
    metadata
  )
VALUES
  (
    NEW.id,
    NEW.creator_id,
    NEW.created_at,
    'task_created',
    NULL,
    NULL,
    to_jsonb(NEW.name),
    jsonb_build_object(
      'description',
      NEW.description,
      'priority',
      NEW.priority,
      'list_id',
      NEW.list_id,
      'list_name',
      v_list_name,
      'board_id',
      v_board_id,
      'workspace_id',
      v_ws_id,
      'estimation_points',
      NEW.estimation_points,
      'start_date',
      NEW.start_date,
      'end_date',
      NEW.end_date
    )
  );

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_created"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_created"() IS 'Trigger function that creates a task_history entry when a new task is created. Captures initial state including name, description, priority, list placement with list_name, estimation_points, start_date, and end_date.';

CREATE
OR REPLACE FUNCTION "public"."notify_task_label_added"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task RECORD;

v_label RECORD;

v_task_details RECORD;

v_assignee_id UUID;

v_updater_name TEXT;

BEGIN -- Only for INSERT operations
IF TG_OP != 'INSERT' THEN RETURN NEW;

END IF;

-- Get task details
SELECT
  * INTO v_task
FROM
  public.tasks
WHERE
  id = NEW.task_id;

IF v_task IS NULL THEN RETURN NEW;

END IF;

-- Get label details (includes color)
SELECT
  * INTO v_label
FROM
  public.workspace_task_labels
WHERE
  id = NEW.label_id;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(NEW.task_id);

-- Get updater name
SELECT
  COALESCE(display_name, handle, 'Unknown') INTO v_updater_name
FROM
  public.users
WHERE
  id = auth.uid();

-- Insert history record with full label info including color
PERFORM public.insert_task_history(
  NEW.task_id,
  'label_added',
  NULL,
  NULL,
  to_jsonb(v_label),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'label_name',
    v_label.name,
    'label_color',
    v_label.color
  )
);

-- Notify all assignees
FOR v_assignee_id IN
SELECT
  user_id
FROM
  public.task_assignees
WHERE
  task_id = NEW.task_id
  AND user_id != COALESCE(
    auth.uid(),
    '00000000-0000-0000-0000-000000000000' :: uuid
  ) LOOP PERFORM public.create_notification(
    p_ws_id := v_task_details.ws_id,
    p_user_id := v_assignee_id,
    p_type := 'task_label_added',
    p_title := 'Label added to task',
    p_description := v_updater_name || ' added label "' || v_label.name || '" to "' || v_task.name || '"',
    p_data := jsonb_build_object(
      'task_id',
      NEW.task_id,
      'task_name',
      v_task.name,
      'label_id',
      NEW.label_id,
      'label_name',
      v_label.name,
      'label_color',
      v_label.color,
      'board_id',
      v_task_details.board_id,
      'updated_by',
      auth.uid(),
      'updated_by_name',
      v_updater_name,
      'action_url',
      '/' || v_task_details.ws_id || '/tasks/' || NEW.task_id
    ),
    p_entity_type := 'task',
    p_entity_id := NEW.task_id,
    p_scope := 'workspace'
  );

END LOOP;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_label_added"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_label_added"() IS 'Enhanced trigger function that tracks label addition with full label details including color in both new_value and metadata.';

CREATE
OR REPLACE FUNCTION "public"."notify_task_label_removed"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task_details RECORD;

v_label_info RECORD;

v_task_exists BOOLEAN;

BEGIN -- Check if this is being called due to a cascade delete (task being hard deleted)
-- If the task doesn't exist, skip logging as it's being permanently deleted
SELECT
  EXISTS(
    SELECT
      1
    FROM
      public.tasks
    WHERE
      id = OLD.task_id
  ) INTO v_task_exists;

IF NOT v_task_exists THEN RETURN OLD;

END IF;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(OLD.task_id);

IF v_task_details IS NULL
OR v_task_details.board_id IS NULL THEN RETURN OLD;

END IF;

-- Get label info for better display
SELECT
  id,
  name,
  color INTO v_label_info
FROM
  public.workspace_task_labels
WHERE
  id = OLD.label_id;

-- Log the label removal to task_history (SECURITY DEFINER bypasses RLS)
PERFORM public.insert_task_history(
  OLD.task_id,
  'label_removed',
  NULL,
  jsonb_build_object(
    'id',
    OLD.label_id,
    'name',
    COALESCE(v_label_info.name, 'Unknown label'),
    'color',
    v_label_info.color
  ),
  NULL,
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'label_name',
    COALESCE(v_label_info.name, 'Unknown label'),
    'label_color',
    v_label_info.color
  )
);

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."notify_task_label_removed"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_label_removed"() IS 'Logs label removals to task_history. Skips logging when task is being permanently deleted (cascade delete scenario).';

CREATE
OR REPLACE FUNCTION "public"."notify_task_project_linked"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public',
  'pg_temp' AS $ $ DECLARE v_task_details RECORD;

v_task RECORD;

v_project_name TEXT;

v_updater_name TEXT;

v_assignee_id UUID;

BEGIN -- Skip if this is a system update
IF auth.uid() IS NULL THEN RETURN NEW;

END IF;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(NEW.task_id);

-- Get updater name
SELECT
  COALESCE(display_name, 'Unknown user') INTO v_updater_name
FROM
  public.users
WHERE
  id = auth.uid();

-- Insert history record
PERFORM public.insert_task_history(
  NEW.task_id,
  'project_linked',
  NULL,
  NULL,
  to_jsonb(NEW.project_id),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

-- Get project name
SELECT
  name INTO v_project_name
FROM
  public.task_projects
WHERE
  id = NEW.project_id;

-- Get task name
SELECT
  name INTO v_task
FROM
  public.tasks
WHERE
  id = NEW.task_id;

-- Notify all assignees except the person who made the change
FOR v_assignee_id IN
SELECT
  user_id
FROM
  public.task_assignees
WHERE
  task_id = NEW.task_id
  AND user_id != auth.uid() LOOP PERFORM public.create_notification(
    p_ws_id := v_task_details.ws_id,
    p_user_id := v_assignee_id,
    p_type := 'task_project_linked',
    p_title := 'Project linked to task',
    p_description := v_updater_name || ' linked project "' || v_project_name || '" to "' || v_task.name || '"',
    p_data := jsonb_build_object(
      'task_id',
      NEW.task_id,
      'task_name',
      v_task.name,
      'project_id',
      NEW.project_id,
      'project_name',
      v_project_name,
      'board_id',
      v_task_details.board_id,
      'updated_by',
      auth.uid(),
      'updated_by_name',
      v_updater_name
    ),
    p_entity_type := 'task',
    p_entity_id := NEW.task_id
  );

END LOOP;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_project_linked"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_project_linked"() IS 'Trigger function for project linking with history tracking';

CREATE
OR REPLACE FUNCTION "public"."notify_task_project_unlinked"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_task_details RECORD;

v_project_info RECORD;

v_task_exists BOOLEAN;

BEGIN -- Check if this is being called due to a cascade delete (task being hard deleted)
-- If the task doesn't exist, skip logging as it's being permanently deleted
SELECT
  EXISTS(
    SELECT
      1
    FROM
      public.tasks
    WHERE
      id = OLD.task_id
  ) INTO v_task_exists;

IF NOT v_task_exists THEN RETURN OLD;

END IF;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(OLD.task_id);

IF v_task_details IS NULL
OR v_task_details.board_id IS NULL THEN RETURN OLD;

END IF;

-- Get project info for better display
SELECT
  id,
  name INTO v_project_info
FROM
  public.task_projects
WHERE
  id = OLD.project_id;

-- Log the project unlink to task_history (SECURITY DEFINER bypasses RLS)
PERFORM public.insert_task_history(
  OLD.task_id,
  'project_unlinked',
  NULL,
  jsonb_build_object(
    'project_id',
    OLD.project_id,
    'project_name',
    COALESCE(v_project_info.name, 'Unknown project')
  ),
  NULL,
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'project_name',
    COALESCE(v_project_info.name, 'Unknown project')
  )
);

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."notify_task_project_unlinked"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_project_unlinked"() IS 'Logs project unlinks to task_history. Skips logging when task is being permanently deleted (cascade delete scenario).';

CREATE
OR REPLACE FUNCTION "public"."notify_task_updated"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_has_changes BOOLEAN := false;

v_changes JSONB := '{}' :: jsonb;

v_notification_type TEXT := 'task_updated';

v_task_details RECORD;

v_updater_name TEXT;

v_assignee_id UUID;

v_skip_embedding_only BOOLEAN := false;

v_old_list_name TEXT;

v_new_list_name TEXT;

v_notification_data JSONB;

BEGIN -- Check if this is ONLY an embedding update (AI background processing)
-- In this case, skip logging to avoid noise from AI operations
IF TG_OP = 'UPDATE'
AND NEW.embedding IS DISTINCT
FROM
  OLD.embedding
  AND NEW.name = OLD.name
  AND NEW.description IS NOT DISTINCT
FROM
  OLD.description
  AND NEW.priority IS NOT DISTINCT
FROM
  OLD.priority
  AND NEW.end_date IS NOT DISTINCT
FROM
  OLD.end_date
  AND NEW.start_date IS NOT DISTINCT
FROM
  OLD.start_date
  AND NEW.estimation_points IS NOT DISTINCT
FROM
  OLD.estimation_points
  AND NEW.list_id IS NOT DISTINCT
FROM
  OLD.list_id
  AND NEW.completed IS NOT DISTINCT
FROM
  OLD.completed
  AND NEW.deleted_at IS NOT DISTINCT
FROM
  OLD.deleted_at THEN -- Only embedding changed, skip logging
  RETURN NEW;

END IF;

-- Note: We no longer skip when auth.uid() is NULL
-- This ensures bulk operations are logged even without user context
-- The changed_by column will be NULL in such cases
IF auth.uid() IS NULL THEN RAISE LOG 'notify_task_updated: auth.uid() is NULL for task %, logging with anonymous user',
NEW.id;

END IF;

-- Get comprehensive task details
SELECT
  * INTO v_task_details
FROM
  public.get_task_details(NEW.id);

-- Get updater name (will be NULL if auth.uid() is NULL)
SELECT
  COALESCE(display_name, 'Unknown user') INTO v_updater_name
FROM
  public.users
WHERE
  id = auth.uid();

-- Default updater name if not found
IF v_updater_name IS NULL THEN v_updater_name := 'System';

END IF;

-- ========================================================================
-- TRACK TITLE/NAME CHANGES
-- ========================================================================
IF OLD.name IS DISTINCT
FROM
  NEW.name THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'name',
  jsonb_build_object('old', OLD.name, 'new', NEW.name)
);

v_notification_type := 'task_title_changed';

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'name',
  to_jsonb(OLD.name),
  to_jsonb(NEW.name),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK DESCRIPTION CHANGES
-- ========================================================================
IF OLD.description IS DISTINCT
FROM
  NEW.description THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'description',
  jsonb_build_object('old', OLD.description, 'new', NEW.description)
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_description_changed';

END IF;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'description',
  to_jsonb(OLD.description),
  to_jsonb(NEW.description),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK PRIORITY CHANGES
-- ========================================================================
IF OLD.priority IS DISTINCT
FROM
  NEW.priority THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'priority',
  jsonb_build_object('old', OLD.priority, 'new', NEW.priority)
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_priority_changed';

END IF;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'priority',
  to_jsonb(OLD.priority),
  to_jsonb(NEW.priority),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK END DATE CHANGES
-- ========================================================================
IF OLD.end_date IS DISTINCT
FROM
  NEW.end_date THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'end_date',
  jsonb_build_object('old', OLD.end_date, 'new', NEW.end_date)
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_due_date_changed';

END IF;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'end_date',
  to_jsonb(OLD.end_date),
  to_jsonb(NEW.end_date),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK START DATE CHANGES
-- ========================================================================
IF OLD.start_date IS DISTINCT
FROM
  NEW.start_date THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'start_date',
  jsonb_build_object('old', OLD.start_date, 'new', NEW.start_date)
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_start_date_changed';

END IF;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'start_date',
  to_jsonb(OLD.start_date),
  to_jsonb(NEW.start_date),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK ESTIMATION CHANGES
-- ========================================================================
IF OLD.estimation_points IS DISTINCT
FROM
  NEW.estimation_points THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'estimation_points',
  jsonb_build_object(
    'old',
    OLD.estimation_points,
    'new',
    NEW.estimation_points
  )
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_estimation_changed';

END IF;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'estimation_points',
  to_jsonb(OLD.estimation_points),
  to_jsonb(NEW.estimation_points),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK LIST_ID CHANGES (with list names in metadata)
-- This tracks when tasks are moved between columns/lists
-- ========================================================================
IF OLD.list_id IS DISTINCT
FROM
  NEW.list_id THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'list_id',
  jsonb_build_object('old', OLD.list_id, 'new', NEW.list_id)
);

IF v_notification_type = 'task_updated' THEN v_notification_type := 'task_moved';

END IF;

-- Lookup list names for better UI display
SELECT
  name INTO v_old_list_name
FROM
  public.task_lists
WHERE
  id = OLD.list_id;

SELECT
  name INTO v_new_list_name
FROM
  public.task_lists
WHERE
  id = NEW.list_id;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'list_id',
  to_jsonb(OLD.list_id),
  to_jsonb(NEW.list_id),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id,
    'old_list_name',
    COALESCE(v_old_list_name, 'Unknown'),
    'new_list_name',
    COALESCE(v_new_list_name, 'Unknown')
  )
);

END IF;

-- ========================================================================
-- TRACK COMPLETION STATUS CHANGES
-- ========================================================================
IF OLD.completed IS DISTINCT
FROM
  NEW.completed THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'completed',
  jsonb_build_object('old', OLD.completed, 'new', NEW.completed)
);

v_notification_type := CASE
  WHEN NEW.completed = true THEN 'task_completed'
  ELSE 'task_reopened'
END;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'completed',
  to_jsonb(OLD.completed),
  to_jsonb(NEW.completed),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- TRACK DELETED_AT CHANGES (for soft delete tracking)
-- This tracks when tasks are soft deleted or restored
-- ========================================================================
IF OLD.deleted_at IS DISTINCT
FROM
  NEW.deleted_at THEN v_has_changes := true;

v_changes := v_changes || jsonb_build_object(
  'deleted_at',
  jsonb_build_object('old', OLD.deleted_at, 'new', NEW.deleted_at)
);

v_notification_type := CASE
  WHEN NEW.deleted_at IS NOT NULL THEN 'task_deleted'
  ELSE 'task_restored'
END;

PERFORM public.insert_task_history(
  NEW.id,
  'field_updated',
  'deleted_at',
  to_jsonb(OLD.deleted_at),
  to_jsonb(NEW.deleted_at),
  jsonb_build_object(
    'ws_id',
    v_task_details.ws_id,
    'board_id',
    v_task_details.board_id
  )
);

END IF;

-- ========================================================================
-- CREATE NOTIFICATIONS FOR ALL ASSIGNEES
-- ========================================================================
IF v_has_changes THEN -- Build notification data with list names if applicable
v_notification_data := jsonb_build_object(
  'task_id',
  NEW.id,
  'task_name',
  NEW.name,
  'changes',
  v_changes,
  'change_type',
  v_notification_type,
  'board_id',
  v_task_details.board_id,
  'updated_by',
  auth.uid(),
  'updated_by_name',
  v_updater_name
);

-- Add list names to notification data if this is a task_moved event
IF v_notification_type = 'task_moved' THEN v_notification_data := v_notification_data || jsonb_build_object(
  'old_list_name',
  COALESCE(v_old_list_name, 'Unknown'),
  'new_list_name',
  COALESCE(v_new_list_name, 'Unknown')
);

END IF;

-- Notify all assignees except the person who made the change
-- Use COALESCE to handle NULL auth.uid()
FOR v_assignee_id IN
SELECT
  user_id
FROM
  public.task_assignees
WHERE
  task_id = NEW.id
  AND user_id != COALESCE(
    auth.uid(),
    '00000000-0000-0000-0000-000000000000' :: uuid
  ) LOOP PERFORM public.create_notification(
    p_ws_id := v_task_details.ws_id,
    p_user_id := v_assignee_id,
    p_email := NULL,
    p_type := v_notification_type,
    p_code := NULL,
    p_title := 'Task updated',
    p_description := v_updater_name || ' updated "' || NEW.name || '"',
    p_data := v_notification_data,
    p_entity_type := 'task',
    p_entity_id := NEW.id,
    p_created_by := auth.uid(),
    p_scope := 'workspace',
    p_priority := 'medium'
  );

END LOOP;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_task_updated"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_task_updated"() IS 'Enhanced trigger function tracking ALL task field changes. Now includes old_list_name and new_list_name in notification data for task_moved events, allowing the UI and emails to display human-readable column names instead of UUIDs.';

CREATE
OR REPLACE FUNCTION "public"."notify_workspace_email_invite"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_workspace_name TEXT;

v_inviter_name TEXT;

v_inviter_email TEXT;

v_notification_id UUID;

BEGIN -- Get workspace details
SELECT
  name INTO v_workspace_name
FROM
  public.workspaces
WHERE
  id = NEW.ws_id;

-- Get inviter name (if available)
IF NEW.invited_by IS NOT NULL THEN -- Get display name from public.users
SELECT
  display_name INTO v_inviter_name
FROM
  public.users
WHERE
  id = NEW.invited_by;

-- Get email from auth.users if display name is null
IF v_inviter_name IS NULL THEN
SELECT
  email INTO v_inviter_email
FROM
  auth.users
WHERE
  id = NEW.invited_by;

v_inviter_name := v_inviter_email;

END IF;

END IF;

-- Create notification for the invitee (email-based, no user_id yet)
-- Note: user-scoped notifications must have ws_id = NULL per constraint
-- Note: role column was removed from workspace_email_invites in migration 20251104101455
v_notification_id := public.create_notification(
  p_ws_id := NULL,
  p_user_id := NULL,
  -- No user_id yet
  p_email := NEW.email,
  p_type := 'workspace_invite',
  p_code := 'workspace_invite',
  p_title := 'You have been invited to join a workspace',
  p_description := COALESCE(v_inviter_name, 'Someone') || ' invited you to join "' || v_workspace_name || '"',
  p_data := jsonb_build_object(
    'workspace_id',
    NEW.ws_id,
    'workspace_name',
    v_workspace_name,
    'inviter_id',
    NEW.invited_by,
    'inviter_name',
    v_inviter_name,
    'email',
    NEW.email -- Removed 'role' reference as column no longer exists
  ),
  p_entity_type := 'workspace_invite',
  p_entity_id := NEW.ws_id,
  p_created_by := NEW.invited_by,
  p_scope := 'user',
  p_priority := 'high'
);

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_workspace_email_invite"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_workspace_email_invite"() IS 'Creates notifications for workspace email invites (pending users)';

CREATE
OR REPLACE FUNCTION "public"."notify_workspace_user_invite"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_workspace_name TEXT;

v_invitee_email TEXT;

v_notification_id UUID;

BEGIN -- Get workspace details
SELECT
  name INTO v_workspace_name
FROM
  public.workspaces
WHERE
  id = NEW.ws_id;

-- Get invitee email
SELECT
  email INTO v_invitee_email
FROM
  auth.users
WHERE
  id = NEW.user_id;

-- Create notification for the invitee
-- Note: workspace_invites table doesn't track who sent the invite (no invited_by column)
-- Note: user-scoped notifications must have ws_id = NULL per constraint
-- Note: role column was removed from workspace_invites in migration 20251104101455
v_notification_id := public.create_notification(
  p_ws_id := NULL,
  p_user_id := NEW.user_id,
  p_email := v_invitee_email,
  p_type := 'workspace_invite',
  p_code := 'workspace_invite',
  p_title := 'You have been invited to join a workspace',
  p_description := 'You have been invited to join "' || v_workspace_name || '"',
  p_data := jsonb_build_object(
    'workspace_id',
    NEW.ws_id,
    'workspace_name',
    v_workspace_name
  ),
  p_entity_type := 'workspace_invite',
  p_entity_id := NEW.ws_id,
  p_created_by := NULL,
  p_scope := 'user',
  p_priority := 'high'
);

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."notify_workspace_user_invite"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."notify_workspace_user_invite"() IS 'Creates notifications for workspace user invites (existing users)';

CREATE
OR REPLACE FUNCTION "public"."nova_get_all_challenges_with_user_stats"("user_id" "uuid") RETURNS "jsonb" LANGUAGE "plpgsql" SECURITY DEFINER AS $ _ $ DECLARE all_challenges jsonb;

challenge_rec RECORD;

challenges_array jsonb := '[]' :: jsonb;

BEGIN -- Iterate through all challenges
FOR challenge_rec IN
SELECT
  nova_challenges.id
FROM
  nova_challenges LOOP -- Get challenge with user stats
  all_challenges := nova_get_challenge_with_user_stats(challenge_rec.id, $ 1);

-- Add to array if not null
IF all_challenges IS NOT NULL THEN challenges_array := challenges_array || all_challenges;

END IF;

END LOOP;

RETURN challenges_array;

END;

$ _ $;

ALTER FUNCTION "public"."nova_get_all_challenges_with_user_stats"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."nova_get_challenge_with_user_stats"("challenge_id" "uuid", "user_id" "uuid") RETURNS "jsonb" LANGUAGE "plpgsql" SECURITY DEFINER AS $ _ $ DECLARE challenge_info jsonb;

total_sessions INTEGER;

daily_sessions INTEGER;

last_session jsonb;

BEGIN -- Get the challenge information
SELECT
  to_jsonb(c) INTO challenge_info
FROM
  nova_challenges c
WHERE
  c.id = $ 1;

-- If challenge doesn't exist, return null
IF challenge_info IS NULL THEN RETURN NULL;

END IF;

-- Get user's total sessions for this challenge
total_sessions := nova_get_user_total_sessions($ 1, $ 2);

-- Get user's daily sessions for this challenge
daily_sessions := nova_get_user_daily_sessions($ 1, $ 2);

-- Get user's last session for this challenge
SELECT
  to_jsonb(s) INTO last_session
FROM
  nova_sessions s
WHERE
  s.challenge_id = $ 1
  AND s.user_id = $ 2
ORDER BY
  s.start_time DESC
LIMIT
  1;

-- Add stats to the challenge info
challenge_info := challenge_info || jsonb_build_object(
  'total_sessions', total_sessions, 'daily_sessions', daily_sessions, 'lastSession', last_session
);

RETURN challenge_info;

END;

$ _ $;

ALTER FUNCTION "public"."nova_get_challenge_with_user_stats"("challenge_id" "uuid", "user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."nova_get_user_daily_sessions"("challenge_id" "uuid", "user_id" "uuid") RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ _ $ DECLARE daily_count INTEGER;

BEGIN
SELECT
  COUNT(*) INTO daily_count
FROM
  nova_sessions
WHERE
  nova_sessions.challenge_id = $ 1
  AND nova_sessions.user_id = $ 2
  AND DATE(nova_sessions.start_time) = CURRENT_DATE;

RETURN daily_count;

END;

$ _ $;

ALTER FUNCTION "public"."nova_get_user_daily_sessions"("challenge_id" "uuid", "user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."nova_get_user_total_sessions"("challenge_id" "uuid", "user_id" "uuid") RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ _ $ DECLARE total_count INTEGER;

BEGIN
SELECT
  COUNT(*) INTO total_count
FROM
  nova_sessions
WHERE
  nova_sessions.challenge_id = $ 1
  AND nova_sessions.user_id = $ 2;

RETURN total_count;

END;

$ _ $;

ALTER FUNCTION "public"."nova_get_user_total_sessions"("challenge_id" "uuid", "user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."on_delete_user"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
UPDATE
  public.users
SET
  deleted = true
WHERE
  id = OLD.id;

DELETE FROM
  public.workspace_members
WHERE
  user_id = OLD.id;

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."on_delete_user"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."parse_user_agent"("user_agent" "text") RETURNS TABLE(
  "device_type" "text",
  "browser" "text",
  "os" "text"
) LANGUAGE "plpgsql" IMMUTABLE AS $ $ BEGIN RETURN QUERY
SELECT
  CASE
    WHEN user_agent ~* 'mobile|android|iphone|ipad|ipod|blackberry|windows phone' THEN 'mobile'
    WHEN user_agent ~* 'tablet|ipad' THEN 'tablet'
    ELSE 'desktop'
  END as device_type,
  CASE
    WHEN user_agent ~* 'chrome' THEN 'Chrome'
    WHEN user_agent ~* 'firefox' THEN 'Firefox'
    WHEN user_agent ~* 'safari' THEN 'Safari'
    WHEN user_agent ~* 'edge' THEN 'Edge'
    WHEN user_agent ~* 'opera' THEN 'Opera'
    ELSE 'Other'
  END as browser,
  CASE
    WHEN user_agent ~* 'windows' THEN 'Windows'
    WHEN user_agent ~* 'macintosh|mac os x' THEN 'macOS'
    WHEN user_agent ~* 'linux' THEN 'Linux'
    WHEN user_agent ~* 'android' THEN 'Android'
    WHEN user_agent ~* 'iphone|ipad|ipod' THEN 'iOS'
    ELSE 'Other'
  END as os;

END;

$ $;

ALTER FUNCTION "public"."parse_user_agent"("user_agent" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."pause_session_for_break"(
  "p_session_id" "uuid",
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE v_session RECORD;

v_result json;

BEGIN -- Set the bypass flag for this transaction
PERFORM set_config('time_tracking.is_break_pause', 'on', true);

-- Update the session
UPDATE
  time_tracking_sessions
SET
  end_time = p_end_time,
  duration_seconds = p_duration_seconds,
  is_running = false,
  updated_at = NOW()
WHERE
  id = p_session_id RETURNING * INTO v_session;

IF NOT FOUND THEN RAISE EXCEPTION 'Session not found';

END IF;

-- Return the updated session as JSON
SELECT
  json_build_object(
    'id',
    v_session.id,
    'ws_id',
    v_session.ws_id,
    'user_id',
    v_session.user_id,
    'title',
    v_session.title,
    'description',
    v_session.description,
    'category_id',
    v_session.category_id,
    'task_id',
    v_session.task_id,
    'start_time',
    v_session.start_time,
    'end_time',
    v_session.end_time,
    'duration_seconds',
    v_session.duration_seconds,
    'is_running',
    v_session.is_running,
    'was_resumed',
    v_session.was_resumed,
    'parent_session_id',
    v_session.parent_session_id,
    'created_at',
    v_session.created_at,
    'updated_at',
    v_session.updated_at
  ) INTO v_result;

RETURN v_result;

END;

$ $;

ALTER FUNCTION "public"."pause_session_for_break"(
  "p_session_id" "uuid",
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."pause_session_for_break"(
  "p_session_id" "uuid",
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer,
  "p_pending_approval" boolean DEFAULT false
) RETURNS json LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ DECLARE v_session RECORD;

v_result json;

BEGIN -- Set the bypass flag for this transaction
PERFORM set_config('time_tracking.is_break_pause', 'on', true);

-- Update the session
UPDATE
  time_tracking_sessions
SET
  end_time = p_end_time,
  duration_seconds = p_duration_seconds,
  is_running = false,
  pending_approval = COALESCE(p_pending_approval, false),
  updated_at = NOW()
WHERE
  id = p_session_id RETURNING * INTO v_session;

IF NOT FOUND THEN RAISE EXCEPTION 'Session not found';

END IF;

-- Return the updated session as JSON
SELECT
  json_build_object(
    'id',
    v_session.id,
    'ws_id',
    v_session.ws_id,
    'user_id',
    v_session.user_id,
    'title',
    v_session.title,
    'description',
    v_session.description,
    'category_id',
    v_session.category_id,
    'task_id',
    v_session.task_id,
    'start_time',
    v_session.start_time,
    'end_time',
    v_session.end_time,
    'duration_seconds',
    v_session.duration_seconds,
    'is_running',
    v_session.is_running,
    'was_resumed',
    v_session.was_resumed,
    'parent_session_id',
    v_session.parent_session_id,
    'pending_approval',
    v_session.pending_approval,
    'created_at',
    v_session.created_at,
    'updated_at',
    v_session.updated_at
  ) INTO v_result;

RETURN v_result;

END;

$ $;

ALTER FUNCTION "public"."pause_session_for_break"(
  "p_session_id" "uuid",
  "p_end_time" timestamp with time zone,
  "p_duration_seconds" integer,
  "p_pending_approval" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."prevent_circular_parent_child"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_current_task_id UUID;

v_depth INT := 0;

v_max_depth INT := 100;

-- Prevent infinite loops
BEGIN -- Only check for parent_child relationships
IF NEW.type != 'parent_child' THEN RETURN NEW;

END IF;

-- Walk up the parent chain from the new parent (source) to check if we encounter the new child (target)
v_current_task_id := NEW.source_task_id;

WHILE v_current_task_id IS NOT NULL
AND v_depth < v_max_depth LOOP -- Check if we've reached the task we're trying to make a child
IF v_current_task_id = NEW.target_task_id THEN RAISE EXCEPTION 'Circular parent-child relationship detected. Task % cannot be a child of task % because it would create a cycle.',
NEW.target_task_id,
NEW.source_task_id;

END IF;

-- Move up to the parent
SELECT
  source_task_id INTO v_current_task_id
FROM
  public.task_relationships
WHERE
  target_task_id = v_current_task_id
  AND type = 'parent_child';

v_depth := v_depth + 1;

END LOOP;

-- Also check if the source is already a descendant of target (walking down)
-- This prevents making a parent out of a child
v_current_task_id := NEW.target_task_id;

v_depth := 0;

-- Use recursive CTE to find all descendants
IF EXISTS (
  WITH RECURSIVE descendants AS (
    -- Base case: direct children of the target
    SELECT
      target_task_id AS task_id
    FROM
      public.task_relationships
    WHERE
      source_task_id = NEW.target_task_id
      AND type = 'parent_child'
    UNION
    ALL -- Recursive case: children of children
    SELECT
      tr.target_task_id
    FROM
      public.task_relationships tr
      INNER JOIN descendants d ON tr.source_task_id = d.task_id
    WHERE
      tr.type = 'parent_child'
  )
  SELECT
    1
  FROM
    descendants
  WHERE
    task_id = NEW.source_task_id
) THEN RAISE EXCEPTION 'Circular parent-child relationship detected. Task % is already a descendant of task %.',
NEW.source_task_id,
NEW.target_task_id;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."prevent_circular_parent_child"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."prevent_personal_workspace_threshold_modification"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER
SET
  "search_path" TO 'public' AS $ $ BEGIN -- Check if the workspace is personal
  IF is_personal_workspace(NEW.ws_id) THEN -- On INSERT: ensure missed_entry_date_threshold is NULL for personal workspaces
  IF TG_OP = 'INSERT' THEN IF NEW.missed_entry_date_threshold IS NOT NULL THEN RAISE EXCEPTION 'Cannot set missed_entry_date_threshold for personal workspaces. This feature is only available for team workspaces.';

END IF;

END IF;

-- On UPDATE: prevent changing missed_entry_date_threshold from NULL to a value
IF TG_OP = 'UPDATE' THEN -- Check if we're trying to set a non-NULL value
IF NEW.missed_entry_date_threshold IS NOT NULL THEN RAISE EXCEPTION 'Cannot set missed_entry_date_threshold for personal workspaces. This feature is only available for team workspaces.';

END IF;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."prevent_personal_workspace_threshold_modification"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."prevent_personal_workspace_threshold_modification"() IS 'Prevents setting missed_entry_date_threshold on personal workspaces. This time tracking restriction feature is only available for team workspaces.';

CREATE
OR REPLACE FUNCTION "public"."process_notification_batches"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_batch RECORD;

v_notification RECORD;

v_notifications JSONB := '[]' :: jsonb;

v_user_email TEXT;

v_user_name TEXT;

v_workspace_name TEXT;

v_workspace_url TEXT;

v_email_body TEXT;

v_notification_count INTEGER;

BEGIN -- Harden search_path to prevent privilege escalation
SET
  LOCAL search_path = pg_temp,
  public;

-- Find all pending batches where window_end has passed
-- Use FOR UPDATE SKIP LOCKED to atomically claim batches and prevent race conditions
FOR v_batch IN
SELECT
  *
FROM
  public.notification_batches
WHERE
  status = 'pending'
  AND window_end <= now()
ORDER BY
  window_end ASC FOR
UPDATE
  SKIP LOCKED LOOP BEGIN -- Mark batch as processing (with status check to ensure we still own it)
UPDATE
  public.notification_batches
SET
  status = 'processing',
  updated_at = now()
WHERE
  id = v_batch.id
  AND status = 'pending';

-- Double-check status hasn't changed
-- Get all pending notifications for this batch
v_notifications := '[]' :: jsonb;

v_notification_count := 0;

FOR v_notification IN
SELECT
  n.*
FROM
  public.notification_delivery_log ndl
  JOIN public.notifications n ON ndl.notification_id = n.id
WHERE
  ndl.batch_id = v_batch.id
  AND ndl.status = 'pending'
  AND ndl.channel = 'email'
ORDER BY
  n.created_at DESC LOOP v_notification_count := v_notification_count + 1;

-- Build notifications array
v_notifications := v_notifications || jsonb_build_object(
  'id',
  v_notification.id,
  'type',
  v_notification.type,
  'title',
  v_notification.title,
  'description',
  v_notification.description,
  'data',
  v_notification.data,
  'created_at',
  v_notification.created_at
);

END LOOP;

-- If no notifications, mark batch as sent and continue
IF v_notification_count = 0 THEN
UPDATE
  public.notification_batches
SET
  status = 'sent',
  sent_at = now(),
  updated_at = now()
WHERE
  id = v_batch.id;

CONTINUE;

END IF;

-- Get user details
SELECT
  email,
  COALESCE(display_name, email) INTO v_user_email,
  v_user_name
FROM
  public.users
WHERE
  id = v_batch.user_id;

-- Get workspace details
SELECT
  name INTO v_workspace_name
FROM
  public.workspaces
WHERE
  id = v_batch.ws_id;

-- Build workspace URL
v_workspace_url := COALESCE(
  current_setting('app.base_url', true),
  'https://tuturuuu.com'
) || '/' || v_batch.ws_id;

-- TODO: Send actual email here
-- This is a placeholder - integrate with your email sending service
-- Example: Call a function that sends email via your email provider
-- PERFORM public.send_email_digest(
--   v_user_email,
--   v_user_name,
--   v_workspace_name,
--   v_notifications,
--   v_workspace_url
-- );
-- For now, just log that we would send an email
RAISE NOTICE 'Would send email to % with % notifications',
v_user_email,
v_notification_count;

-- Mark all delivery logs as sent
UPDATE
  public.notification_delivery_log
SET
  status = 'sent',
  sent_at = now(),
  updated_at = now()
WHERE
  batch_id = v_batch.id
  AND status = 'pending';

-- Mark batch as sent
UPDATE
  public.notification_batches
SET
  status = 'sent',
  sent_at = now(),
  notification_count = v_notification_count,
  updated_at = now()
WHERE
  id = v_batch.id;

EXCEPTION
WHEN OTHERS THEN -- Mark batch as failed
UPDATE
  public.notification_batches
SET
  status = 'failed',
  error_message = SQLERRM,
  updated_at = now()
WHERE
  id = v_batch.id;

-- Mark delivery logs as failed
UPDATE
  public.notification_delivery_log
SET
  status = 'failed',
  error_message = SQLERRM,
  retry_count = retry_count + 1,
  updated_at = now()
WHERE
  batch_id = v_batch.id
  AND status = 'pending';

RAISE WARNING 'Failed to process batch %: %',
v_batch.id,
SQLERRM;

END;

END LOOP;

END;

$ $;

ALTER FUNCTION "public"."process_notification_batches"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."process_notification_batches"() IS '[DEPRECATED] This function is no longer used. Email sending now happens via the API route /api/cron/process-notification-batches which should be called by an external cron service or Trigger.dev.

To set up email notifications:

1. Add CRON_SECRET to your .env.local file
2. Configure AWS SES credentials in workspace_email_credentials table (root workspace)
3. Set up one of the following:

   Option A - External Cron (Recommended for production):
   - Use a service like cron-job.org, EasyCron, or your hosting provider
   - Schedule POST requests to: https://your-domain.com/api/cron/process-notification-batches
   - Include header: Authorization: Bearer YOUR_CRON_SECRET
   - Run every 2-5 minutes

   Option B - Trigger.dev (Recommended for development):
   - Create a scheduled task in packages/trigger/src/send-notification-emails.ts
   - Configure it to call the API route every 2-5 minutes

   Option C - Vercel Cron (If deployed on Vercel):
   - Add to vercel.json:
     {
       "crons": [{
         "path": "/api/cron/process-notification-batches",
         "schedule": "*/2 * * * *"
       }]
     }

The API route will:
- Fetch pending notification batches from the database
- Render email templates using React Email
- Send emails via AWS SES
- Update batch status in the database
';

CREATE
OR REPLACE FUNCTION "public"."process_recurring_transactions"() RETURNS TABLE(
  "recurring_id" "uuid",
  "transaction_id" "uuid",
  "processed_count" integer
) LANGUAGE "plpgsql" AS $ $ DECLARE rec_record RECORD;

new_transaction_id UUID;

transactions_processed INT := 0;

BEGIN -- Find all active recurring transactions that are due
FOR rec_record IN
SELECT
  *
FROM
  recurring_transactions
WHERE
  is_active = true
  AND next_occurrence <= CURRENT_DATE
  AND (
    end_date IS NULL
    OR next_occurrence <= end_date
  ) LOOP -- Create the transaction
INSERT INTO
  wallet_transactions (
    wallet_id,
    amount,
    description,
    category_id,
    taken_at,
    report_opt_in
  )
VALUES
  (
    rec_record.wallet_id,
    rec_record.amount,
    COALESCE(rec_record.description, rec_record.name),
    rec_record.category_id,
    rec_record.next_occurrence,
    true
  ) RETURNING id INTO new_transaction_id;

-- Update the recurring transaction
UPDATE
  recurring_transactions
SET
  last_occurrence = next_occurrence,
  next_occurrence = calculate_next_occurrence(next_occurrence, frequency),
  updated_at = now()
WHERE
  id = rec_record.id;

transactions_processed := transactions_processed + 1;

RETURN QUERY
SELECT
  rec_record.id,
  new_transaction_id,
  transactions_processed;

END LOOP;

-- Deactivate recurring transactions that have passed their end date
UPDATE
  recurring_transactions
SET
  is_active = false,
  updated_at = now()
WHERE
  is_active = true
  AND end_date IS NOT NULL
  AND next_occurrence > end_date;

END;

$ $;

ALTER FUNCTION "public"."process_recurring_transactions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."record_email_bounce"(
  "p_email_hash" "text",
  "p_bounce_type" "text",
  "p_bounce_subtype" "text" DEFAULT NULL :: "text",
  "p_original_email_id" "uuid" DEFAULT NULL :: "uuid",
  "p_raw_notification" "jsonb" DEFAULT NULL :: "jsonb"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_id UUID;

BEGIN
INSERT INTO
  public.email_bounce_complaints (
    email_hash,
    event_type,
    bounce_type,
    bounce_subtype,
    original_email_id,
    raw_notification
  )
VALUES
  (
    p_email_hash,
    'bounce',
    p_bounce_type,
    p_bounce_subtype,
    p_original_email_id,
    p_raw_notification
  ) RETURNING id INTO v_id;

RETURN v_id;

END;

$ $;

ALTER FUNCTION "public"."record_email_bounce"(
  "p_email_hash" "text",
  "p_bounce_type" "text",
  "p_bounce_subtype" "text",
  "p_original_email_id" "uuid",
  "p_raw_notification" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."record_email_complaint"(
  "p_email_hash" "text",
  "p_complaint_type" "text" DEFAULT NULL :: "text",
  "p_complaint_feedback_id" "text" DEFAULT NULL :: "text",
  "p_original_email_id" "uuid" DEFAULT NULL :: "uuid",
  "p_raw_notification" "jsonb" DEFAULT NULL :: "jsonb"
) RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_id UUID;

BEGIN
INSERT INTO
  public.email_bounce_complaints (
    email_hash,
    event_type,
    complaint_type,
    complaint_feedback_id,
    original_email_id,
    raw_notification
  )
VALUES
  (
    p_email_hash,
    'complaint',
    p_complaint_type,
    p_complaint_feedback_id,
    p_original_email_id,
    p_raw_notification
  ) RETURNING id INTO v_id;

RETURN v_id;

END;

$ $;

ALTER FUNCTION "public"."record_email_complaint"(
  "p_email_hash" "text",
  "p_complaint_type" "text",
  "p_complaint_feedback_id" "text",
  "p_original_email_id" "uuid",
  "p_raw_notification" "jsonb"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."redirect_platform_email_roles_insert"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE user_id_var uuid;

BEGIN -- Check if email exists in user_private_details
SELECT
  upd.user_id INTO user_id_var
FROM
  public.user_private_details upd
WHERE
  upd.email = NEW.email;

-- If email exists in user_private_details
IF user_id_var IS NOT NULL THEN -- Add or update the user in platform_user_roles instead
INSERT INTO
  public.platform_user_roles(
    user_id,
    enabled,
    allow_challenge_management,
    allow_manage_all_challenges,
    allow_role_management
  )
VALUES
  (
    user_id_var,
    NEW.enabled,
    NEW.allow_challenge_management,
    NEW.allow_manage_all_challenges,
    NEW.allow_role_management
  ) ON CONFLICT (user_id) DO
UPDATE
SET
  enabled = NEW.enabled,
  allow_challenge_management = NEW.allow_challenge_management,
  allow_manage_all_challenges = NEW.allow_manage_all_challenges,
  allow_role_management = NEW.allow_role_management;

-- Skip the insert to platform_email_roles
RETURN NULL;

END IF;

-- If email doesn't exist in user_private_details, proceed with normal insert
RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."redirect_platform_email_roles_insert"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."refresh_posts_dashboard_view"() RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN REFRESH MATERIALIZED VIEW CONCURRENTLY posts_dashboard_view;

END;

$ $;

ALTER FUNCTION "public"."refresh_posts_dashboard_view"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."revoke_all_cross_app_tokens"("p_user_id" "uuid") RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN
UPDATE
  public.cross_app_tokens
SET
  is_revoked = true
WHERE
  user_id = p_user_id
  AND is_revoked = false;

END;

$ $;

ALTER FUNCTION "public"."revoke_all_cross_app_tokens"("p_user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."revoke_all_other_sessions"("user_id" "uuid") RETURNS integer LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE current_session_id text;

revoked_count integer;

BEGIN -- Check if user is revoking their own sessions
IF auth.uid() != user_id THEN RAISE EXCEPTION 'Unauthorized access to sessions';

END IF;

-- Get current session ID from JWT
current_session_id := auth.jwt() ->> 'session_id';

-- Delete all sessions except current
DELETE FROM
  auth.sessions
WHERE
  user_id = revoke_all_other_sessions.user_id
  AND (
    current_session_id IS NULL
    OR current_session_id = ''
    OR id :: text != current_session_id
  );

GET DIAGNOSTICS revoked_count = ROW_COUNT;

RETURN revoked_count;

END;

$ $;

ALTER FUNCTION "public"."revoke_all_other_sessions"("user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."revoke_user_session"("target_user_id" "uuid", "session_id" "text") RETURNS boolean LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE session_found boolean := false;

BEGIN -- Check if user is revoking their own session
IF auth.uid() != target_user_id THEN RAISE EXCEPTION 'Unauthorized access to sessions';

END IF;

-- Check if session exists and belongs to user
SELECT
  EXISTS(
    SELECT
      1
    FROM
      auth.sessions
    WHERE
      id = session_id :: uuid
      AND user_id = target_user_id
  ) INTO session_found;

IF NOT session_found THEN RAISE EXCEPTION 'Session not found or unauthorized';

END IF;

-- Delete the session
DELETE FROM
  auth.sessions
WHERE
  id = session_id :: uuid
  AND user_id = target_user_id;

RETURN true;

END;

$ $;

ALTER FUNCTION "public"."revoke_user_session"("target_user_id" "uuid", "session_id" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."search_users"(
  "search_query" "text",
  "page_number" integer,
  "page_size" integer,
  "role_filter" "text" DEFAULT NULL :: "text",
  "enabled_filter" boolean DEFAULT NULL :: boolean
) RETURNS TABLE(
  "id" "uuid",
  "display_name" "text",
  "deleted" boolean,
  "avatar_url" "text",
  "handle" "text",
  "bio" "text",
  "created_at" timestamp with time zone,
  "user_id" "uuid",
  "enabled" boolean,
  "allow_challenge_management" boolean,
  "allow_manage_all_challenges" boolean,
  "allow_role_management" boolean,
  "email" "text",
  "new_email" "text",
  "birthday" "date",
  "full_name" "text",
  "team_name" "text" []
) LANGUAGE "plpgsql" AS $ _ $ DECLARE where_clause TEXT := '';

BEGIN -- Base where condition
where_clause := 'u.display_name ILIKE ''%'' || $1 || ''%'' OR ud.email ILIKE ''%'' || $1 || ''%''';

-- Add role filter if provided
IF role_filter IS NOT NULL THEN CASE
  role_filter
  WHEN 'admin' THEN where_clause := where_clause || ' AND ur.allow_role_management = true';

WHEN 'global_manager' THEN where_clause := where_clause || ' AND ur.allow_manage_all_challenges = true';

WHEN 'challenge_manager' THEN where_clause := where_clause || ' AND ur.allow_challenge_management = true';

WHEN 'member' THEN where_clause := where_clause || ' AND ur.allow_challenge_management = false AND ur.allow_manage_all_challenges = false AND ur.allow_role_management = false';

ELSE -- No additional filter for 'all' or other values
END CASE
;

END IF;

-- Add enabled filter if provided
IF enabled_filter IS NOT NULL THEN where_clause := where_clause || ' AND ur.enabled = ' || enabled_filter :: TEXT;

END IF;

-- Execute dynamic query
RETURN QUERY EXECUTE '
    SELECT 
      -- User columns
      u.id,
      u.display_name,
      u.deleted,
      u.avatar_url,
      u.handle,
      u.bio,
      u.created_at,
      
      -- PlatformUser columns
      ur.user_id,
      ur.enabled,
      ur.allow_challenge_management,
      ur.allow_manage_all_challenges,
      ur.allow_role_management,
      
      -- UserPrivateDetails columns
      ud.email,
      ud.new_email,
      ud.birthday,
      ud.full_name,
      
      -- Team names
      ARRAY_REMOVE(ARRAY_AGG(DISTINCT t.name), NULL) as team_name
      
    FROM platform_user_roles ur
    JOIN users u ON ur.user_id = u.id
    JOIN user_private_details ud ON u.id = ud.user_id
    LEFT JOIN nova_team_members tm ON u.id = tm.user_id
    LEFT JOIN nova_teams t ON tm.team_id = t.id
    
    WHERE ' || where_clause || '
    
    GROUP BY 
      u.id,
      u.display_name,
      u.deleted,
      u.avatar_url,
      u.handle,
      u.bio,
      u.created_at,
      ur.user_id,
      ur.enabled,
      ur.allow_challenge_management,
      ur.allow_manage_all_challenges,
      ur.allow_role_management,
      ud.email,
      ud.new_email,
      ud.birthday,
      ud.full_name
    ORDER BY u.created_at DESC
    LIMIT $2
    OFFSET ($3 - 1) * $2
  ' USING search_query,
page_size,
page_number;

END;

$ _ $;

ALTER FUNCTION "public"."search_users"(
  "search_query" "text",
  "page_number" integer,
  "page_size" integer,
  "role_filter" "text",
  "enabled_filter" boolean
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."search_users_by_name"(
  "search_query" "text",
  "result_limit" integer DEFAULT 5,
  "min_similarity" double precision DEFAULT 0.3
) RETURNS TABLE(
  "id" "uuid",
  "handle" "text",
  "display_name" "text",
  "avatar_url" "text",
  "relevance" double precision
) LANGUAGE "plpgsql" AS $ $ BEGIN RETURN QUERY
SELECT
  u.id,
  u.handle,
  u.display_name,
  u.avatar_url,
  GREATEST(
    similarity(u.handle, search_query),
    similarity(u.display_name, search_query)
  ) :: double precision AS relevance
FROM
  users u
WHERE
  u.deleted = false
  AND (
    similarity(u.handle, search_query) >= min_similarity
    OR similarity(u.display_name, search_query) >= min_similarity
  )
ORDER BY
  GREATEST(
    similarity(u.handle, search_query),
    similarity(u.display_name, search_query)
  ) DESC,
  u.created_at
LIMIT
  result_limit;

END;

$ $;

ALTER FUNCTION "public"."search_users_by_name"(
  "search_query" "text",
  "result_limit" integer,
  "min_similarity" double precision
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_analytics_metadata"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE parsed_ua RECORD;

BEGIN -- Set referrer domain (existing functionality)
NEW.referrer_domain := extract_referrer_domain(NEW.referrer);

-- Parse user agent to extract device info
IF NEW.user_agent IS NOT NULL THEN
SELECT
  * INTO parsed_ua
FROM
  parse_user_agent(NEW.user_agent);

NEW.device_type := parsed_ua.device_type;

NEW.browser := parsed_ua.browser;

NEW.os := parsed_ua.os;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."set_analytics_metadata"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_default_break_type"("p_ws_id" "uuid", "p_target_id" "uuid") RETURNS TABLE(
  "id" "uuid",
  "ws_id" "uuid",
  "name" "text",
  "description" "text",
  "color" "text",
  "icon" "text",
  "is_default" boolean,
  "created_at" timestamp with time zone
) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- First, unset all other defaults in this workspace
UPDATE
  workspace_break_types
SET
  is_default = false
WHERE
  workspace_break_types.ws_id = p_ws_id
  AND workspace_break_types.id != p_target_id;

-- Then, set the target as default and return it
RETURN QUERY
UPDATE
  workspace_break_types
SET
  is_default = true
WHERE
  workspace_break_types.ws_id = p_ws_id
  AND workspace_break_types.id = p_target_id RETURNING workspace_break_types.id,
  workspace_break_types.ws_id,
  workspace_break_types.name,
  workspace_break_types.description,
  workspace_break_types.color,
  workspace_break_types.icon,
  workspace_break_types.is_default,
  workspace_break_types.created_at;

END;

$ $;

ALTER FUNCTION "public"."set_default_break_type"("p_ws_id" "uuid", "p_target_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_first_workspace_as_default"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Check if user already has a default workspace
IF NOT EXISTS (
  SELECT
    1
  FROM
    user_private_details
  WHERE
    user_id = NEW.user_id
    AND default_workspace_id IS NOT NULL
) THEN -- Set this workspace as the user's default
UPDATE
  user_private_details
SET
  default_workspace_id = NEW.ws_id
WHERE
  user_id = NEW.user_id;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."set_first_workspace_as_default"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_referrer_domain"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.referrer_domain := extract_referrer_domain(NEW.referrer);

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."set_referrer_domain"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_shortened_links_domain"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ _ $ BEGIN NEW.domain := regexp_replace(
  regexp_replace(NEW.link, '^https?://|^//', ''),
  '/.*$',
  ''
);

RETURN NEW;

END;

$ _ $;

ALTER FUNCTION "public"."set_shortened_links_domain"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."set_task_timestamps"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE new_list_status TEXT;

BEGIN -- Get the status of the new list
IF NEW.list_id IS NOT NULL THEN
SELECT
  status INTO new_list_status
FROM
  task_lists
WHERE
  id = NEW.list_id;

-- Handle different list statuses
CASE
  new_list_status
  WHEN 'done' THEN -- Task moved to done list: set completed_at, clear closed_at
  IF NEW.completed_at IS NULL THEN NEW.completed_at = NOW();

END IF;

NEW.closed_at = NULL;

WHEN 'closed' THEN -- Task moved to closed list: set closed_at, clear completed_at
IF NEW.closed_at IS NULL THEN NEW.closed_at = NOW();

END IF;

NEW.completed_at = NULL;

WHEN 'active',
'not_started' THEN -- Task moved to active/not_started list: clear both timestamps
NEW.completed_at = NULL;

NEW.closed_at = NULL;

ELSE -- Unknown status: clear both timestamps to be safe
NEW.completed_at = NULL;

NEW.closed_at = NULL;

END CASE
;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."set_task_timestamps"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."should_send_notification"(
  "p_user_id" "uuid",
  "p_event_type" "text",
  "p_channel" "text",
  "p_scope" "public"."notification_scope" DEFAULT 'workspace' :: "public"."notification_scope",
  "p_ws_id" "uuid" DEFAULT NULL :: "uuid"
) RETURNS boolean LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_preference BOOLEAN;

BEGIN -- Check for workspace-specific preference first
IF p_scope = 'workspace'
AND p_ws_id IS NOT NULL THEN
SELECT
  enabled INTO v_preference
FROM
  public.notification_preferences
WHERE
  user_id = p_user_id
  AND ws_id = p_ws_id
  AND event_type = p_event_type
  AND channel = p_channel
  AND scope = 'workspace';

END IF;

-- Fall back to user-level preference if no workspace preference
IF v_preference IS NULL THEN
SELECT
  enabled INTO v_preference
FROM
  public.notification_preferences
WHERE
  user_id = p_user_id
  AND ws_id IS NULL
  AND event_type = p_event_type
  AND channel = p_channel
  AND scope IN ('user', 'system');

END IF;

-- Default to enabled if no preference found
RETURN COALESCE(v_preference, true);

END;

$ $;

ALTER FUNCTION "public"."should_send_notification"(
  "p_user_id" "uuid",
  "p_event_type" "text",
  "p_channel" "text",
  "p_scope" "public"."notification_scope",
  "p_ws_id" "uuid"
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."should_send_notification"(
  "p_user_id" "uuid",
  "p_event_type" "text",
  "p_channel" "text",
  "p_scope" "public"."notification_scope",
  "p_ws_id" "uuid"
) IS 'Checks if a notification should be sent based on user preferences, including workspace/user scope and quiet hours';

CREATE
OR REPLACE FUNCTION "public"."stop_other_running_sessions"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN -- If this session is being set to running, stop all other running sessions for this user in this workspace
IF NEW.is_running = true THEN
UPDATE
  time_tracking_sessions
SET
  is_running = false,
  end_time = COALESCE(end_time, NOW()),
  updated_at = NOW()
WHERE
  ws_id = NEW.ws_id
  AND user_id = NEW.user_id
  AND id != NEW.id
  AND is_running = true;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."stop_other_running_sessions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."store_task_metadata_before_delete"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_board_id UUID;

v_ws_id UUID;

v_board_name TEXT;

v_list_name TEXT;

BEGIN -- Get the board_id, workspace_id, and names for metadata
SELECT
  tl.board_id,
  wb.ws_id,
  wb.name,
  tl.name INTO v_board_id,
  v_ws_id,
  v_board_name,
  v_list_name
FROM
  public.task_lists tl
  JOIN public.workspace_boards wb ON tl.board_id = wb.id
WHERE
  tl.id = OLD.list_id;

-- Update all history entries for this task to include task metadata
-- This ensures the history is still meaningful after task deletion
UPDATE
  public.task_history
SET
  metadata = metadata || jsonb_build_object(
    'task_name',
    OLD.name,
    'board_id',
    v_board_id,
    'board_name',
    v_board_name,
    'workspace_id',
    v_ws_id,
    'list_id',
    OLD.list_id,
    'list_name',
    v_list_name
  )
WHERE
  task_id = OLD.id
  AND (
    metadata ->> 'task_name' IS NULL
    OR metadata ->> 'task_name' = ''
  );

RETURN OLD;

END;

$ $;

ALTER FUNCTION "public"."store_task_metadata_before_delete"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."store_task_metadata_before_delete"() IS 'Stores task metadata in task_history entries before a task is permanently deleted, ensuring history context is preserved.';

CREATE
OR REPLACE FUNCTION "public"."sum_quiz_scores"("p_set_id" "uuid") RETURNS TABLE("sum" numeric) LANGUAGE "sql" AS $ $
SELECT
  COALESCE(SUM(wq.score), 0) :: numeric
FROM
  quiz_set_quizzes qsq
  JOIN workspace_quizzes wq ON qsq.quiz_id = wq.id
WHERE
  qsq.set_id = p_set_id;

$ $;

ALTER FUNCTION "public"."sum_quiz_scores"("p_set_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."sync_invoice_transaction"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE new_transaction_id uuid;

begin if (TG_OP = 'INSERT') then
INSERT INTO
  public.wallet_transactions (
    amount,
    description,
    wallet_id,
    invoice_id,
    category_id,
    creator_id,
    created_at,
    taken_at
  )
VALUES
  (
    NEW.price + NEW.total_diff,
    NEW.notice,
    NEW.wallet_id,
    NEW.id,
    NEW.category_id,
    NEW.creator_id,
    NEW.created_at,
    NEW.created_at
  ) RETURNING id INTO new_transaction_id;

UPDATE
  public.finance_invoices
SET
  transaction_id = new_transaction_id
WHERE
  id = NEW.id;

elsif (TG_OP = 'UPDATE') then
UPDATE
  public.wallet_transactions
SET
  amount = NEW.price + NEW.total_diff,
  description = NEW.notice,
  wallet_id = NEW.wallet_id,
  category_id = NEW.category_id,
  creator_id = NEW.creator_id,
  created_at = NEW.created_at
WHERE
  id = NEW.transaction_id;

elsif (TG_OP = 'DELETE') then
DELETE FROM
  public.wallet_transactions
WHERE
  id = OLD.transaction_id;

end if;

RETURN NEW;

end;

$ $;

ALTER FUNCTION "public"."sync_invoice_transaction"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."sync_my_notifications"() RETURNS TABLE("updated_count" integer) LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_count INTEGER;

BEGIN -- Update notifications matching the current user's email
WITH updated AS (
  UPDATE
    public.notifications
  SET
    user_id = auth.uid()
  WHERE
    email = public.get_user_email(auth.uid())
    AND (
      user_id IS NULL
      OR user_id != auth.uid()
    ) RETURNING id
)
SELECT
  COUNT(*) :: INTEGER INTO v_count
FROM
  updated;

RETURN QUERY
SELECT
  v_count;

END;

$ $;

ALTER FUNCTION "public"."sync_my_notifications"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."sync_my_notifications"() IS 'Syncs email-based notifications to the current user. Call this if you are not seeing workspace invites that were sent to your email address.';

CREATE
OR REPLACE FUNCTION "public"."sync_transfer_transactions"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE opposite_id uuid;

is_from boolean;

report_opt_in_value boolean;

BEGIN IF TG_OP = 'UPDATE' THEN
SELECT
  CASE
    WHEN wtt.from_transaction_id = OLD.id THEN wtt.to_transaction_id
    WHEN wtt.to_transaction_id = OLD.id THEN wtt.from_transaction_id
    ELSE NULL
  END INTO opposite_id
FROM
  public.workspace_wallet_transfers wtt
WHERE
  wtt.from_transaction_id = OLD.id
  OR wtt.to_transaction_id = OLD.id
LIMIT
  1;

IF opposite_id IS NOT NULL THEN
SELECT
  report_opt_in INTO report_opt_in_value
FROM
  public.wallet_transactions
WHERE
  id = NEW.id;

UPDATE
  public.wallet_transactions wt
SET
  amount = ABS(NEW.amount),
  report_opt_in = report_opt_in_value
WHERE
  wt.id = opposite_id
  AND (
    wt.amount <> ABS(NEW.amount)
    OR wt.report_opt_in <> report_opt_in_value
  );

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."sync_transfer_transactions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."sync_user_details"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE BEGIN IF (TG_OP = 'INSERT') THEN
INSERT INTO
  public.users (id)
VALUES
  (NEW.id);

INSERT INTO
  public.user_private_details (user_id, email, new_email)
VALUES
  (NEW.id, NEW.email, NEW.email_change);

ELSIF (NEW.email <> OLD.email) THEN
UPDATE
  public.user_private_details
SET
  email = NEW.email
WHERE
  user_id = NEW.id;

END IF;

IF (NEW.email_change <> OLD.email_change) THEN
UPDATE
  public.user_private_details
SET
  new_email = NEW.email_change
WHERE
  user_id = NEW.id;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."sync_user_details"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."sync_user_private_details"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN IF (TG_OP = 'INSERT') THEN
INSERT INTO
  public.user_private_details (user_id, email, new_email)
VALUES
  (NEW.id, NEW.email, NEW.email_change);

ELSIF (
  NEW.email <> OLD.email
  OR NEW.email_change <> OLD.email_change
) THEN
UPDATE
  public.user_private_details
SET
  email = NEW.email,
  new_email = NEW.email_change
WHERE
  user_id = NEW.id;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."sync_user_private_details"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."transactions_have_same_abs_amount"(
  "transaction_id_1" "uuid",
  "transaction_id_2" "uuid"
) RETURNS boolean LANGUAGE "sql" AS $ $
SELECT
  ABS(t1.amount) = ABS(t2.amount)
FROM
  wallet_transactions t1,
  wallet_transactions t2
WHERE
  t1.id = transaction_id_1
  AND t2.id = transaction_id_2 $ $;

ALTER FUNCTION "public"."transactions_have_same_abs_amount"(
  "transaction_id_1" "uuid",
  "transaction_id_2" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."transactions_have_same_amount"(
  "transaction_id_1" "uuid",
  "transaction_id_2" "uuid"
) RETURNS boolean LANGUAGE "sql" AS $ $
SELECT
  t1.amount = t2.amount
FROM
  wallet_transactions t1,
  wallet_transactions t2
WHERE
  t1.id = transaction_id_1
  AND t2.id = transaction_id_2 $ $;

ALTER FUNCTION "public"."transactions_have_same_amount"(
  "transaction_id_1" "uuid",
  "transaction_id_2" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."trigger_cleanup_expired_cross_app_tokens"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN PERFORM public.cleanup_expired_cross_app_tokens();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."trigger_cleanup_expired_cross_app_tokens"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."trigger_immediate_notification_send"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_app_url TEXT;

v_service_key TEXT;

BEGIN -- Only trigger for immediate delivery mode batches
IF NEW.delivery_mode != 'immediate' THEN RETURN NEW;

END IF;

-- Get app URL from settings or use default
v_app_url := COALESCE(
  current_setting('app.base_url', true),
  'https://tuturuuu.com'
);

-- Get service role key for authorization
-- Note: This should be set via Supabase Vault or environment variable
v_service_key := COALESCE(
  current_setting('app.service_role_key', true),
  ''
);

-- Only make the HTTP call if we have pg_net extension and service key
IF v_service_key != '' THEN -- Queue the HTTP request to send the immediate notification
-- pg_net.http_post is non-blocking and won't slow down the insert
PERFORM net.http_post(
  url := v_app_url || '/api/notifications/send-immediate',
  headers := jsonb_build_object(
    'Content-Type',
    'application/json',
    'Authorization',
    'Bearer ' || v_service_key
  ),
  body := jsonb_build_object('batch_id', NEW.id)
);

END IF;

RETURN NEW;

EXCEPTION
WHEN OTHERS THEN -- Log error but don't fail the insert
-- The cron job will pick up any missed immediate notifications
RAISE WARNING 'Failed to trigger immediate notification send: %',
SQLERRM;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."trigger_immediate_notification_send"() OWNER TO "postgres";

COMMENT ON FUNCTION "public"."trigger_immediate_notification_send"() IS 'Trigger function that calls the immediate notification API endpoint via pg_net when an immediate batch is created';

CREATE
OR REPLACE FUNCTION "public"."trigger_refresh_posts_dashboard_view"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ BEGIN -- Use pg_notify to signal that a refresh is needed
-- A background worker can listen and batch refresh requests
PERFORM pg_notify('posts_dashboard_refresh', 'refresh_needed');

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."trigger_refresh_posts_dashboard_view"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_budget_spent"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ DECLARE budget_record RECORD;

BEGIN -- Find all active budgets that might be affected
FOR budget_record IN
SELECT
  fb.id,
  fb.start_date,
  fb.end_date,
  fb.category_id,
  fb.wallet_id
FROM
  finance_budgets fb
  JOIN workspace_wallets ww ON (
    fb.wallet_id IS NULL
    OR fb.wallet_id = ww.id
  )
WHERE
  fb.is_active = true
  AND ww.ws_id = (
    SELECT
      ws_id
    FROM
      workspace_wallets
    WHERE
      id = COALESCE(NEW.wallet_id, OLD.wallet_id)
  ) LOOP -- Calculate spent amount for this budget
UPDATE
  finance_budgets
SET
  spent = (
    SELECT
      COALESCE(ABS(SUM(wt.amount)), 0)
    FROM
      wallet_transactions wt
    WHERE
      wt.amount < 0 -- Only expenses
      AND wt.taken_at :: date >= budget_record.start_date
      AND (
        budget_record.end_date IS NULL
        OR wt.taken_at :: date <= budget_record.end_date
      )
      AND (
        budget_record.category_id IS NULL
        OR wt.category_id = budget_record.category_id
      )
      AND (
        budget_record.wallet_id IS NULL
        OR wt.wallet_id = budget_record.wallet_id
      )
  ),
  updated_at = now()
WHERE
  id = budget_record.id;

END LOOP;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_budget_spent"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_calendar_connections_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin new.updated_at = now();

return new;

end;

$ $;

ALTER FUNCTION "public"."update_calendar_connections_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_chat_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_chat_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_email_audit_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_email_audit_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_expired_sessions"() RETURNS "void" LANGUAGE "plpgsql" AS $ $ BEGIN WITH expiration_time AS (
  SELECT
    ns.id,
    CASE
      WHEN nc.close_at IS NULL THEN ns.start_time + (nc.duration * interval '1 second')
      ELSE LEAST(
        ns.start_time + (nc.duration * interval '1 second'),
        nc.close_at
      )
    END AS exp_time
  FROM
    nova_sessions ns
    JOIN nova_challenges nc ON ns.challenge_id = nc.id
  WHERE
    ns.end_time IS NULL
    AND ns.status != 'ENDED'
)
UPDATE
  nova_sessions ns
SET
  end_time = et.exp_time,
  status = 'ENDED'
FROM
  expiration_time et
WHERE
  ns.id = et.id
  AND et.exp_time <= now();

END;

$ $;

ALTER FUNCTION "public"."update_expired_sessions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_inventory_product_amount"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF (TG_OP = 'INSERT') THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount + NEW.amount
WHERE
  ip.product_id = NEW.product_id
  AND ip.unit_id = NEW.unit_id
  AND ip.warehouse_id = (
    SELECT
      warehouse_id
    FROM
      inventory_batches ib
    WHERE
      ib.id = NEW.batch_id
  );

ELSIF (TG_OP = 'UPDATE') THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount - OLD.amount + NEW.amount
WHERE
  ip.product_id = NEW.product_id
  AND ip.unit_id = NEW.unit_id
  AND ip.warehouse_id = (
    SELECT
      warehouse_id
    FROM
      inventory_batches ib
    WHERE
      ib.id = NEW.batch_id
  );

ELSIF (TG_OP = 'DELETE') THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount - OLD.amount
WHERE
  ip.product_id = OLD.product_id
  AND ip.unit_id = OLD.unit_id
  AND ip.warehouse_id = (
    SELECT
      warehouse_id
    FROM
      inventory_batches ib
    WHERE
      ib.id = OLD.batch_id
  );

END IF;

RETURN NULL;

END;

$ $;

ALTER FUNCTION "public"."update_inventory_product_amount"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_inventory_products_from_invoice"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF TG_OP = 'INSERT' THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount - NEW.amount
WHERE
  ip.product_id = NEW.product_id
  AND ip.unit_id = NEW.unit_id
  AND ip.warehouse_id = NEW.warehouse_id;

ELSIF TG_OP = 'UPDATE' THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount - NEW.amount + OLD.amount
WHERE
  ip.product_id = NEW.product_id
  AND ip.unit_id = NEW.unit_id
  AND ip.warehouse_id = NEW.warehouse_id;

ELSIF TG_OP = 'DELETE' THEN
UPDATE
  inventory_products ip
SET
  amount = ip.amount + OLD.amount
WHERE
  ip.product_id = OLD.product_id
  AND ip.unit_id = OLD.unit_id
  AND ip.warehouse_id = OLD.warehouse_id;

END IF;

RETURN NULL;

END;

$ $;

ALTER FUNCTION "public"."update_inventory_products_from_invoice"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_invoice_products_warehouse"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF (
  TG_OP = 'INSERT'
  OR TG_OP = 'UPDATE'
) THEN NEW.warehouse = COALESCE(
  (
    SELECT
      name
    FROM
      inventory_warehouses
    WHERE
      id = NEW.warehouse_id
  ),
  OLD.warehouse
);

RETURN NEW;

ELSIF (TG_OP = 'DELETE') THEN RETURN OLD;

END IF;

END;

$ $;

ALTER FUNCTION "public"."update_invoice_products_warehouse"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_many_tasks"("updates" "jsonb") RETURNS integer LANGUAGE "plpgsql" AS $ $ DECLARE rec jsonb;

updated_count integer := 0;

rows_affected integer;

BEGIN BEGIN FOR rec IN
SELECT
  *
FROM
  jsonb_array_elements(updates) LOOP IF rec ->> 'id' IS NULL THEN RAISE EXCEPTION 'Missing required field: id';

END IF;

UPDATE
  public.tasks
SET
  priority = COALESCE((rec ->> 'priority') :: integer, priority),
  archived = COALESCE((rec ->> 'archived') :: boolean, archived),
  tags = COALESCE(
    CASE
      WHEN jsonb_typeof(rec -> 'tags') = 'array' THEN ARRAY(
        SELECT
          jsonb_array_elements_text(rec -> 'tags')
      )
      ELSE tags
    END,
    tags
  )
WHERE
  id = (rec ->> 'id') :: uuid;

GET DIAGNOSTICS rows_affected = ROW_COUNT;

updated_count := updated_count + rows_affected;

END LOOP;

RETURN updated_count;

EXCEPTION
WHEN OTHERS THEN RAISE EXCEPTION 'Batch update failed: %',
SQLERRM;

END;

END;

$ $;

ALTER FUNCTION "public"."update_many_tasks"("updates" "jsonb") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_notification_batches_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_notification_batches_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_notification_delivery_log_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_notification_delivery_log_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_notification_email_config_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_notification_email_config_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_notification_preferences_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_notification_preferences_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_productivity_score"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN -- Only calculate for completed sessions
IF NEW.duration_seconds IS NOT NULL
AND NEW.category_id IS NOT NULL THEN NEW.productivity_score := calculate_productivity_score(
  NEW.duration_seconds,
  (
    SELECT
      color
    FROM
      time_tracking_categories
    WHERE
      id = NEW.category_id
  )
);

ELSE NEW.productivity_score := 0;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_productivity_score"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_session_duration"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN -- Calculate duration if end_time is set and start_time exists
IF NEW.end_time IS NOT NULL
AND NEW.start_time IS NOT NULL THEN NEW.duration_seconds = EXTRACT(
  EPOCH
  FROM
    (NEW.end_time - NEW.start_time)
) :: integer;

NEW.is_running = false;

ELSIF NEW.end_time IS NULL
AND OLD.end_time IS NOT NULL THEN -- If end_time is being cleared, clear duration and set running
NEW.duration_seconds = NULL;

NEW.is_running = true;

END IF;

-- Update timestamp
NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_session_duration"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_session_total_score"(
  "challenge_id_param" "uuid",
  "user_id_param" "uuid"
) RETURNS "void" LANGUAGE "plpgsql" AS $ $ DECLARE new_total_score INTEGER;

BEGIN
SELECT
  COALESCE(SUM(max_score), 0) INTO new_total_score
FROM
  (
    SELECT
      MAX(score) as max_score
    FROM
      nova_submissions
    WHERE
      user_id = user_id_param
    GROUP BY
      problem_id
  ) as max_scores;

UPDATE
  nova_sessions
SET
  total_score = new_total_score
WHERE
  challenge_id = challenge_id_param
  AND user_id = user_id_param;

END;

$ $;

ALTER FUNCTION "public"."update_session_total_score"(
  "challenge_id_param" "uuid",
  "user_id_param" "uuid"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_task_calendar_events_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_task_calendar_events_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_time_tracking_breaks_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin new.updated_at = now();

return new;

end;

$ $;

ALTER FUNCTION "public"."update_time_tracking_breaks_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_time_tracking_request"(
  "p_request_id" "uuid",
  "p_action" "text",
  "p_workspace_id" "uuid",
  "p_bypass_rules" boolean DEFAULT false,
  "p_rejection_reason" "text" DEFAULT NULL :: "text"
) RETURNS "jsonb" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ declare v_request record;

v_session_id uuid;

v_duration_seconds integer;

begin -- Get the current request and validate workspace
select
  * into v_request
from
  time_tracking_requests
where
  id = p_request_id
  and workspace_id = p_workspace_id
  and workspace_id in (
    select
      ws_id
    from
      workspace_members
    where
      user_id = auth.uid()
  );

if not found then raise exception 'Time tracking request not found';

end if;

-- Check if already processed
if v_request.approval_status <> 'PENDING' then raise exception 'Request has already been %',
lower(v_request.approval_status);

end if;

if p_action = 'approve' then if not p_bypass_rules then -- Enforce that the approver is not the request owner
if v_request.user_id = auth.uid() then raise exception 'Request owner cannot approve their own request';

end if;

end if;

perform set_config(
  'time_tracking.bypass_approval_rules',
  'on',
  true
);

-- Calculate duration
v_duration_seconds := extract(
  epoch
  from
    (v_request.end_time - v_request.start_time)
) :: integer;

-- Set bypass flag to allow creating session with approved request data
perform set_config('time_tracking.bypass_insert_limit', 'on', true);

-- If request has a linked_session_id, update that session instead of creating a new one
if v_request.linked_session_id IS NOT NULL then -- Session already exists (was paused with break), just update it
-- The trigger on time_tracking_requests will clear pending_approval
v_session_id := v_request.linked_session_id;

else -- No linked session, create a new one
insert into
  time_tracking_sessions (
    ws_id,
    user_id,
    title,
    description,
    category_id,
    task_id,
    start_time,
    end_time,
    duration_seconds
  )
values
  (
    v_request.workspace_id,
    v_request.user_id,
    v_request.title,
    v_request.description,
    v_request.category_id,
    v_request.task_id,
    v_request.start_time,
    v_request.end_time,
    v_duration_seconds
  ) returning id into v_session_id;

end if;

-- Update the request
update
  time_tracking_requests
set
  approval_status = 'APPROVED',
  approved_by = auth.uid(),
  approved_at = now(),
  updated_at = now()
where
  id = p_request_id;

return jsonb_build_object(
  'success',
  true,
  'message',
  'Request approved and time tracking session created',
  'session_id',
  v_session_id
);

elsif p_action = 'reject' then if p_rejection_reason is null
or trim(p_rejection_reason) = '' then raise exception 'Rejection reason is required';

end if;

if not p_bypass_rules then -- Enforce that the approver is not the request owner
if v_request.user_id = auth.uid() then raise exception 'Request owner cannot reject their own request';

end if;

end if;

perform set_config(
  'time_tracking.bypass_approval_rules',
  'on',
  true
);

-- Update the request
update
  time_tracking_requests
set
  approval_status = 'REJECTED',
  rejected_by = auth.uid(),
  rejected_at = now(),
  rejection_reason = p_rejection_reason,
  updated_at = now()
where
  id = p_request_id;

return jsonb_build_object(
  'success',
  true,
  'message',
  'Request rejected'
);

else raise exception 'Invalid action. Must be "approve" or "reject"';

end if;

end;

$ $;

ALTER FUNCTION "public"."update_time_tracking_request"(
  "p_request_id" "uuid",
  "p_action" "text",
  "p_workspace_id" "uuid",
  "p_bypass_rules" boolean,
  "p_rejection_reason" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_time_tracking_session_bypassed"(
  "session_id" "uuid",
  "new_start_time" timestamp with time zone,
  "new_end_time" timestamp with time zone,
  "new_notes" "text"
) RETURNS "public"."time_tracking_sessions" LANGUAGE "plpgsql" AS $ $ DECLARE updated_row time_tracking_sessions;

BEGIN -- 1. Set the bypass flag
PERFORM set_config('time_tracking.bypass_update_limit', 'on', true);

-- 2. Execute the update, which will now ignore the trigger
UPDATE
  time_tracking_sessions
SET
  start_time = new_start_time,
  end_time = new_end_time,
  notes = new_notes
WHERE
  id = session_id RETURNING * INTO updated_row;

-- 3. Unset the bypass flag (optional but good practice)
PERFORM set_config('time_tracking.bypass_update_limit', 'off', true);

RETURN updated_row;

END;

$ $;

ALTER FUNCTION "public"."update_time_tracking_session_bypassed"(
  "session_id" "uuid",
  "new_start_time" timestamp with time zone,
  "new_end_time" timestamp with time zone,
  "new_notes" "text"
) OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_transaction_amount"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF EXISTS (
  SELECT
    1
  FROM
    public.workspace_wallet_transfers wtt
  WHERE
    wtt.from_transaction_id = NEW.id
)
AND NEW.amount > 0 THEN NEW.amount = - NEW.amount;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_transaction_amount"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_wallet_balance"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF TG_OP = 'INSERT' THEN
UPDATE
  workspace_wallets
SET
  balance = balance + NEW.amount
WHERE
  id = NEW.wallet_id;

ELSIF TG_OP = 'UPDATE' THEN IF OLD.wallet_id = NEW.wallet_id THEN
UPDATE
  workspace_wallets
SET
  balance = balance - OLD.amount + NEW.amount
WHERE
  id = OLD.wallet_id;

ELSE
UPDATE
  workspace_wallets
SET
  balance = balance - OLD.amount
WHERE
  id = OLD.wallet_id;

UPDATE
  workspace_wallets
SET
  balance = balance + NEW.amount
WHERE
  id = NEW.wallet_id;

END IF;

ELSIF TG_OP = 'DELETE' THEN
UPDATE
  workspace_wallets
SET
  balance = balance - OLD.amount
WHERE
  id = OLD.wallet_id;

END IF;

RETURN NULL;

END;

$ $;

ALTER FUNCTION "public"."update_wallet_balance"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_wallet_transaction_amount"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF (TG_OP = 'UPDATE') THEN IF (
  (NEW.price + NEW.total_diff) <> (OLD.price + OLD.total_diff)
) THEN
UPDATE
  public.wallet_transactions
SET
  amount = CASE
    WHEN tc.is_expense THEN -(NEW.price + NEW.total_diff)
    ELSE (NEW.price + NEW.total_diff)
  END
FROM
  public.transaction_categories tc
WHERE
  tc.id = wallet_transactions.category_id
  AND wallet_transactions.id = NEW.transaction_id;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_wallet_transaction_amount"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_wallet_transactions"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN IF (OLD.is_expense <> NEW.is_expense) THEN IF (NEW.is_expense = true) THEN
UPDATE
  public.wallet_transactions
SET
  amount = - amount
WHERE
  category_id = NEW.id
  AND amount > 0;

UPDATE
  public.wallet_transactions
SET
  amount = amount
WHERE
  category_id = NEW.id
  AND amount < 0;

ELSE
UPDATE
  public.wallet_transactions
SET
  amount = - amount
WHERE
  category_id = NEW.id
  AND amount < 0;

UPDATE
  public.wallet_transactions
SET
  amount = amount
WHERE
  category_id = NEW.id
  AND amount > 0;

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_wallet_transactions"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_api_keys_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_api_keys_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_break_types_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ begin new.updated_at = now();

return new;

end;

$ $;

ALTER FUNCTION "public"."update_workspace_break_types_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_calendar_categories_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_calendar_categories_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_calendar_sync_coordination_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_calendar_sync_coordination_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_education_access_requests_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = NOW();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_education_access_requests_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_encryption_keys_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_encryption_keys_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."update_workspace_invite_links_updated_at"() RETURNS "trigger" LANGUAGE "plpgsql" AS $ $ BEGIN NEW.updated_at = now();

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."update_workspace_invite_links_updated_at"() OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."upsert_calendar_events_and_count"("events" "jsonb") RETURNS "jsonb" LANGUAGE "sql" AS $ _ $ with upserted as (
  insert into
    public.workspace_calendar_events (
      ws_id,
      google_event_id,
      google_calendar_id,
      title,
      description,
      start_at,
      end_at,
      location,
      color,
      locked,
      task_id,
      is_encrypted
    )
  select
    (event ->> 'ws_id') :: uuid,
    event ->> 'google_event_id',
    event ->> 'google_calendar_id',
    coalesce(event ->> 'title', ''),
    coalesce(event ->> 'description', ''),
    (event ->> 'start_at') :: timestamptz,
    (event ->> 'end_at') :: timestamptz,
    event ->> 'location',
    event ->> 'color',
    coalesce((event ->> 'locked') :: boolean, false),
    case
      when event ->> 'task_id' is not null
      and event ->> 'task_id' != '' then (event ->> 'task_id') :: uuid
      else null
    end,
    coalesce((event ->> 'is_encrypted') :: boolean, false)
  from
    jsonb_array_elements(events) as event
  where
    event ->> 'ws_id' is not null
    and event ->> 'google_event_id' is not null
    and event ->> 'start_at' is not null
    and event ->> 'end_at' is not null
    and (event ->> 'ws_id') :: text ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
    and length(event ->> 'google_event_id') > 0
    and (event ->> 'start_at') :: timestamptz < (event ->> 'end_at') :: timestamptz on conflict (ws_id, google_event_id) do
  update
  set
    google_calendar_id = excluded.google_calendar_id,
    -- For encrypted events: preserve encrypted fields, only update non-sensitive data
    -- For non-encrypted events: update all fields normally
    -- CASE: If existing event is encrypted AND incoming is_encrypted is false (default/plaintext from Google),
    --       preserve the existing encrypted title/description/location
    title = case
      when workspace_calendar_events.is_encrypted = true
      and excluded.is_encrypted = false then workspace_calendar_events.title
      else excluded.title
    end,
    description = case
      when workspace_calendar_events.is_encrypted = true
      and excluded.is_encrypted = false then workspace_calendar_events.description
      else excluded.description
    end,
    location = case
      when workspace_calendar_events.is_encrypted = true
      and excluded.is_encrypted = false then workspace_calendar_events.location
      else excluded.location
    end,
    -- Always update time/color/locked (not encrypted)
    start_at = excluded.start_at,
    end_at = excluded.end_at,
    color = excluded.color,
    locked = excluded.locked,
    task_id = excluded.task_id,
    -- NEVER downgrade from encrypted to unencrypted
    -- Only upgrade to encrypted if incoming explicitly says so
    is_encrypted = case
      when workspace_calendar_events.is_encrypted = true then true
      else excluded.is_encrypted
    end returning xmax
)
select
  jsonb_build_object(
    'inserted',
    count(*) filter (
      where
        xmax = 0
    ),
    'updated',
    count(*) filter (
      where
        xmax != 0
    )
  )
from
  upserted;

$ _ $;

ALTER FUNCTION "public"."upsert_calendar_events_and_count"("events" "jsonb") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."upsert_realtime_log_aggregations"("p_logs" "jsonb") RETURNS "void" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE log_item jsonb;

BEGIN -- Iterate through each log in the array
FOR log_item IN
SELECT
  jsonb_array_elements(p_logs) LOOP
INSERT INTO
  public.realtime_log_aggregations (
    ws_id,
    user_id,
    channel_id,
    time_bucket,
    kind,
    total_count,
    error_count,
    sample_messages
  )
VALUES
  (
    (log_item ->> 'ws_id') :: uuid,
    (log_item ->> 'user_id') :: uuid,
    (log_item ->> 'channel_id') :: text,
    (log_item ->> 'time_bucket') :: timestamptz,
    (log_item ->> 'kind') :: text,
    (log_item ->> 'total_count') :: integer,
    (log_item ->> 'error_count') :: integer,
    ARRAY(
      SELECT
        jsonb_array_elements_text(log_item -> 'sample_messages')
    )
  ) ON CONFLICT (ws_id, user_id, channel_id, time_bucket, kind) DO
UPDATE
SET
  total_count = realtime_log_aggregations.total_count + (log_item ->> 'total_count') :: integer,
  error_count = realtime_log_aggregations.error_count + (log_item ->> 'error_count') :: integer,
  sample_messages = ARRAY(
    SELECT
      jsonb_array_elements_text(log_item -> 'sample_messages')
  );

END LOOP;

END;

$ $;

ALTER FUNCTION "public"."upsert_realtime_log_aggregations"("p_logs" "jsonb") OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_scheduling_metadata" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "last_scheduled_at" timestamp with time zone,
  "last_status" "text",
  "last_message" "text",
  "habits_scheduled" integer DEFAULT 0,
  "tasks_scheduled" integer DEFAULT 0,
  "events_created" integer DEFAULT 0,
  "bumped_habits" integer DEFAULT 0,
  "window_days" integer DEFAULT 30,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_scheduling_metadata" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_scheduling_metadata" IS 'Tracks unified scheduling runs for each workspace';

COMMENT ON COLUMN "public"."workspace_scheduling_metadata"."last_status" IS 'Status of last schedule run: success, partial (some items failed), or failed';

COMMENT ON COLUMN "public"."workspace_scheduling_metadata"."bumped_habits" IS 'Number of habit events that were bumped by urgent tasks';

CREATE
OR REPLACE FUNCTION "public"."upsert_scheduling_metadata"(
  "p_ws_id" "uuid",
  "p_status" "text",
  "p_message" "text",
  "p_habits_scheduled" integer,
  "p_tasks_scheduled" integer,
  "p_events_created" integer,
  "p_bumped_habits" integer,
  "p_window_days" integer DEFAULT 30
) RETURNS "public"."workspace_scheduling_metadata" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE result workspace_scheduling_metadata;

BEGIN
INSERT INTO
  workspace_scheduling_metadata (
    ws_id,
    last_scheduled_at,
    last_status,
    last_message,
    habits_scheduled,
    tasks_scheduled,
    events_created,
    bumped_habits,
    window_days
  )
VALUES
  (
    p_ws_id,
    NOW(),
    p_status,
    p_message,
    p_habits_scheduled,
    p_tasks_scheduled,
    p_events_created,
    p_bumped_habits,
    p_window_days
  ) ON CONFLICT (ws_id) DO
UPDATE
SET
  last_scheduled_at = NOW(),
  last_status = EXCLUDED.last_status,
  last_message = EXCLUDED.last_message,
  habits_scheduled = EXCLUDED.habits_scheduled,
  tasks_scheduled = EXCLUDED.tasks_scheduled,
  events_created = EXCLUDED.events_created,
  bumped_habits = EXCLUDED.bumped_habits,
  window_days = EXCLUDED.window_days,
  updated_at = NOW() RETURNING * INTO result;

RETURN result;

END;

$ $;

ALTER FUNCTION "public"."upsert_scheduling_metadata"(
  "p_ws_id" "uuid",
  "p_status" "text",
  "p_message" "text",
  "p_habits_scheduled" integer,
  "p_tasks_scheduled" integer,
  "p_events_created" integer,
  "p_bumped_habits" integer,
  "p_window_days" integer
) OWNER TO "postgres";

COMMENT ON FUNCTION "public"."upsert_scheduling_metadata"(
  "p_ws_id" "uuid",
  "p_status" "text",
  "p_message" "text",
  "p_habits_scheduled" integer,
  "p_tasks_scheduled" integer,
  "p_events_created" integer,
  "p_bumped_habits" integer,
  "p_window_days" integer
) IS 'Updates or inserts scheduling metadata after a scheduling run';

CREATE
OR REPLACE FUNCTION "public"."user_is_in_channel"("p_channel_id" "uuid", "p_user_id" "uuid") RETURNS boolean LANGUAGE "sql" STABLE SECURITY DEFINER AS $ $
SELECT
  EXISTS (
    SELECT
      1
    FROM
      public.workspace_chat_participants
    WHERE
      channel_id = p_channel_id
      AND user_id = p_user_id
  );

$ $;

ALTER FUNCTION "public"."user_is_in_channel"("p_channel_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."validate_cross_app_token"("p_token" "text", "p_target_app" "text") RETURNS "uuid" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_result RECORD;

BEGIN -- Use the new function but only return the user_id to maintain compatibility
SELECT
  * INTO v_result
FROM
  validate_cross_app_token_with_session(p_token, p_target_app);

RETURN v_result.user_id;

END;

$ $;

ALTER FUNCTION "public"."validate_cross_app_token"("p_token" "text", "p_target_app" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."validate_cross_app_token_with_session"("p_token" "text", "p_target_app" "text") RETURNS TABLE("user_id" "uuid", "session_data" "jsonb") LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_record RECORD;

v_required_service platform_service;

v_user_services platform_service [];

BEGIN -- Find the token and get the user_id, session_data, and origin_app if it's valid
SELECT
  t.user_id,
  t.session_data,
  t.origin_app INTO v_record
FROM
  public.cross_app_tokens t
WHERE
  t.token = p_token
  AND t.target_app = p_target_app
  AND t.expires_at > now()
  AND t.used_at IS NULL
  AND t.is_revoked = false;

-- Log the found record for debugging
RAISE NOTICE 'Found token record: user_id=%, session_data=%, origin_app=%',
v_record.user_id,
v_record.session_data,
v_record.origin_app;

-- If the token is valid, check additional permissions for service access
IF v_record.user_id IS NOT NULL THEN -- If origin app is web, check that user has the required service for the target app
IF v_record.origin_app = 'web' THEN -- Map target app to required platform service
CASE
  p_target_app
  WHEN 'platform' THEN v_required_service := 'TUTURUUU';

WHEN 'rewise' THEN v_required_service := 'REWISE';

WHEN 'nova' THEN v_required_service := 'NOVA';

WHEN 'upskii' THEN v_required_service := 'UPSKII';

ELSE v_required_service := NULL;

END CASE
;

-- Get user's services
SELECT
  COALESCE(services, '{}' :: platform_service []) INTO v_user_services
FROM
  public.users
WHERE
  id = v_record.user_id;

-- Add the required service if user doesn't have it yet
IF v_required_service IS NOT NULL
AND NOT (v_required_service = ANY(v_user_services)) THEN RAISE NOTICE 'Adding missing service % for user % accessing target app %',
v_required_service,
v_record.user_id,
p_target_app;

-- Add the service to the user's services array
UPDATE
  public.users
SET
  services = array_append(services, v_required_service)
WHERE
  id = v_record.user_id;

END IF;

END IF;

-- Mark token as used
UPDATE
  public.cross_app_tokens
SET
  used_at = now()
WHERE
  token = p_token;

-- Return the user_id and session_data
RETURN QUERY
SELECT
  v_record.user_id,
  v_record.session_data;

ELSE -- Return NULL if token is invalid
RETURN QUERY
SELECT
  NULL :: UUID,
  NULL :: JSONB;

END IF;

END;

$ $;

ALTER FUNCTION "public"."validate_cross_app_token_with_session"("p_token" "text", "p_target_app" "text") OWNER TO "postgres";

CREATE
OR REPLACE FUNCTION "public"."validate_task_relationship_scope"() RETURNS "trigger" LANGUAGE "plpgsql" SECURITY DEFINER AS $ $ DECLARE v_source_board_id UUID;

v_target_board_id UUID;

v_source_ws_id UUID;

v_target_ws_id UUID;

BEGIN -- Get board_id for both tasks
SELECT
  board_id INTO v_source_board_id
FROM
  public.tasks
WHERE
  id = NEW.source_task_id;

SELECT
  board_id INTO v_target_board_id
FROM
  public.tasks
WHERE
  id = NEW.target_task_id;

-- If both tasks have board_ids, verify they're in the same workspace
IF v_source_board_id IS NOT NULL
AND v_target_board_id IS NOT NULL THEN
SELECT
  ws_id INTO v_source_ws_id
FROM
  public.workspace_boards
WHERE
  id = v_source_board_id;

SELECT
  ws_id INTO v_target_ws_id
FROM
  public.workspace_boards
WHERE
  id = v_target_board_id;

IF v_source_ws_id != v_target_ws_id THEN RAISE EXCEPTION 'Task relationships can only be created between tasks in the same workspace.';

END IF;

END IF;

RETURN NEW;

END;

$ $;

ALTER FUNCTION "public"."validate_task_relationship_scope"() OWNER TO "postgres";

CREATE TEXT SEARCH CONFIGURATION "public"."vietnamese_config" (PARSER = "pg_catalog"."default");

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "asciiword" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "word" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "numword" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "email" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "url" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "host" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "sfloat" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "version" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "hword_numpart" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "hword_part" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "hword_asciipart" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "numhword" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "asciihword" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "hword" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "url_path" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "file" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "float" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "int" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config"
ADD
  MAPPING FOR "uint" WITH "simple";

ALTER TEXT SEARCH CONFIGURATION "public"."vietnamese_config" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "audit"."record_version" (
  "id" bigint NOT NULL,
  "record_id" "uuid",
  "old_record_id" "uuid",
  "op" "audit"."operation" NOT NULL,
  "ts" timestamp with time zone DEFAULT "now"() NOT NULL,
  "table_oid" "oid" NOT NULL,
  "table_schema" "name" NOT NULL,
  "table_name" "name" NOT NULL,
  "record" "jsonb",
  "old_record" "jsonb",
  "auth_uid" "uuid" DEFAULT "auth"."uid"(),
  "auth_role" "text" DEFAULT "auth"."role"(),
  CONSTRAINT "record_version_check" CHECK (
    (
      (
        COALESCE("record_id", "old_record_id") IS NOT NULL
      )
      OR ("op" = 'TRUNCATE' :: "audit"."operation")
    )
  ),
  CONSTRAINT "record_version_check1" CHECK (
    (
      (
        "op" = ANY (
          ARRAY ['INSERT'::"audit"."operation", 'UPDATE'::"audit"."operation"]
        )
      ) = ("record_id" IS NOT NULL)
    )
  ),
  CONSTRAINT "record_version_check2" CHECK (
    (
      (
        "op" = ANY (
          ARRAY ['INSERT'::"audit"."operation", 'UPDATE'::"audit"."operation"]
        )
      ) = ("record" IS NOT NULL)
    )
  ),
  CONSTRAINT "record_version_check3" CHECK (
    (
      (
        "op" = ANY (
          ARRAY ['UPDATE'::"audit"."operation", 'DELETE'::"audit"."operation"]
        )
      ) = ("old_record_id" IS NOT NULL)
    )
  ),
  CONSTRAINT "record_version_check4" CHECK (
    (
      (
        "op" = ANY (
          ARRAY ['UPDATE'::"audit"."operation", 'DELETE'::"audit"."operation"]
        )
      ) = ("old_record" IS NOT NULL)
    )
  )
);

ALTER TABLE
  "audit"."record_version" OWNER TO "postgres";

CREATE SEQUENCE IF NOT EXISTS "audit"."record_version_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;

ALTER SEQUENCE "audit"."record_version_id_seq" OWNER TO "postgres";

ALTER SEQUENCE "audit"."record_version_id_seq" OWNED BY "audit"."record_version"."id";

CREATE TABLE IF NOT EXISTS "public"."abuse_events" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ip_address" "text" NOT NULL,
  "event_type" "public"."abuse_event_type" NOT NULL,
  "email_hash" "text",
  "user_agent" "text",
  "endpoint" "text",
  "success" boolean DEFAULT false NOT NULL,
  "metadata" "jsonb" DEFAULT '{}' :: "jsonb",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."abuse_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."abuse_events" IS 'Audit log of abuse-related events for security monitoring';

CREATE TABLE IF NOT EXISTS "public"."ai_chat_members" (
  "chat_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "email" "text" NOT NULL
);

ALTER TABLE
  "public"."ai_chat_members" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_chat_messages" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "chat_id" "uuid" NOT NULL,
  "content" "text",
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "role" "public"."chat_role" NOT NULL,
  "model" "text",
  "completion_tokens" integer DEFAULT 0 NOT NULL,
  "finish_reason" "text",
  "prompt_tokens" integer DEFAULT 0 NOT NULL,
  "type" "public"."ai_message_type" DEFAULT 'message' :: "public"."ai_message_type" NOT NULL,
  "metadata" "jsonb"
);

ALTER TABLE
  "public"."ai_chat_messages" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_chats" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "title" "text" DEFAULT '' :: "text",
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "model" "text",
  "is_public" boolean DEFAULT false NOT NULL,
  "latest_summarized_message_id" "uuid",
  "summary" "text",
  "pinned" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."ai_chats" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_models" (
  "id" "text" NOT NULL,
  "provider" "text",
  "name" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "enabled" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."ai_models" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_providers" (
  "id" "text" NOT NULL,
  "name" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."ai_providers" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_whitelisted_domains" (
  "domain" "text" NOT NULL,
  "description" "text",
  "enabled" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."ai_whitelisted_domains" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_whitelisted_emails" (
  "email" "text" NOT NULL,
  "enabled" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."ai_whitelisted_emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."audio_chunks" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "session_id" "uuid" NOT NULL,
  "chunk_order" integer NOT NULL,
  "storage_path" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."audio_chunks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_members" (
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "sort_key" smallint
);

ALTER TABLE
  "public"."workspace_members" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."audit_logs" AS
SELECT
  "id",
  "table_name",
  "record_id",
  "old_record_id",
  "op",
  "ts",
  "record",
  "old_record",
  "auth_role",
  "auth_uid",
  COALESCE(
    "audit"."get_ws_id"(("table_name") :: "text", "record"),
    "audit"."get_ws_id"(("table_name") :: "text", "old_record")
  ) AS "ws_id"
FROM
  "audit"."record_version" "audit_log"
WHERE
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wm"
      WHERE
        (
          (
            (
              "wm"."ws_id" = "audit"."get_ws_id"(
                ("audit_log"."table_name") :: "text",
                "audit_log"."record"
              )
            )
            OR (
              "wm"."ws_id" = "audit"."get_ws_id"(
                ("audit_log"."table_name") :: "text",
                "audit_log"."old_record"
              )
            )
          )
          AND (
            ("auth"."uid"() IS NULL)
            OR ("wm"."user_id" = "auth"."uid"())
          )
        )
    )
  )
ORDER BY
  "ts" DESC;

ALTER VIEW "public"."audit_logs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."aurora_ml_forecast" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "date" "date" NOT NULL,
  "elasticnet" real NOT NULL,
  "lightgbm" real NOT NULL,
  "xgboost" real NOT NULL,
  "catboost" real NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."aurora_ml_forecast" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."aurora_ml_metrics" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "model" "text" NOT NULL,
  "rmse" real NOT NULL,
  "directional_accuracy" real NOT NULL,
  "turning_point_accuracy" real NOT NULL,
  "weighted_score" real NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."aurora_ml_metrics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."aurora_statistical_forecast" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "date" "date" NOT NULL,
  "auto_arima" real NOT NULL,
  "auto_arima_lo_90" real NOT NULL,
  "auto_arima_hi_90" real NOT NULL,
  "auto_ets" real NOT NULL,
  "auto_ets_lo_90" real NOT NULL,
  "auto_ets_hi_90" real NOT NULL,
  "auto_theta" real NOT NULL,
  "auto_theta_lo_90" real NOT NULL,
  "auto_theta_hi_90" real NOT NULL,
  "ces" real NOT NULL,
  "ces_lo_90" real NOT NULL,
  "ces_hi_90" real NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."aurora_statistical_forecast" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."aurora_statistical_metrics" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "model" "text" NOT NULL,
  "rmse" real NOT NULL,
  "directional_accuracy" real NOT NULL,
  "turning_point_accuracy" real NOT NULL,
  "weighted_score" real NOT NULL,
  "no_scaling" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."aurora_statistical_metrics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."blocked_ips" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ip_address" "text" NOT NULL,
  "reason" "public"."abuse_event_type" NOT NULL,
  "block_level" integer DEFAULT 1 NOT NULL,
  "status" "public"."ip_block_status" DEFAULT 'active' :: "public"."ip_block_status" NOT NULL,
  "blocked_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "expires_at" timestamp with time zone NOT NULL,
  "unblocked_at" timestamp with time zone,
  "unblocked_by" "uuid",
  "unblock_reason" "text",
  "metadata" "jsonb" DEFAULT '{}' :: "jsonb",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."blocked_ips" OWNER TO "postgres";

COMMENT ON TABLE "public"."blocked_ips" IS 'Tracks blocked IP addresses with progressive block durations for abuse prevention';

CREATE TABLE IF NOT EXISTS "public"."calendar_auth_tokens" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "access_token" "text" NOT NULL,
  "refresh_token" "text" NOT NULL,
  "created_at" timestamp without time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "provider" "text" DEFAULT 'google' :: "text" NOT NULL,
  "account_email" "text",
  "account_name" "text",
  "expires_at" timestamp with time zone,
  "is_active" boolean DEFAULT true NOT NULL,
  CONSTRAINT "calendar_auth_tokens_provider_check" CHECK (
    (
      "provider" = ANY (ARRAY ['google'::"text", 'microsoft'::"text"])
    )
  )
);

ALTER TABLE
  "public"."calendar_auth_tokens" OWNER TO "postgres";

COMMENT ON COLUMN "public"."calendar_auth_tokens"."provider" IS 'OAuth provider: google or microsoft';

COMMENT ON COLUMN "public"."calendar_auth_tokens"."account_email" IS 'Email address of the connected account';

COMMENT ON COLUMN "public"."calendar_auth_tokens"."account_name" IS 'Display name of the connected account';

COMMENT ON COLUMN "public"."calendar_auth_tokens"."expires_at" IS 'When the access token expires, used for proactive refresh';

COMMENT ON COLUMN "public"."calendar_auth_tokens"."is_active" IS 'Whether this connection is active (soft delete)';

CREATE TABLE IF NOT EXISTS "public"."calendar_connections" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "calendar_id" "text" NOT NULL,
  "calendar_name" "text" NOT NULL,
  "is_enabled" boolean DEFAULT true NOT NULL,
  "color" "text",
  "created_at" timestamp without time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp without time zone DEFAULT "now"() NOT NULL,
  "auth_token_id" "uuid",
  "provider" "text" DEFAULT 'google' :: "text" NOT NULL,
  "workspace_calendar_id" "uuid",
  CONSTRAINT "calendar_connections_provider_check" CHECK (
    (
      "provider" = ANY (ARRAY ['google'::"text", 'microsoft'::"text"])
    )
  )
);

ALTER TABLE
  "public"."calendar_connections" OWNER TO "postgres";

COMMENT ON COLUMN "public"."calendar_connections"."auth_token_id" IS 'Reference to the auth token for this calendar connection';

COMMENT ON COLUMN "public"."calendar_connections"."provider" IS 'OAuth provider for this calendar connection';

CREATE TABLE IF NOT EXISTS "public"."calendar_event_colors" ("value" "text" NOT NULL);

ALTER TABLE
  "public"."calendar_event_colors" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."calendar_event_participant_groups" (
  "event_id" "uuid" NOT NULL,
  "group_id" "uuid" NOT NULL,
  "role" "text" DEFAULT '' :: "text",
  "notes" "text" DEFAULT '' :: "text",
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."calendar_event_participant_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."calendar_event_platform_participants" (
  "event_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "going" boolean,
  "role" "text",
  "notes" "text" DEFAULT '' :: "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."calendar_event_platform_participants" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."calendar_event_virtual_participants" (
  "event_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "going" boolean,
  "role" "text",
  "notes" "text" DEFAULT '' :: "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."calendar_event_virtual_participants" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_groups" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "archived" boolean DEFAULT false NOT NULL,
  "ending_date" timestamp with time zone,
  "notes" "text",
  "sessions" "date" [],
  "starting_date" timestamp with time zone,
  "is_guest" boolean DEFAULT false
);

ALTER TABLE
  "public"."workspace_user_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_users" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "full_name" "text",
  "email" "text",
  "phone" "text",
  "birthday" "date",
  "gender" "text",
  "ethnicity" "text",
  "guardian" "text",
  "address" "text",
  "national_id" "text",
  "note" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "balance" bigint DEFAULT '0' :: bigint,
  "avatar_url" "text",
  "display_name" "text",
  "archived" boolean DEFAULT false NOT NULL,
  "archived_until" timestamp with time zone,
  "created_by" "uuid",
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_by" "uuid",
  "referred_by" "uuid"
);

ALTER TABLE
  "public"."workspace_users" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."calendar_event_participants" WITH ("security_invoker" = 'on') AS
SELECT
  "p"."event_id",
  "p"."user_id" AS "participant_id",
  "p"."going",
  "u"."display_name",
  "u"."handle",
  'platform_user' :: "text" AS "type",
  "p"."created_at"
FROM
  (
    "public"."calendar_event_platform_participants" "p"
    JOIN "public"."users" "u" ON (("u"."id" = "p"."user_id"))
  )
UNION
SELECT
  "p"."event_id",
  "p"."user_id" AS "participant_id",
  "p"."going",
  "u"."display_name",
  COALESCE("u"."phone", "u"."email") AS "handle",
  'virtual_user' :: "text" AS "type",
  "p"."created_at"
FROM
  (
    "public"."calendar_event_virtual_participants" "p"
    JOIN "public"."workspace_users" "u" ON (("u"."id" = "p"."user_id"))
  )
UNION
SELECT
  "p"."event_id",
  "p"."group_id" AS "participant_id",
  NULL :: boolean AS "going",
  "g"."name" AS "display_name",
  NULL :: "text" AS "handle",
  'user_group' :: "text" AS "type",
  "p"."created_at"
FROM
  (
    "public"."calendar_event_participant_groups" "p"
    JOIN "public"."workspace_user_groups" "g" ON (("g"."id" = "p"."group_id"))
  );

ALTER VIEW "public"."calendar_event_participants" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."calendar_sync_dashboard" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "triggered_by" "uuid" NOT NULL,
  "start_time" timestamp with time zone,
  "end_time" timestamp with time zone,
  "type" "text",
  "source" "text",
  "status" "text",
  "inserted_events" integer DEFAULT 0,
  "updated_events" integer DEFAULT 0,
  "deleted_events" integer DEFAULT 0,
  "timing_google_api_fetch_ms" integer,
  "timing_token_operations_ms" integer,
  "timing_event_processing_ms" integer,
  "timing_database_writes_ms" integer,
  "timing_total_ms" integer,
  "google_api_calls_count" integer DEFAULT 0,
  "google_api_pages_fetched" integer DEFAULT 0,
  "google_api_retry_count" integer DEFAULT 0,
  "google_api_error_code" "text",
  "events_fetched_total" integer DEFAULT 0,
  "events_filtered_out" integer DEFAULT 0,
  "batch_count" integer DEFAULT 0,
  "payload_size_bytes" bigint,
  "error_message" "text",
  "error_type" "text",
  "error_stack_trace" "text",
  "failed_event_ids" "jsonb",
  "calendar_ids_synced" "text" [],
  "calendar_connection_count" integer DEFAULT 0,
  "was_blocked_by_cooldown" boolean DEFAULT false,
  "cooldown_remaining_seconds" integer,
  "sync_token_used" boolean DEFAULT false,
  "date_range_start" timestamp with time zone,
  "date_range_end" timestamp with time zone,
  "triggered_from" "text",
  CONSTRAINT "calendar_sync_dashboard_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['completed'::"text", 'failed'::"text", 'running'::"text"]
      )
    )
  ),
  CONSTRAINT "calendar_sync_dashboard_type_check" CHECK (
    (
      "type" = ANY (
        ARRAY ['active'::"text", 'manual'::"text", 'background'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."calendar_sync_dashboard" OWNER TO "postgres";

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."timing_google_api_fetch_ms" IS 'Time spent fetching events from Google Calendar API';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."timing_token_operations_ms" IS 'Time spent on token retrieval and refresh operations';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."timing_event_processing_ms" IS 'Time spent processing and filtering events';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."timing_database_writes_ms" IS 'Time spent writing to database (upserts and deletes)';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."timing_total_ms" IS 'Total sync duration calculated from start_time and end_time';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."google_api_calls_count" IS 'Number of API calls made to Google Calendar';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."google_api_pages_fetched" IS 'Number of pagination pages fetched from Google Calendar';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."google_api_retry_count" IS 'Number of retry attempts due to API errors';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."google_api_error_code" IS 'HTTP error code or API error identifier from Google';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."events_fetched_total" IS 'Total number of events fetched from Google before filtering';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."events_filtered_out" IS 'Number of events filtered out (e.g., outside date range)';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."batch_count" IS 'Number of database batch operations performed';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."payload_size_bytes" IS 'Total size of data transferred from Google Calendar API';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."error_message" IS 'Human-readable error message for failed syncs';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."error_type" IS 'Categorized error type for analytics and alerting';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."error_stack_trace" IS 'Full stack trace for debugging production issues';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."failed_event_ids" IS 'JSONB array of Google Calendar event IDs that failed to sync';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."calendar_ids_synced" IS 'Array of Google Calendar IDs included in this sync operation';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."calendar_connection_count" IS 'Number of calendar connections processed in this sync';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."was_blocked_by_cooldown" IS 'Whether sync was initially blocked by 30-second cooldown coordination';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."cooldown_remaining_seconds" IS 'Seconds remaining in cooldown when sync was attempted';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."sync_token_used" IS 'Whether incremental sync token was used (vs full date range fetch)';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."date_range_start" IS 'Start date for event fetching (if not using sync token)';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."date_range_end" IS 'End date for event fetching (if not using sync token)';

COMMENT ON COLUMN "public"."calendar_sync_dashboard"."triggered_from" IS 'Source that initiated the sync operation';

CREATE TABLE IF NOT EXISTS "public"."calendar_sync_states" (
  "ws_id" "uuid" NOT NULL,
  "calendar_id" "text" DEFAULT 'primary' :: "text" NOT NULL,
  "sync_token" "text",
  "last_synced_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."calendar_sync_states" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."changelog_entries" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "title" "text" NOT NULL,
  "slug" "text" NOT NULL,
  "content" "jsonb" NOT NULL,
  "summary" "text",
  "category" "text" NOT NULL,
  "version" "text",
  "cover_image_url" "text",
  "is_published" boolean DEFAULT false,
  "published_at" timestamp with time zone,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  CONSTRAINT "changelog_entries_category_check" CHECK (
    (
      "category" = ANY (
        ARRAY ['feature'::"text", 'improvement'::"text", 'bugfix'::"text", 'breaking'::"text", 'security'::"text", 'performance'::"text"]
      )
    )
  ),
  CONSTRAINT "changelog_entries_content_valid" CHECK (
    (
      ("content" IS NOT NULL)
      AND ("content" ? 'type' :: "text")
      AND (("content" ->> 'type' :: "text") = 'doc' :: "text")
    )
  )
);

ALTER TABLE
  "public"."changelog_entries" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."course_certificates" (
  "id" "text" DEFAULT (
    (
      'CERT-' :: "text" || "to_char"("now"(), 'YYYY-MM-DD-' :: "text")
    ) || ("gen_random_uuid"()) :: "text"
  ) NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "course_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc' :: "text") NOT NULL,
  "completed_date" "date" NOT NULL
);

ALTER TABLE
  "public"."course_certificates" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."course_module_completion_status" (
  "completion_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "module_id" "uuid" NOT NULL,
  "user_id" "uuid" DEFAULT "auth"."uid"(),
  "completed_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc' :: "text"),
  "completion_status" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."course_module_completion_status" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."course_module_flashcards" (
  "module_id" "uuid" NOT NULL,
  "flashcard_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."course_module_flashcards" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."course_module_quiz_sets" (
  "module_id" "uuid" NOT NULL,
  "set_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."course_module_quiz_sets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."course_module_quizzes" (
  "module_id" "uuid" NOT NULL,
  "quiz_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."course_module_quizzes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."crawled_url_next_urls" (
  "origin_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "url" "text" NOT NULL,
  "skipped" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."crawled_url_next_urls" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."crawled_urls" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "url" "text" NOT NULL,
  "html" "text",
  "markdown" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "creator_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."crawled_urls" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."credit_wallets" (
  "wallet_id" "uuid" NOT NULL,
  "statement_date" smallint NOT NULL,
  "payment_date" smallint NOT NULL,
  "limit" bigint NOT NULL
);

ALTER TABLE
  "public"."credit_wallets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."cross_app_tokens" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "token" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "expires_at" timestamp with time zone NOT NULL,
  "used_at" timestamp with time zone,
  "is_revoked" boolean DEFAULT false NOT NULL,
  "origin_app" "text" NOT NULL,
  "target_app" "text" NOT NULL,
  "session_data" "jsonb"
);

ALTER TABLE
  "public"."cross_app_tokens" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."currencies" (
  "code" "text" NOT NULL,
  "name" "text" NOT NULL
);

ALTER TABLE
  "public"."currencies" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."discord_guild_members" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "discord_guild_id" "text" NOT NULL,
  "discord_user_id" "text" NOT NULL,
  "platform_user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."discord_guild_members" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."discord_integrations" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "discord_guild_id" "text" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."discord_integrations" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."finance_invoices" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "price" bigint NOT NULL,
  "total_diff" bigint DEFAULT '0' :: bigint NOT NULL,
  "note" "text",
  "notice" "text",
  "customer_id" "uuid",
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid",
  "completed_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "transaction_id" "uuid",
  "category_id" "uuid" NOT NULL,
  "valid_until" timestamp with time zone,
  "wallet_id" "uuid" NOT NULL,
  "paid_amount" bigint DEFAULT '0' :: bigint NOT NULL,
  "user_group_id" "uuid"
);

ALTER TABLE
  "public"."finance_invoices" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."distinct_invoice_creators" WITH ("security_invoker" = 'on') AS
SELECT
  DISTINCT "u"."id",
  COALESCE("u"."display_name", "u"."full_name") AS "display_name"
FROM
  "public"."finance_invoices" "b",
  "public"."workspace_users" "u"
WHERE
  ("u"."id" = "b"."creator_id");

ALTER VIEW "public"."distinct_invoice_creators" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."email_audit" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid",
  "provider" "text" DEFAULT 'ses' :: "text" NOT NULL,
  "source_name" "text" NOT NULL,
  "source_email" "text" NOT NULL,
  "to_addresses" "text" [] NOT NULL,
  "cc_addresses" "text" [] DEFAULT '{}' :: "text" [] NOT NULL,
  "bcc_addresses" "text" [] DEFAULT '{}' :: "text" [] NOT NULL,
  "reply_to_addresses" "text" [] DEFAULT '{}' :: "text" [] NOT NULL,
  "subject" "text" NOT NULL,
  "content_hash" "text",
  "template_type" "text",
  "entity_type" "text",
  "entity_id" "uuid",
  "status" "text" DEFAULT 'pending' :: "text" NOT NULL,
  "message_id" "text",
  "error_message" "text",
  "ip_address" "text",
  "user_agent" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "sent_at" timestamp with time zone,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "html_content" "text",
  "text_content" "text",
  "metadata" "jsonb",
  CONSTRAINT "email_audit_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['pending'::"text", 'sent'::"text", 'failed'::"text", 'bounced'::"text", 'complained'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."email_audit" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_audit" IS 'Centralized audit log for all external email sending';

COMMENT ON COLUMN "public"."email_audit"."provider" IS 'Email provider used (ses, sendgrid, postmark)';

COMMENT ON COLUMN "public"."email_audit"."content_hash" IS 'SHA256 hash of email content for deduplication detection';

COMMENT ON COLUMN "public"."email_audit"."template_type" IS 'Email template identifier (workspace-invite, notification-digest, etc.)';

COMMENT ON COLUMN "public"."email_audit"."entity_type" IS 'Type of entity this email relates to (notification, post, lead)';

COMMENT ON COLUMN "public"."email_audit"."entity_id" IS 'ID of the related entity for cross-referencing';

COMMENT ON COLUMN "public"."email_audit"."message_id" IS 'Provider-specific message ID for tracking bounces/complaints';

COMMENT ON COLUMN "public"."email_audit"."html_content" IS 'HTML content of the email body';

COMMENT ON COLUMN "public"."email_audit"."text_content" IS 'Plain text content of the email body';

CREATE TABLE IF NOT EXISTS "public"."email_blacklist" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "entry_type" "public"."blacklist_entry_type" NOT NULL,
  "value" "text" NOT NULL,
  "reason" "text",
  "added_by_user_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  CONSTRAINT "email_blacklist_domain_format_check" CHECK (
    (
      (
        "entry_type" <> 'domain' :: "public"."blacklist_entry_type"
      )
      OR (
        "value" ~ '^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$' :: "text"
      )
    )
  ),
  CONSTRAINT "email_blacklist_email_format_check" CHECK (
    (
      (
        "entry_type" <> 'email' :: "public"."blacklist_entry_type"
      )
      OR (
        "value" ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$' :: "text"
      )
    )
  ),
  CONSTRAINT "email_blacklist_value_not_empty_check" CHECK (
    (
      TRIM(
        BOTH
        FROM
          "value"
      ) <> '' :: "text"
    )
  )
);

ALTER TABLE
  "public"."email_blacklist" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."email_bounce_complaints" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "email_hash" "text" NOT NULL,
  "event_type" "text" NOT NULL,
  "bounce_type" "text",
  "bounce_subtype" "text",
  "complaint_type" "text",
  "complaint_feedback_id" "text",
  "original_email_id" "uuid",
  "raw_notification" "jsonb",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  CONSTRAINT "email_bounce_complaints_event_type_check" CHECK (
    (
      "event_type" = ANY (ARRAY ['bounce'::"text", 'complaint'::"text"])
    )
  )
);

ALTER TABLE
  "public"."email_bounce_complaints" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_bounce_complaints" IS 'Tracks email bounces and complaints for reputation management';

COMMENT ON COLUMN "public"."email_bounce_complaints"."email_hash" IS 'SHA256 hash (truncated) of the email address for privacy';

COMMENT ON COLUMN "public"."email_bounce_complaints"."bounce_type" IS 'Type of bounce: hard (permanent), soft (temporary), transient';

COMMENT ON COLUMN "public"."email_bounce_complaints"."complaint_type" IS 'Type of complaint: abuse, auth-failure, fraud, etc.';

COMMENT ON COLUMN "public"."email_bounce_complaints"."raw_notification" IS 'Raw notification payload from email provider (for debugging)';

CREATE TABLE IF NOT EXISTS "public"."external_user_monthly_report_logs" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "report_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "group_id" "uuid" NOT NULL,
  "title" "text" DEFAULT '' :: "text" NOT NULL,
  "content" "text" DEFAULT '' :: "text" NOT NULL,
  "feedback" "text" DEFAULT '' :: "text" NOT NULL,
  "score" real,
  "scores" real [],
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."external_user_monthly_report_logs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."external_user_monthly_reports" (
  "user_id" "uuid" NOT NULL,
  "group_id" "uuid" NOT NULL,
  "title" "text" NOT NULL,
  "content" "text" NOT NULL,
  "feedback" "text" NOT NULL,
  "score" real,
  "scores" real [],
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."external_user_monthly_reports" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."field_types" (
  "id" "text" NOT NULL,
  "enabled" boolean DEFAULT true NOT NULL
);

ALTER TABLE
  "public"."field_types" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."finance_budgets" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "amount" numeric DEFAULT 0 NOT NULL,
  "spent" numeric DEFAULT 0 NOT NULL,
  "period" "text" DEFAULT 'monthly' :: "text" NOT NULL,
  "category_id" "uuid",
  "wallet_id" "uuid",
  "start_date" "date" NOT NULL,
  "end_date" "date",
  "alert_threshold" numeric DEFAULT 80,
  "is_active" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  CONSTRAINT "finance_budgets_alert_threshold_check" CHECK (
    (
      ("alert_threshold" >= (0) :: numeric)
      AND ("alert_threshold" <= (100) :: numeric)
    )
  ),
  CONSTRAINT "finance_budgets_amount_check" CHECK (("amount" >= (0) :: numeric)),
  CONSTRAINT "finance_budgets_spent_check" CHECK (("spent" >= (0) :: numeric))
);

ALTER TABLE
  "public"."finance_budgets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."finance_invoice_products" (
  "invoice_id" "uuid" NOT NULL,
  "product_id" "uuid",
  "unit_id" "uuid" NOT NULL,
  "amount" bigint NOT NULL,
  "price" bigint NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "total_diff" bigint DEFAULT '0' :: bigint NOT NULL,
  "warehouse_id" "uuid" NOT NULL,
  "product_name" "text" DEFAULT '' :: "text" NOT NULL,
  "product_unit" "text" DEFAULT '' :: "text" NOT NULL,
  "warehouse" "text" DEFAULT '' :: "text" NOT NULL
);

ALTER TABLE
  "public"."finance_invoice_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."finance_invoice_promotions" (
  "code" "text" DEFAULT '' :: "text" NOT NULL,
  "promo_id" "uuid",
  "name" "text" DEFAULT '' :: "text",
  "description" "text" DEFAULT '' :: "text",
  "value" integer NOT NULL,
  "use_ratio" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "invoice_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."finance_invoice_promotions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_group_attendance" (
  "group_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "date" "date" NOT NULL,
  "status" "text" NOT NULL,
  "notes" "text" DEFAULT '' :: "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."user_group_attendance" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_groups_users" (
  "user_id" "uuid" NOT NULL,
  "group_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "role" "text"
);

ALTER TABLE
  "public"."workspace_user_groups_users" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."group_with_attendance" AS
SELECT
  "wug"."id" AS "group_id",
  "wug"."ws_id",
  "wuuu"."user_id",
  "wu"."full_name",
  "wu"."email",
  "wu"."gender",
  "wu"."phone",
  "count"("uga".*) AS "attendance_count"
FROM
  (
    (
      (
        "public"."workspace_user_groups" "wug"
        JOIN "public"."workspace_user_groups_users" "wuuu" ON (("wug"."id" = "wuuu"."group_id"))
      )
      JOIN "public"."workspace_users" "wu" ON (("wuuu"."user_id" = "wu"."id"))
    )
    LEFT JOIN "public"."user_group_attendance" "uga" ON (("uga"."user_id" = "wuuu"."user_id"))
  )
WHERE
  ("wug"."is_guest" = true)
GROUP BY
  "wug"."id",
  "wug"."ws_id",
  "wuuu"."user_id",
  "wu"."full_name",
  "wu"."email",
  "wu"."gender",
  "wu"."phone";

ALTER VIEW "public"."group_with_attendance" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_group_post_checks" (
  "post_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "is_completed" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "notes" "text",
  "email_id" "uuid"
);

ALTER TABLE
  "public"."user_group_post_checks" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."group_user_with_attendance" AS
SELECT
  "gu"."group_id",
  "wu"."id" AS "user_id",
  "wu"."full_name",
  "upc"."post_id",
  "upc"."is_completed",
  "gwa"."attendance_count"
FROM
  (
    (
      (
        "public"."workspace_user_groups_users" "gu"
        JOIN "public"."workspace_users" "wu" ON (("gu"."user_id" = "wu"."id"))
      )
      LEFT JOIN "public"."user_group_post_checks" "upc" ON (("wu"."id" = "upc"."user_id"))
    )
    LEFT JOIN "public"."group_with_attendance" "gwa" ON (
      (
        ("gu"."group_id" = "gwa"."group_id")
        AND ("gu"."user_id" = "gwa"."user_id")
      )
    )
  );

ALTER VIEW "public"."group_user_with_attendance" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."group_users_with_post_checks" AS
SELECT
  "gwa"."group_id",
  "gwa"."ws_id",
  "gwa"."user_id",
  "gwa"."full_name",
  "gwa"."email",
  "gwa"."gender",
  "gwa"."phone",
  "gwa"."attendance_count",
  "ugpc"."post_id",
  "ugpc"."is_completed"
FROM
  (
    "public"."group_with_attendance" "gwa"
    LEFT JOIN "public"."user_group_post_checks" "ugpc" ON (("ugpc"."user_id" = "gwa"."user_id"))
  );

ALTER VIEW "public"."group_users_with_post_checks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."guest_users_lead_generation" (
  "id" bigint NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "mail_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."guest_users_lead_generation" OWNER TO "postgres";

ALTER TABLE
  "public"."guest_users_lead_generation"
ALTER COLUMN
  "id"
ADD
  GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."guest_users_lead_generation_id_seq" START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
  );

CREATE TABLE IF NOT EXISTS "public"."habit_calendar_events" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "habit_id" "uuid" NOT NULL,
  "event_id" "uuid" NOT NULL,
  "occurrence_date" "date" NOT NULL,
  "completed" boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."habit_calendar_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."habit_calendar_events" IS 'Links habits to their scheduled calendar events';

CREATE TABLE IF NOT EXISTS "public"."habit_completions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "habit_id" "uuid" NOT NULL,
  "occurrence_date" "date" NOT NULL,
  "completed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "event_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."habit_completions" OWNER TO "postgres";

COMMENT ON TABLE "public"."habit_completions" IS 'Tracks habit completions for streak calculation';

CREATE TABLE IF NOT EXISTS "public"."handles" (
  "value" "text" NOT NULL,
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."handles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_checkup_vital_groups" (
  "checkup_id" "uuid" NOT NULL,
  "group_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."healthcare_checkup_vital_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_checkup_vitals" (
  "checkup_id" "uuid" NOT NULL,
  "vital_id" "uuid" NOT NULL,
  "value" real,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."healthcare_checkup_vitals" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_checkups" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "patient_id" "uuid" NOT NULL,
  "diagnosis_id" "uuid",
  "checked" boolean DEFAULT false NOT NULL,
  "checkup_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "next_checked" boolean,
  "next_checkup_at" timestamp with time zone,
  "note" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "completed_at" timestamp with time zone,
  "creator_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."healthcare_checkups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_diagnoses" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "description" "text",
  "note" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."healthcare_diagnoses" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_vital_groups" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "note" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."healthcare_vital_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."healthcare_vitals" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "unit" "text" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "factor" smallint DEFAULT '1' :: smallint NOT NULL,
  "group_id" "uuid"
);

ALTER TABLE
  "public"."healthcare_vitals" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."internal_email_api_keys" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "value" "text" NOT NULL,
  "allowed_emails" "text" [],
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."internal_email_api_keys" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."internal_emails" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "source_email" "text" NOT NULL,
  "subject" "text" NOT NULL,
  "to_addresses" "text" [] NOT NULL,
  "cc_addresses" "text" [] NOT NULL,
  "bcc_addresses" "text" [] NOT NULL,
  "reply_to_addresses" "text" [] NOT NULL,
  "payload" "text" NOT NULL,
  "html_payload" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."internal_emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_batch_products" (
  "batch_id" "uuid" NOT NULL,
  "product_id" "uuid" NOT NULL,
  "unit_id" "uuid" NOT NULL,
  "amount" bigint DEFAULT '0' :: bigint NOT NULL,
  "price" bigint DEFAULT '0' :: bigint NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  CONSTRAINT "inventory_batch_products_amount_check" CHECK (("amount" >= 0))
);

ALTER TABLE
  "public"."inventory_batch_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_batches" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "price" bigint DEFAULT '0' :: bigint NOT NULL,
  "warehouse_id" "uuid" NOT NULL,
  "supplier_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "total_diff" bigint DEFAULT '0' :: bigint NOT NULL
);

ALTER TABLE
  "public"."inventory_batches" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_products" (
  "product_id" "uuid" NOT NULL,
  "unit_id" "uuid" NOT NULL,
  "amount" bigint DEFAULT '0' :: bigint,
  "price" bigint DEFAULT '0' :: bigint NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "warehouse_id" "uuid" NOT NULL,
  "min_amount" bigint DEFAULT '0' :: bigint NOT NULL,
  CONSTRAINT "inventory_products_amount_check" CHECK (
    (
      ("amount" IS NULL)
      OR ("amount" IS NOT NULL)
    )
  )
);

ALTER TABLE
  "public"."inventory_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_suppliers" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."inventory_suppliers" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_units" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."inventory_units" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."inventory_warehouses" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."inventory_warehouses" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."link_analytics" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "link_id" "uuid" NOT NULL,
  "ip_address" "inet",
  "user_agent" "text",
  "referrer" "text",
  "referrer_domain" "text",
  "country" "text",
  "city" "text",
  "clicked_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "country_region" "text",
  "latitude" real,
  "longitude" real,
  "timezone" "text",
  "postal_code" "text",
  "vercel_region" "text",
  "vercel_id" "text",
  "device_type" "text",
  "browser" "text",
  "os" "text"
);

ALTER TABLE
  "public"."link_analytics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."shortened_links" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "link" "text" NOT NULL,
  "slug" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "domain" "text" NOT NULL,
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."shortened_links" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."link_analytics_device_insights" AS
SELECT
  "sl"."id" AS "link_id",
  "sl"."slug",
  "sl"."domain",
  "la"."device_type",
  "la"."browser",
  "la"."os",
  "count"(*) AS "click_count",
  "count"(DISTINCT "la"."ip_address") AS "unique_visitors",
  "min"("la"."clicked_at") AS "first_click_at",
  "max"("la"."clicked_at") AS "last_click_at"
FROM
  (
    "public"."shortened_links" "sl"
    JOIN "public"."link_analytics" "la" ON (("sl"."id" = "la"."link_id"))
  )
WHERE
  ("la"."device_type" IS NOT NULL)
GROUP BY
  "sl"."id",
  "sl"."slug",
  "sl"."domain",
  "la"."device_type",
  "la"."browser",
  "la"."os"
ORDER BY
  ("count"(*)) DESC;

ALTER VIEW "public"."link_analytics_device_insights" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."link_analytics_geo_insights" AS
SELECT
  "sl"."id" AS "link_id",
  "sl"."slug",
  "sl"."domain",
  "la"."country",
  "la"."country_region",
  "la"."city",
  "la"."latitude",
  "la"."longitude",
  "la"."timezone",
  "la"."postal_code",
  "la"."vercel_region",
  "count"(*) AS "click_count",
  "count"(DISTINCT "la"."ip_address") AS "unique_visitors",
  "min"("la"."clicked_at") AS "first_click_at",
  "max"("la"."clicked_at") AS "last_click_at"
FROM
  (
    "public"."shortened_links" "sl"
    JOIN "public"."link_analytics" "la" ON (("sl"."id" = "la"."link_id"))
  )
WHERE
  ("la"."country" IS NOT NULL)
GROUP BY
  "sl"."id",
  "sl"."slug",
  "sl"."domain",
  "la"."country",
  "la"."country_region",
  "la"."city",
  "la"."latitude",
  "la"."longitude",
  "la"."timezone",
  "la"."postal_code",
  "la"."vercel_region"
ORDER BY
  ("count"(*)) DESC;

ALTER VIEW "public"."link_analytics_geo_insights" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."link_analytics_summary" AS
SELECT
  "sl"."id" AS "link_id",
  "sl"."slug",
  "sl"."link" AS "original_url",
  "sl"."domain",
  "sl"."creator_id",
  "sl"."ws_id",
  "sl"."created_at" AS "link_created_at",
  "count"("la"."id") AS "total_clicks",
  "count"(DISTINCT "la"."ip_address") AS "unique_visitors",
  "count"(DISTINCT "la"."referrer_domain") AS "unique_referrers",
  "count"(DISTINCT "la"."country") AS "unique_countries",
  "count"(DISTINCT "la"."city") AS "unique_cities",
  "count"(DISTINCT "la"."device_type") AS "unique_device_types",
  "count"(DISTINCT "la"."browser") AS "unique_browsers",
  "count"(DISTINCT "la"."os") AS "unique_operating_systems",
  "min"("la"."clicked_at") AS "first_click_at",
  "max"("la"."clicked_at") AS "last_click_at",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."referrer_domain"
  ) AS "top_referrer_domain",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."country"
  ) AS "top_country",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."city"
  ) AS "top_city",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."device_type"
  ) AS "top_device_type",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."browser"
  ) AS "top_browser",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."os"
  ) AS "top_os",
  "mode"() WITHIN GROUP (
    ORDER BY
      "la"."vercel_region"
  ) AS "top_vercel_region"
FROM
  (
    "public"."shortened_links" "sl"
    LEFT JOIN "public"."link_analytics" "la" ON (("sl"."id" = "la"."link_id"))
  )
GROUP BY
  "sl"."id",
  "sl"."slug",
  "sl"."link",
  "sl"."domain",
  "sl"."creator_id",
  "sl"."ws_id",
  "sl"."created_at";

ALTER VIEW "public"."link_analytics_summary" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."live_api_sessions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "session_handle" "text" NOT NULL,
  "expires_at" timestamp with time zone NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."live_api_sessions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meet_together_guest_timeblocks" (
  "plan_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "date" "date" NOT NULL,
  "start_time" time with time zone NOT NULL,
  "end_time" time with time zone NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "tentative" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."meet_together_guest_timeblocks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meet_together_guests" (
  "plan_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "password_hash" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "password_salt" "text" NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."meet_together_guests" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meet_together_plans" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "dates" "date" [] NOT NULL,
  "start_time" time with time zone NOT NULL,
  "end_time" time with time zone NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "description" "text",
  "is_public" boolean DEFAULT true NOT NULL,
  "ws_id" "uuid",
  "where_to_meet" boolean DEFAULT false NOT NULL,
  "agenda_content" "jsonb",
  "is_confirmed" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."meet_together_plans" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meet_together_user_timeblocks" (
  "plan_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "date" "date" NOT NULL,
  "start_time" time with time zone NOT NULL,
  "end_time" time with time zone NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "tentative" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."meet_together_user_timeblocks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_private_details" (
  "user_id" "uuid" NOT NULL,
  "email" "text",
  "new_email" "text",
  "birthday" "date",
  "full_name" "text",
  "default_workspace_id" "uuid"
);

ALTER TABLE
  "public"."user_private_details" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."meet_together_users" AS
SELECT
  DISTINCT ON (
    "all_users"."id",
    COALESCE("gtbs"."plan_id", "utbs"."plan_id")
  ) "all_users"."id" AS "user_id",
  COALESCE(
    NULLIF("all_users"."name", '' :: "text"),
    "upd"."email"
  ) AS "display_name",
  COALESCE("gtbs"."plan_id", "utbs"."plan_id") AS "plan_id",
  CASE
    WHEN "all_users"."is_guest" THEN true
    ELSE false
  END AS "is_guest",
  "count"(COALESCE("gtbs"."id", "utbs"."id")) AS "timeblock_count"
FROM
  (
    (
      (
        (
          (
            SELECT
              "meet_together_guests"."id",
              "meet_together_guests"."name",
              true AS "is_guest"
            FROM
              "public"."meet_together_guests"
            UNION
            ALL
            SELECT
              "u"."id",
              "u"."display_name" AS "name",
              false AS "is_guest"
            FROM
              "public"."users" "u"
          ) "all_users"
          LEFT JOIN "public"."user_private_details" "upd" ON (("all_users"."id" = "upd"."user_id"))
        )
        LEFT JOIN "public"."meet_together_guest_timeblocks" "gtbs" ON (
          (
            ("all_users"."id" = "gtbs"."user_id")
            AND "all_users"."is_guest"
          )
        )
      )
      LEFT JOIN "public"."meet_together_user_timeblocks" "utbs" ON (
        (
          ("all_users"."id" = "utbs"."user_id")
          AND (NOT "all_users"."is_guest")
        )
      )
    )
    LEFT JOIN "public"."meet_together_plans" "plans" ON (
      (
        "plans"."id" = COALESCE("gtbs"."plan_id", "utbs"."plan_id")
      )
    )
  )
WHERE
  (
    COALESCE("gtbs"."plan_id", "utbs"."plan_id") IS NOT NULL
  )
GROUP BY
  "all_users"."id",
  "all_users"."name",
  "upd"."email",
  "all_users"."is_guest",
  "gtbs"."plan_id",
  "utbs"."plan_id";

ALTER VIEW "public"."meet_together_users" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."notes" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "archived" boolean DEFAULT false,
  "deleted" boolean DEFAULT false,
  "content" "jsonb" NOT NULL,
  "title" "text",
  CONSTRAINT "notes_content_valid_json" CHECK (
    (
      ("content" IS NOT NULL)
      AND ("content" ? 'type' :: "text")
      AND (("content" ->> 'type' :: "text") = 'doc' :: "text")
    )
  )
);

ALTER TABLE
  "public"."notes" OWNER TO "postgres";

COMMENT ON COLUMN "public"."notes"."content" IS 'TipTap JSONContent format for rich text editing';

CREATE TABLE IF NOT EXISTS "public"."notification_batches" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid",
  "user_id" "uuid",
  "channel" "text" NOT NULL,
  "status" "text" DEFAULT 'pending' :: "text" NOT NULL,
  "window_start" timestamp with time zone NOT NULL,
  "window_end" timestamp with time zone NOT NULL,
  "sent_at" timestamp with time zone,
  "notification_count" integer DEFAULT 0 NOT NULL,
  "error_message" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "email" "text",
  "delivery_mode" "public"."notification_delivery_mode" DEFAULT 'batched' :: "public"."notification_delivery_mode" NOT NULL,
  CONSTRAINT "notification_batches_channel_check" CHECK (
    (
      "channel" = ANY (
        ARRAY ['email'::"text", 'sms'::"text", 'push'::"text"]
      )
    )
  ),
  CONSTRAINT "notification_batches_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['pending'::"text", 'processing'::"text", 'sent'::"text", 'failed'::"text"]
      )
    )
  ),
  CONSTRAINT "notification_batches_user_or_email_check" CHECK (
    (
      ("user_id" IS NOT NULL)
      OR ("email" IS NOT NULL)
    )
  )
);

ALTER TABLE
  "public"."notification_batches" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_batches" IS 'Stores batches of notifications for digest email delivery. Batches are processed by the /api/cron/process-notification-batches endpoint.';

COMMENT ON COLUMN "public"."notification_batches"."window_start" IS 'When the batching window started';

COMMENT ON COLUMN "public"."notification_batches"."window_end" IS 'When the batching window ends and notifications should be sent';

COMMENT ON COLUMN "public"."notification_batches"."notification_count" IS 'Number of notifications grouped in this batch';

COMMENT ON COLUMN "public"."notification_batches"."delivery_mode" IS 'Whether this batch should be sent immediately or after the batch window';

CREATE TABLE IF NOT EXISTS "public"."notification_delivery_log" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "notification_id" "uuid" NOT NULL,
  "channel" "text" NOT NULL,
  "status" "text" DEFAULT 'pending' :: "text" NOT NULL,
  "batch_id" "uuid",
  "sent_at" timestamp with time zone,
  "error_message" "text",
  "retry_count" integer DEFAULT 0 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  CONSTRAINT "notification_delivery_log_channel_check" CHECK (
    (
      "channel" = ANY (
        ARRAY ['email'::"text", 'sms'::"text", 'push'::"text"]
      )
    )
  ),
  CONSTRAINT "notification_delivery_log_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['pending'::"text", 'sent'::"text", 'failed'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."notification_delivery_log" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_delivery_log" IS 'Tracks delivery status of notifications across different channels (web, email, etc.). Email deliveries are processed in batches.';

COMMENT ON COLUMN "public"."notification_delivery_log"."channel" IS 'Delivery channel: email, sms, push';

COMMENT ON COLUMN "public"."notification_delivery_log"."status" IS 'Delivery status: pending, sent, failed';

COMMENT ON COLUMN "public"."notification_delivery_log"."batch_id" IS 'Reference to notification batch for grouped deliveries (10-minute window)';

COMMENT ON COLUMN "public"."notification_delivery_log"."retry_count" IS 'Number of retry attempts for failed deliveries';

CREATE TABLE IF NOT EXISTS "public"."notification_email_config" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "notification_type" "text" NOT NULL,
  "delivery_mode" "public"."notification_delivery_mode" DEFAULT 'batched' :: "public"."notification_delivery_mode" NOT NULL,
  "email_template" "text",
  "email_subject_template" "text",
  "priority_override" "public"."notification_priority",
  "batch_window_minutes" integer DEFAULT 10,
  "enabled" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."notification_email_config" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_email_config" IS 'Configuration for notification email delivery. Batch windows are tuned for UX:
- Assignments/mentions/deadline changes: 5 min (actionable, needs quick delivery)
- Other task updates: 15 min (allows consolidation of rapid changes)
- Deadline reminders: Immediate (critical)
- Workspace invites: Immediate (important first impression)';

COMMENT ON COLUMN "public"."notification_email_config"."notification_type" IS 'The notification type this config applies to (e.g., workspace_invite, task_assigned)';

COMMENT ON COLUMN "public"."notification_email_config"."delivery_mode" IS 'immediate: send individual email right away, batched: group in digest email';

COMMENT ON COLUMN "public"."notification_email_config"."email_template" IS 'Template identifier for immediate emails (used to select React Email template)';

COMMENT ON COLUMN "public"."notification_email_config"."email_subject_template" IS 'Subject line template with {placeholder} variables';

COMMENT ON COLUMN "public"."notification_email_config"."priority_override" IS 'Optional priority override for this notification type';

COMMENT ON COLUMN "public"."notification_email_config"."batch_window_minutes" IS 'Batch window duration in minutes (only used for batched mode)';

CREATE TABLE IF NOT EXISTS "public"."notification_preferences" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid",
  "user_id" "uuid" NOT NULL,
  "event_type" "text" NOT NULL,
  "channel" "text" NOT NULL,
  "enabled" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "scope" "public"."notification_scope" DEFAULT 'workspace' :: "public"."notification_scope" NOT NULL,
  CONSTRAINT "check_user_preferences_no_ws_id" CHECK (
    (
      (
        "scope" = 'workspace' :: "public"."notification_scope"
      )
      OR ("ws_id" IS NULL)
    )
  ),
  CONSTRAINT "check_workspace_preferences_have_ws_id" CHECK (
    (
      (
        "scope" <> 'workspace' :: "public"."notification_scope"
      )
      OR ("ws_id" IS NOT NULL)
    )
  )
);

ALTER TABLE
  "public"."notification_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_preferences" IS 'User preferences for notification channels and event types per workspace';

COMMENT ON COLUMN "public"."notification_preferences"."event_type" IS 'Type of event: task_assigned, task_updated, task_mention, workspace_invite';

COMMENT ON COLUMN "public"."notification_preferences"."channel" IS 'Delivery channel: web, email, sms, push';

COMMENT ON COLUMN "public"."notification_preferences"."enabled" IS 'Whether notifications are enabled for this combination';

COMMENT ON COLUMN "public"."notification_preferences"."scope" IS 'Preference scope: user or workspace';

CREATE TABLE IF NOT EXISTS "public"."notifications" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid",
  "user_id" "uuid",
  "type" "text" NOT NULL,
  "title" "text" NOT NULL,
  "description" "text",
  "data" "jsonb" DEFAULT '{}' :: "jsonb",
  "entity_type" "text",
  "entity_id" "uuid",
  "read_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_by" "uuid",
  "scope" "public"."notification_scope" DEFAULT 'workspace' :: "public"."notification_scope" NOT NULL,
  "priority" "public"."notification_priority" DEFAULT 'medium' :: "public"."notification_priority" NOT NULL,
  "action_url" "text",
  "expires_at" timestamp with time zone,
  "parent_id" "uuid",
  "metadata" "jsonb" DEFAULT '{}' :: "jsonb",
  "archived_at" timestamp with time zone,
  "code" "text",
  "email" "text",
  CONSTRAINT "check_non_workspace_notifications_no_ws_id" CHECK (
    (
      (
        "scope" = 'workspace' :: "public"."notification_scope"
      )
      OR ("ws_id" IS NULL)
    )
  ),
  CONSTRAINT "check_workspace_notifications_have_ws_id" CHECK (
    (
      (
        "scope" <> 'workspace' :: "public"."notification_scope"
      )
      OR ("ws_id" IS NOT NULL)
    )
  ),
  CONSTRAINT "notifications_type_check" CHECK (
    (
      "type" = ANY (
        ARRAY ['task_assigned'::"text", 'task_updated'::"text", 'task_mention'::"text", 'task_label_added'::"text", 'task_label_removed'::"text", 'task_title_changed'::"text", 'task_description_changed'::"text", 'task_priority_changed'::"text", 'task_due_date_changed'::"text", 'task_start_date_changed'::"text", 'task_estimation_changed'::"text", 'task_assignee_added'::"text", 'task_assignee_removed'::"text", 'task_project_linked'::"text", 'task_project_unlinked'::"text", 'task_moved'::"text", 'task_completed'::"text", 'task_reopened'::"text", 'task_deleted'::"text", 'task_restored'::"text", 'deadline_reminder'::"text", 'workspace_invite'::"text", 'system_announcement'::"text"]
      )
    )
  ),
  CONSTRAINT "notifications_user_or_email_check" CHECK (
    (
      ("user_id" IS NOT NULL)
      OR ("email" IS NOT NULL)
    )
  )
);

ALTER TABLE
  "public"."notifications" OWNER TO "postgres";

COMMENT ON TABLE "public"."notifications" IS 'Notification records for workspace and user events.
- RLS policies consolidated in 20251111101400_consolidate_notifications_rls_policies.sql
- Deletion is disabled to maintain audit trail
- Users can view their notifications and mark them as read/unread
- Direct inserts are disabled; use create_notification() function instead';

COMMENT ON COLUMN "public"."notifications"."ws_id" IS 'Workspace ID (required for workspace scope, NULL for user/system scope)';

COMMENT ON COLUMN "public"."notifications"."type" IS 'Notification type: task_assigned, task_updated, task_mention, workspace_invite, etc.';

COMMENT ON COLUMN "public"."notifications"."data" IS 'JSON data containing event-specific information (task details, changes, etc.)';

COMMENT ON COLUMN "public"."notifications"."read_at" IS 'Timestamp when notification was marked as read. NULL indicates unread.';

COMMENT ON COLUMN "public"."notifications"."scope" IS 'Notification scope: user (personal), workspace (workspace-specific), system (platform-wide)';

COMMENT ON COLUMN "public"."notifications"."priority" IS 'Notification priority level';

COMMENT ON COLUMN "public"."notifications"."action_url" IS 'URL to navigate to when notification is clicked';

COMMENT ON COLUMN "public"."notifications"."expires_at" IS 'Expiration timestamp for temporary notifications';

COMMENT ON COLUMN "public"."notifications"."parent_id" IS 'Parent notification ID for threading/grouping notifications';

COMMENT ON COLUMN "public"."notifications"."metadata" IS 'Additional metadata for notification';

COMMENT ON COLUMN "public"."notifications"."archived_at" IS 'Timestamp when notification was archived';

COMMENT ON COLUMN "public"."notifications"."code" IS 'Translation key for i18n support (e.g., "workspace_invite", "task_assigned")';

COMMENT ON COLUMN "public"."notifications"."email" IS 'Email address for pending users who do not have accounts yet';

COMMENT ON CONSTRAINT "notifications_type_check" ON "public"."notifications" IS 'Validates notification types. Includes task lifecycle events (assigned, updated, completed, reopened, deleted, restored, moved), task property changes (labels, priority, dates, estimation, assignees added/removed, projects), deadline reminders, and system events (workspace invites, announcements)';

CREATE TABLE IF NOT EXISTS "public"."nova_challenge_criteria" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text" NOT NULL,
  "challenge_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_challenge_criteria" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_challenge_manager_emails" (
  "challenge_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "email" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_challenge_manager_emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_challenge_whitelisted_emails" (
  "challenge_id" "uuid" NOT NULL,
  "email" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_challenge_whitelisted_emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_challenges" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "title" "text" NOT NULL,
  "description" "text" NOT NULL,
  "duration" integer NOT NULL,
  "close_at" timestamp with time zone,
  "enabled" boolean DEFAULT false NOT NULL,
  "open_at" timestamp with time zone,
  "previewable_at" timestamp with time zone,
  "max_attempts" smallint DEFAULT 1 NOT NULL,
  "max_daily_attempts" smallint DEFAULT 1 NOT NULL,
  "password_hash" "text",
  "password_salt" "text",
  "whitelisted_only" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."nova_challenges" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_problem_test_cases" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "problem_id" "uuid" NOT NULL,
  "input" "text" NOT NULL,
  "hidden" boolean DEFAULT true NOT NULL,
  "output" "text" NOT NULL
);

ALTER TABLE
  "public"."nova_problem_test_cases" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_problems" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "challenge_id" "uuid" NOT NULL,
  "title" "text" NOT NULL,
  "description" "text" NOT NULL,
  "example_input" "text" NOT NULL,
  "example_output" "text" NOT NULL,
  "max_prompt_length" integer NOT NULL
);

ALTER TABLE
  "public"."nova_problems" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_sessions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "challenge_id" "uuid" NOT NULL,
  "status" "text" NOT NULL,
  "start_time" timestamp with time zone NOT NULL,
  "end_time" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_sessions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_submission_criteria" (
  "submission_id" "uuid" NOT NULL,
  "criteria_id" "uuid" NOT NULL,
  "score" real NOT NULL,
  "feedback" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "strengths" "text" [] DEFAULT '{}' :: "text" [],
  "improvements" "text" [] DEFAULT '{}' :: "text" [],
  CONSTRAINT "nova_submission_criteria_score_check" CHECK (
    (
      ("score" >= (0) :: double precision)
      AND ("score" <= (10) :: double precision)
    )
  )
);

ALTER TABLE
  "public"."nova_submission_criteria" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_submission_test_cases" (
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "output" "text" NOT NULL,
  "submission_id" "uuid" NOT NULL,
  "test_case_id" "uuid" NOT NULL,
  "matched" boolean DEFAULT false NOT NULL,
  "confidence" double precision DEFAULT 1.0,
  "reasoning" "text" DEFAULT '' :: "text"
);

ALTER TABLE
  "public"."nova_submission_test_cases" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_submissions" (
  "problem_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "prompt" "text" NOT NULL,
  "session_id" "uuid",
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "overall_assessment" "text" DEFAULT '' :: "text"
);

ALTER TABLE
  "public"."nova_submissions" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."nova_submissions_with_scores" AS WITH "problem_test_counts" AS (
  SELECT
    "nova_problem_test_cases"."problem_id",
    "count"(*) AS "total_tests"
  FROM
    "public"."nova_problem_test_cases"
  GROUP BY
    "nova_problem_test_cases"."problem_id"
),
"challenge_criteria_counts" AS (
  SELECT
    "p"."id" AS "problem_id",
    "count"("cc"."id") AS "total_criteria"
  FROM
    (
      "public"."nova_problems" "p"
      JOIN "public"."nova_challenge_criteria" "cc" ON (("p"."challenge_id" = "cc"."challenge_id"))
    )
  GROUP BY
    "p"."id"
),
"submission_test_stats" AS (
  SELECT
    "nova_submission_test_cases"."submission_id",
    "count"(*) FILTER (
      WHERE
        ("nova_submission_test_cases"."matched" = true)
    ) AS "passed_tests"
  FROM
    "public"."nova_submission_test_cases"
  GROUP BY
    "nova_submission_test_cases"."submission_id"
),
"submission_criteria_stats" AS (
  SELECT
    "nova_submission_criteria"."submission_id",
    "sum"("nova_submission_criteria"."score") AS "sum_criterion_score"
  FROM
    "public"."nova_submission_criteria"
  GROUP BY
    "nova_submission_criteria"."submission_id"
),
"problem_stats" AS (
  SELECT
    "p"."problem_id",
    "p"."total_tests",
    COALESCE("c"."total_criteria", (0) :: bigint) AS "total_criteria"
  FROM
    (
      "problem_test_counts" "p"
      LEFT JOIN "challenge_criteria_counts" "c" ON (("p"."problem_id" = "c"."problem_id"))
    )
),
"score_components" AS (
  SELECT
    "s_1"."id",
    "s_1"."problem_id",
    COALESCE("ps"."total_tests", (0) :: bigint) AS "total_tests",
    COALESCE("ts"."passed_tests", (0) :: bigint) AS "passed_tests",
    COALESCE("ps"."total_criteria", (0) :: bigint) AS "total_criteria",
    COALESCE("cs"."sum_criterion_score", (0) :: real) AS "sum_criterion_score",
    CASE
      WHEN (COALESCE("ps"."total_tests", (0) :: bigint) = 0) THEN (0) :: double precision
      ELSE (
        (
          (COALESCE("ts"."passed_tests", (0) :: bigint)) :: double precision / ("ps"."total_tests") :: double precision
        ) * (10) :: double precision
      )
    END AS "test_case_score",
    CASE
      WHEN (COALESCE("ps"."total_criteria", (0) :: bigint) = 0) THEN (0) :: double precision
      ELSE (
        (
          (COALESCE("cs"."sum_criterion_score", (0) :: real)) :: double precision / (("ps"."total_criteria" * 10)) :: double precision
        ) * (10) :: double precision
      )
    END AS "criteria_score"
  FROM
    (
      (
        (
          "public"."nova_submissions" "s_1"
          LEFT JOIN "problem_stats" "ps" ON (("s_1"."problem_id" = "ps"."problem_id"))
        )
        LEFT JOIN "submission_test_stats" "ts" ON (("s_1"."id" = "ts"."submission_id"))
      )
      LEFT JOIN "submission_criteria_stats" "cs" ON (("s_1"."id" = "cs"."submission_id"))
    )
)
SELECT
  "s"."problem_id",
  "s"."user_id",
  "s"."created_at",
  "s"."prompt",
  "s"."session_id",
  "s"."id",
  "sc"."total_tests",
  "sc"."passed_tests",
  "sc"."test_case_score",
  "sc"."total_criteria",
  "sc"."sum_criterion_score",
  "sc"."criteria_score",
  CASE
    WHEN (
      ("sc"."total_tests" > 0)
      AND ("sc"."total_criteria" > 0)
    ) THEN (
      ("sc"."test_case_score" + "sc"."criteria_score") * (0.5) :: double precision
    )
    WHEN ("sc"."total_tests" > 0) THEN "sc"."test_case_score"
    WHEN ("sc"."total_criteria" > 0) THEN "sc"."criteria_score"
    ELSE (0) :: double precision
  END AS "total_score"
FROM
  (
    "public"."nova_submissions" "s"
    JOIN "score_components" "sc" ON (("s"."id" = "sc"."id"))
  );

ALTER VIEW "public"."nova_submissions_with_scores" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_team_members" (
  "team_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_team_members" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_teams" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "description" "text",
  "goals" "text"
);

ALTER TABLE
  "public"."nova_teams" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."nova_team_challenge_leaderboard" WITH ("security_invoker" = 'true') AS WITH "user_best_problem_scores" AS (
  SELECT
    "s"."user_id",
    "s"."problem_id",
    "max"("s"."total_score") AS "best_score"
  FROM
    "public"."nova_submissions_with_scores" "s"
  GROUP BY
    "s"."user_id",
    "s"."problem_id"
),
"team_best_problem_scores" AS (
  SELECT
    "tm"."team_id",
    "ubps"."problem_id",
    "max"("ubps"."best_score") AS "best_score"
  FROM
    (
      "user_best_problem_scores" "ubps"
      JOIN "public"."nova_team_members" "tm" ON (("ubps"."user_id" = "tm"."user_id"))
    )
  GROUP BY
    "tm"."team_id",
    "ubps"."problem_id"
),
"problem_challenge_map" AS (
  SELECT
    "p"."id" AS "problem_id",
    "p"."challenge_id",
    "p"."title" AS "problem_title"
  FROM
    "public"."nova_problems" "p"
),
"team_problem_scores" AS (
  SELECT
    "tbps"."team_id",
    "pcm"."challenge_id",
    "tbps"."problem_id",
    "pcm"."problem_title",
    "tbps"."best_score" AS "score"
  FROM
    (
      "team_best_problem_scores" "tbps"
      JOIN "problem_challenge_map" "pcm" ON (("tbps"."problem_id" = "pcm"."problem_id"))
    )
),
"problem_scores_json" AS (
  SELECT
    "team_problem_scores"."team_id",
    "team_problem_scores"."challenge_id",
    "jsonb_agg"(
      "jsonb_build_object"(
        'id',
        "team_problem_scores"."problem_id",
        'title',
        "team_problem_scores"."problem_title",
        'score',
        "team_problem_scores"."score"
      )
    ) AS "problem_scores"
  FROM
    "team_problem_scores"
  GROUP BY
    "team_problem_scores"."team_id",
    "team_problem_scores"."challenge_id"
),
"team_challenge_scores" AS (
  SELECT
    "team_problem_scores"."team_id",
    "team_problem_scores"."challenge_id",
    "sum"("team_problem_scores"."score") AS "total_score"
  FROM
    "team_problem_scores"
  GROUP BY
    "team_problem_scores"."team_id",
    "team_problem_scores"."challenge_id"
)
SELECT
  "t"."id" AS "team_id",
  "t"."name",
  "tcs"."challenge_id",
  COALESCE("tcs"."total_score", (0) :: double precision) AS "score",
  COALESCE("psj"."problem_scores", '[]' :: "jsonb") AS "problem_scores"
FROM
  (
    (
      (
        "public"."nova_teams" "t"
        CROSS JOIN (
          SELECT
            DISTINCT "nova_challenges"."id"
          FROM
            "public"."nova_challenges"
        ) "c"
      )
      LEFT JOIN "team_challenge_scores" "tcs" ON (
        (
          ("t"."id" = "tcs"."team_id")
          AND ("c"."id" = "tcs"."challenge_id")
        )
      )
    )
    LEFT JOIN "problem_scores_json" "psj" ON (
      (
        ("t"."id" = "psj"."team_id")
        AND ("c"."id" = "psj"."challenge_id")
      )
    )
  )
ORDER BY
  COALESCE("tcs"."total_score", (0) :: double precision) DESC,
  "t"."name";

ALTER VIEW "public"."nova_team_challenge_leaderboard" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."nova_team_emails" (
  "team_id" "uuid" NOT NULL,
  "email" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."nova_team_emails" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."nova_team_leaderboard" WITH ("security_invoker" = 'true') AS WITH "user_best_problem_scores" AS (
  SELECT
    "s"."user_id",
    "s"."problem_id",
    "max"("s"."total_score") AS "best_score"
  FROM
    "public"."nova_submissions_with_scores" "s"
  GROUP BY
    "s"."user_id",
    "s"."problem_id"
),
"team_best_problem_scores" AS (
  SELECT
    "tm"."team_id",
    "ubps"."problem_id",
    "max"("ubps"."best_score") AS "best_score"
  FROM
    (
      "user_best_problem_scores" "ubps"
      JOIN "public"."nova_team_members" "tm" ON (("ubps"."user_id" = "tm"."user_id"))
    )
  GROUP BY
    "tm"."team_id",
    "ubps"."problem_id"
),
"problem_challenge_map" AS (
  SELECT
    "p"."id" AS "problem_id",
    "p"."challenge_id"
  FROM
    "public"."nova_problems" "p"
),
"team_challenge_scores" AS (
  SELECT
    "tbps"."team_id",
    "pcm"."challenge_id",
    "sum"("tbps"."best_score") AS "challenge_score"
  FROM
    (
      "team_best_problem_scores" "tbps"
      JOIN "problem_challenge_map" "pcm" ON (("tbps"."problem_id" = "pcm"."problem_id"))
    )
  GROUP BY
    "tbps"."team_id",
    "pcm"."challenge_id"
),
"challenge_scores_json" AS (
  SELECT
    "team_challenge_scores"."team_id",
    "jsonb_object_agg"(
      "team_challenge_scores"."challenge_id",
      "team_challenge_scores"."challenge_score"
    ) AS "challenge_scores"
  FROM
    "team_challenge_scores"
  GROUP BY
    "team_challenge_scores"."team_id"
),
"team_total_scores" AS (
  SELECT
    "team_challenge_scores"."team_id",
    "sum"("team_challenge_scores"."challenge_score") AS "total_score"
  FROM
    "team_challenge_scores"
  GROUP BY
    "team_challenge_scores"."team_id"
)
SELECT
  "t"."id" AS "team_id",
  "t"."name",
  COALESCE("tts"."total_score", (0) :: double precision) AS "score",
  COALESCE("csj"."challenge_scores", '{}' :: "jsonb") AS "challenge_scores"
FROM
  (
    (
      "public"."nova_teams" "t"
      LEFT JOIN "team_total_scores" "tts" ON (("t"."id" = "tts"."team_id"))
    )
    LEFT JOIN "challenge_scores_json" "csj" ON (("t"."id" = "csj"."team_id"))
  )
ORDER BY
  COALESCE("tts"."total_score", (0) :: double precision) DESC,
  "t"."name";

ALTER VIEW "public"."nova_team_leaderboard" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."nova_user_challenge_leaderboard" WITH ("security_invoker" = 'true') AS WITH "problem_best_submissions_per_session" AS (
  SELECT
    "s"."user_id",
    "s"."session_id",
    "s"."problem_id",
    "max"("s"."total_score") AS "best_score"
  FROM
    "public"."nova_submissions_with_scores" "s"
  GROUP BY
    "s"."user_id",
    "s"."session_id",
    "s"."problem_id"
),
"problem_challenge_map" AS (
  SELECT
    "p"."id" AS "problem_id",
    "p"."challenge_id",
    "p"."title" AS "problem_title"
  FROM
    "public"."nova_problems" "p"
),
"session_challenge_scores" AS (
  SELECT
    "pbs"."user_id",
    "pbs"."session_id",
    "pcm"."challenge_id",
    "sum"("pbs"."best_score") AS "session_score",
    "jsonb_agg"(
      "jsonb_build_object"(
        'id',
        "pbs"."problem_id",
        'title',
        "pcm"."problem_title",
        'score',
        "pbs"."best_score"
      )
    ) AS "problems_in_session"
  FROM
    (
      "problem_best_submissions_per_session" "pbs"
      JOIN "problem_challenge_map" "pcm" ON (("pbs"."problem_id" = "pcm"."problem_id"))
    )
  GROUP BY
    "pbs"."user_id",
    "pbs"."session_id",
    "pcm"."challenge_id"
),
"best_session_per_challenge" AS (
  SELECT
    DISTINCT ON (
      "session_challenge_scores"."user_id",
      "session_challenge_scores"."challenge_id"
    ) "session_challenge_scores"."user_id",
    "session_challenge_scores"."challenge_id",
    "session_challenge_scores"."session_id",
    "session_challenge_scores"."session_score",
    "session_challenge_scores"."problems_in_session"
  FROM
    "session_challenge_scores"
  ORDER BY
    "session_challenge_scores"."user_id",
    "session_challenge_scores"."challenge_id",
    "session_challenge_scores"."session_score" DESC
)
SELECT
  "u"."id" AS "user_id",
  COALESCE("u"."display_name", '' :: "text") AS "name",
  "u"."avatar_url" AS "avatar",
  "c"."id" AS "challenge_id",
  COALESCE("bs"."session_score", (0) :: double precision) AS "score",
  COALESCE("bs"."problems_in_session", '[]' :: "jsonb") AS "problem_scores"
FROM
  (
    (
      "public"."users" "u"
      CROSS JOIN (
        SELECT
          DISTINCT "nova_challenges"."id"
        FROM
          "public"."nova_challenges"
      ) "c"
    )
    LEFT JOIN "best_session_per_challenge" "bs" ON (
      (
        ("u"."id" = "bs"."user_id")
        AND ("c"."id" = "bs"."challenge_id")
      )
    )
  )
ORDER BY
  COALESCE("bs"."session_score", (0) :: double precision) DESC,
  COALESCE("u"."display_name", '' :: "text");

ALTER VIEW "public"."nova_user_challenge_leaderboard" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."nova_user_leaderboard" WITH ("security_invoker" = 'true') AS WITH "problem_best_submissions_per_session" AS (
  SELECT
    "s"."user_id",
    "s"."session_id",
    "s"."problem_id",
    "max"("s"."total_score") AS "best_score"
  FROM
    "public"."nova_submissions_with_scores" "s"
  GROUP BY
    "s"."user_id",
    "s"."session_id",
    "s"."problem_id"
),
"problem_challenge_map" AS (
  SELECT
    "p"."id" AS "problem_id",
    "p"."challenge_id"
  FROM
    "public"."nova_problems" "p"
),
"session_challenge_scores" AS (
  SELECT
    "pbs"."user_id",
    "pbs"."session_id",
    "pcm"."challenge_id",
    "sum"("pbs"."best_score") AS "session_score"
  FROM
    (
      "problem_best_submissions_per_session" "pbs"
      JOIN "problem_challenge_map" "pcm" ON (("pbs"."problem_id" = "pcm"."problem_id"))
    )
  GROUP BY
    "pbs"."user_id",
    "pbs"."session_id",
    "pcm"."challenge_id"
),
"best_session_per_challenge" AS (
  SELECT
    DISTINCT ON (
      "session_challenge_scores"."user_id",
      "session_challenge_scores"."challenge_id"
    ) "session_challenge_scores"."user_id",
    "session_challenge_scores"."challenge_id",
    "session_challenge_scores"."session_score"
  FROM
    "session_challenge_scores"
  ORDER BY
    "session_challenge_scores"."user_id",
    "session_challenge_scores"."challenge_id",
    "session_challenge_scores"."session_score" DESC
),
"challenge_scores_json" AS (
  SELECT
    "best_session_per_challenge"."user_id",
    "jsonb_object_agg"(
      "best_session_per_challenge"."challenge_id",
      "best_session_per_challenge"."session_score"
    ) AS "challenge_scores"
  FROM
    "best_session_per_challenge"
  GROUP BY
    "best_session_per_challenge"."user_id"
),
"user_total_scores" AS (
  SELECT
    "best_session_per_challenge"."user_id",
    "sum"("best_session_per_challenge"."session_score") AS "total_score"
  FROM
    "best_session_per_challenge"
  GROUP BY
    "best_session_per_challenge"."user_id"
)
SELECT
  "u"."id" AS "user_id",
  COALESCE("u"."display_name", '' :: "text") AS "name",
  "u"."avatar_url" AS "avatar",
  COALESCE("uts"."total_score", (0) :: double precision) AS "score",
  COALESCE("csj"."challenge_scores", '{}' :: "jsonb") AS "challenge_scores"
FROM
  (
    (
      "public"."users" "u"
      LEFT JOIN "user_total_scores" "uts" ON (("u"."id" = "uts"."user_id"))
    )
    LEFT JOIN "challenge_scores_json" "csj" ON (("u"."id" = "csj"."user_id"))
  )
ORDER BY
  COALESCE("uts"."total_score", (0) :: double precision) DESC,
  COALESCE("u"."display_name", '' :: "text");

ALTER VIEW "public"."nova_user_leaderboard" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."onboarding_progress" (
  "user_id" "uuid" NOT NULL,
  "completed_steps" "text" [] DEFAULT '{}' :: "text" [] NOT NULL,
  "current_step" "text" DEFAULT 'welcome' :: "text" NOT NULL,
  "workspace_name" "text",
  "workspace_description" "text",
  "workspace_avatar_url" "text",
  "profile_completed" boolean DEFAULT false NOT NULL,
  "tour_completed" boolean DEFAULT false NOT NULL,
  "completed_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "use_case" "text",
  "flow_type" "text" DEFAULT 'personal' :: "text",
  "invited_emails" "text" [] DEFAULT '{}' :: "text" [],
  "theme_preference" "text",
  "language_preference" "text",
  "notifications_enabled" boolean DEFAULT true,
  "team_workspace_id" "uuid",
  CONSTRAINT "valid_flow_type" CHECK (
    (
      "flow_type" = ANY (ARRAY ['personal'::"text", 'team'::"text"])
    )
  ),
  CONSTRAINT "valid_use_case" CHECK (
    (
      ("use_case" IS NULL)
      OR (
        "use_case" = ANY (
          ARRAY ['personal'::"text", 'small_team'::"text", 'large_team'::"text", 'exploring'::"text"]
        )
      )
    )
  )
);

ALTER TABLE
  "public"."onboarding_progress" OWNER TO "postgres";

COMMENT ON COLUMN "public"."onboarding_progress"."use_case" IS 'User selected use case: personal, small_team, large_team, or exploring';

COMMENT ON COLUMN "public"."onboarding_progress"."flow_type" IS 'Onboarding flow type: personal (quick) or team (extended)';

COMMENT ON COLUMN "public"."onboarding_progress"."invited_emails" IS 'Array of emails invited during onboarding';

COMMENT ON COLUMN "public"."onboarding_progress"."theme_preference" IS 'User theme preference: light, dark, or system';

COMMENT ON COLUMN "public"."onboarding_progress"."language_preference" IS 'User language preference: en, vi, etc.';

COMMENT ON COLUMN "public"."onboarding_progress"."notifications_enabled" IS 'Whether email notifications are enabled';

COMMENT ON COLUMN "public"."onboarding_progress"."team_workspace_id" IS 'Reference to team workspace created during onboarding (distinct from personal workspace)';

CREATE TABLE IF NOT EXISTS "public"."personal_notes" (
  "user_id" "uuid" NOT NULL,
  "owner_id" "uuid" NOT NULL,
  "content" "text",
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."personal_notes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."platform_email_roles" (
  "enabled" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "allow_challenge_management" boolean DEFAULT false NOT NULL,
  "allow_role_management" boolean DEFAULT false NOT NULL,
  "email" "extensions"."citext" NOT NULL,
  "allow_manage_all_challenges" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."platform_email_roles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."platform_user_roles" (
  "user_id" "uuid" NOT NULL,
  "enabled" boolean DEFAULT true NOT NULL,
  "allow_challenge_management" boolean DEFAULT false NOT NULL,
  "allow_manage_all_challenges" boolean DEFAULT false NOT NULL,
  "allow_role_management" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "allow_workspace_creation" boolean DEFAULT false NOT NULL,
  "allow_discord_integrations" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."platform_user_roles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."poll_guest_permissions" (
  "poll_id" "uuid" NOT NULL,
  "read_poll" boolean DEFAULT true NOT NULL,
  "update_poll" boolean DEFAULT true NOT NULL,
  "delete_poll" boolean DEFAULT true NOT NULL,
  "can_vote" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."poll_guest_permissions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."poll_guest_votes" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "guest_id" "uuid" NOT NULL,
  "option_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."poll_guest_votes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."poll_options" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "value" "text" DEFAULT '' :: "text" NOT NULL,
  "poll_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."poll_options" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."poll_user_permissions" (
  "poll_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "read_poll" boolean DEFAULT true NOT NULL,
  "update_poll" boolean DEFAULT true NOT NULL,
  "delete_poll" boolean DEFAULT true NOT NULL,
  "can_vote" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."poll_user_permissions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."poll_user_votes" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "option_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."poll_user_votes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."polls" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "plan_id" "uuid",
  "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc' :: "text") NOT NULL,
  "allow_anonymous_updates" boolean DEFAULT false NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "name" "text" DEFAULT '' :: "text" NOT NULL,
  "ws_id" "uuid"
);

ALTER TABLE
  "public"."polls" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sent_emails" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "sender_id" "uuid" NOT NULL,
  "receiver_id" "uuid" NOT NULL,
  "source_name" "text" NOT NULL,
  "source_email" "text" NOT NULL,
  "post_id" "uuid",
  "email" "text" NOT NULL,
  "content" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "subject" "text" NOT NULL,
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."sent_emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_group_posts" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "group_id" "uuid" NOT NULL,
  "title" "text" DEFAULT '' :: "text",
  "content" "text" DEFAULT '' :: "text",
  "notes" "text" DEFAULT '' :: "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."user_group_posts" OWNER TO "postgres";

CREATE MATERIALIZED VIEW "public"."posts_dashboard_view" AS
SELECT
  "ugpc"."post_id",
  "ugpc"."user_id",
  "ugpc"."email_id",
  "ugpc"."is_completed",
  "ugpc"."notes",
  "ugpc"."created_at",
  "wu"."ws_id",
  "wu"."email" AS "user_email",
  "wu"."display_name",
  "wu"."full_name",
  "ugp"."id" AS "post_id_full",
  "ugp"."title" AS "post_title",
  "ugp"."content" AS "post_content",
  "ugp"."created_at" AS "post_created_at",
  "wug"."id" AS "group_id",
  "wug"."name" AS "group_name",
  "se"."subject" AS "email_subject",
  "se"."created_at" AS "email_sent_at",
  COALESCE("wu"."full_name", "wu"."display_name") AS "recipient"
FROM
  (
    (
      (
        (
          "public"."user_group_post_checks" "ugpc"
          JOIN "public"."workspace_users" "wu" ON (("wu"."id" = "ugpc"."user_id"))
        )
        JOIN "public"."user_group_posts" "ugp" ON (("ugp"."id" = "ugpc"."post_id"))
      )
      LEFT JOIN "public"."workspace_user_groups" "wug" ON (("wug"."id" = "ugp"."group_id"))
    )
    LEFT JOIN "public"."sent_emails" "se" ON (("se"."id" = "ugpc"."email_id"))
  )
WHERE
  ("wu"."email" !~~* '%@easy%' :: "text") WITH NO DATA;

ALTER MATERIALIZED VIEW "public"."posts_dashboard_view" OWNER TO "postgres";

COMMENT ON MATERIALIZED VIEW "public"."posts_dashboard_view" IS 'Denormalized view for Posts dashboard with pre-joined data.
   Refresh using: SELECT refresh_posts_dashboard_view();
   Recommended refresh schedule: Every 5-15 minutes via cron job or trigger.';

CREATE TABLE IF NOT EXISTS "public"."product_categories" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."product_categories" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."product_stock_changes" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "product_id" "uuid" NOT NULL,
  "unit_id" "uuid" NOT NULL,
  "warehouse_id" "uuid" NOT NULL,
  "amount" bigint NOT NULL,
  "beneficiary_id" "uuid",
  "creator_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."product_stock_changes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."quiz_options" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "quiz_id" "uuid" NOT NULL,
  "value" "text" NOT NULL,
  "points" real,
  "is_correct" boolean NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "explanation" "text"
);

ALTER TABLE
  "public"."quiz_options" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."quiz_set_quizzes" (
  "set_id" "uuid" NOT NULL,
  "quiz_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."quiz_set_quizzes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."realtime_log_aggregations" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid",
  "channel_id" "text",
  "time_bucket" timestamp with time zone NOT NULL,
  "kind" "text" NOT NULL,
  "total_count" integer DEFAULT 0 NOT NULL,
  "error_count" integer DEFAULT 0 NOT NULL,
  "sample_messages" "text" [] DEFAULT '{}' :: "text" [],
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."realtime_log_aggregations" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."recording_sessions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "meeting_id" "uuid" NOT NULL,
  "status" "public"."recording_status" DEFAULT 'recording' :: "public"."recording_status" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."recording_sessions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."recording_transcripts" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "session_id" "uuid" NOT NULL,
  "text" "text" NOT NULL,
  "segments" "jsonb",
  "language" "text" DEFAULT 'en' :: "text" NOT NULL,
  "duration_in_seconds" integer DEFAULT 0 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."recording_transcripts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."recurring_transactions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "wallet_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "amount" numeric NOT NULL,
  "category_id" "uuid",
  "frequency" "public"."recurring_frequency" DEFAULT 'monthly' :: "public"."recurring_frequency" NOT NULL,
  "start_date" "date" NOT NULL,
  "end_date" "date",
  "next_occurrence" "date" NOT NULL,
  "last_occurrence" "date",
  "is_active" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."recurring_transactions" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."shortened_links_creator_stats" AS
SELECT
  "u"."id",
  "u"."display_name",
  "u"."avatar_url",
  "upd"."email",
  "count"("sl"."id") AS "link_count",
  "count"(DISTINCT "public"."extract_domain"("sl"."link")) AS "domain_count",
  "min"("sl"."created_at") AS "first_link_created",
  "max"("sl"."created_at") AS "last_link_created"
FROM
  (
    (
      "public"."users" "u"
      LEFT JOIN "public"."user_private_details" "upd" ON (("u"."id" = "upd"."user_id"))
    )
    JOIN "public"."shortened_links" "sl" ON (("u"."id" = "sl"."creator_id"))
  )
WHERE
  ("sl"."link" IS NOT NULL)
GROUP BY
  "u"."id",
  "u"."display_name",
  "u"."avatar_url",
  "upd"."email"
ORDER BY
  ("count"("sl"."id")) DESC;

ALTER VIEW "public"."shortened_links_creator_stats" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."shortened_links_domain_stats" AS
SELECT
  "public"."extract_domain"("link") AS "domain",
  "count"(*) AS "link_count",
  "count"(DISTINCT "creator_id") AS "creator_count",
  "min"("created_at") AS "first_created",
  "max"("created_at") AS "last_created"
FROM
  "public"."shortened_links"
WHERE
  (
    ("link" IS NOT NULL)
    AND ("link" <> '' :: "text")
    AND ("public"."extract_domain"("link") IS NOT NULL)
    AND ("public"."extract_domain"("link") <> '' :: "text")
  )
GROUP BY
  ("public"."extract_domain"("link"))
ORDER BY
  ("count"(*)) DESC;

ALTER VIEW "public"."shortened_links_domain_stats" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."support_inquiries" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "email" "text" NOT NULL,
  "subject" "text" NOT NULL,
  "message" "text" NOT NULL,
  "is_read" boolean DEFAULT false NOT NULL,
  "is_resolved" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "type" "public"."support_type" DEFAULT 'support' :: "public"."support_type" NOT NULL,
  "product" "public"."product" DEFAULT 'other' :: "public"."product" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "images" "text" [],
  CONSTRAINT "chk_support_inquiries_images_limit" CHECK (("array_length"("images", 1) <= 5))
);

ALTER TABLE
  "public"."support_inquiries" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_assignees" (
  "task_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_assignees" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_board_status_templates" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "statuses" "jsonb" NOT NULL,
  "is_default" boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_board_status_templates" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_calendar_events" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "task_id" "uuid" NOT NULL,
  "event_id" "uuid" NOT NULL,
  "scheduled_minutes" integer DEFAULT 0 NOT NULL,
  "completed" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_calendar_events" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_cycle_tasks" (
  "task_id" "uuid" NOT NULL,
  "cycle_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_cycle_tasks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_cycles" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "archived" boolean DEFAULT false,
  "deleted" boolean DEFAULT false,
  "status" "text" DEFAULT 'planned' :: "text",
  "start_date" "date",
  "end_date" "date",
  CONSTRAINT "task_cycles_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['planned'::"text", 'active'::"text", 'completed'::"text", 'cancelled'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."task_cycles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_history" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "task_id" "uuid",
  "changed_by" "uuid",
  "changed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "change_type" "text" NOT NULL,
  "field_name" "text",
  "old_value" "jsonb",
  "new_value" "jsonb",
  "metadata" "jsonb" DEFAULT '{}' :: "jsonb",
  "deleted_at" timestamp with time zone,
  CONSTRAINT "task_history_change_type_check" CHECK (
    (
      "change_type" = ANY (
        ARRAY ['task_created'::"text", 'field_updated'::"text", 'assignee_added'::"text", 'assignee_removed'::"text", 'label_added'::"text", 'label_removed'::"text", 'project_linked'::"text", 'project_unlinked'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."task_history" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_history" IS 'Permanent audit trail of all task changes including field updates, assignee changes, label changes, and project links';

COMMENT ON COLUMN "public"."task_history"."change_type" IS 'Type of change: field_updated, assignee_added/removed, label_added/removed, project_linked/unlinked';

COMMENT ON COLUMN "public"."task_history"."field_name" IS 'Name of the field that changed (for field_updated changes)';

COMMENT ON COLUMN "public"."task_history"."old_value" IS 'Previous value as JSONB (flexible format)';

COMMENT ON COLUMN "public"."task_history"."new_value" IS 'New value as JSONB (flexible format)';

COMMENT ON COLUMN "public"."task_history"."metadata" IS 'Additional context like workspace_id, board_id, list_id, etc.';

CREATE TABLE IF NOT EXISTS "public"."task_initiatives" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "archived" boolean DEFAULT false,
  "deleted" boolean DEFAULT false,
  "status" "text" DEFAULT 'active' :: "text",
  CONSTRAINT "task_initiatives_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['active'::"text", 'completed'::"text", 'on_hold'::"text", 'cancelled'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."task_initiatives" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_labels" (
  "task_id" "uuid" NOT NULL,
  "label_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."task_labels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_lists" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "archived" boolean DEFAULT false,
  "deleted" boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "board_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "status" "public"."task_board_status" DEFAULT 'not_started' :: "public"."task_board_status",
  "color" "text" DEFAULT 'GRAY' :: "text",
  "position" integer DEFAULT 0
);

ALTER TABLE
  "public"."task_lists" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_project_initiatives" (
  "project_id" "uuid" NOT NULL,
  "initiative_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_project_initiatives" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_project_tasks" (
  "task_id" "uuid" NOT NULL,
  "project_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."task_project_tasks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_project_update_attachments" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "update_id" "uuid" NOT NULL,
  "file_name" "text" NOT NULL,
  "file_path" "text" NOT NULL,
  "file_size" bigint NOT NULL,
  "mime_type" "text" NOT NULL,
  "uploaded_by" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "deleted_at" timestamp with time zone
);

ALTER TABLE
  "public"."task_project_update_attachments" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_project_update_attachments" IS 'File attachments for project updates (images, documents, etc.)';

COMMENT ON COLUMN "public"."task_project_update_attachments"."file_path" IS 'Storage path in Supabase storage bucket (workspaces/{ws_id}/project-updates/{file})';

CREATE TABLE IF NOT EXISTS "public"."task_project_update_comments" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "update_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "content" "text" NOT NULL,
  "parent_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "deleted_at" timestamp with time zone
);

ALTER TABLE
  "public"."task_project_update_comments" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_project_update_comments" IS 'Comments on project updates with optional threading support';

COMMENT ON COLUMN "public"."task_project_update_comments"."parent_id" IS 'Parent comment ID for threaded replies (NULL for top-level comments)';

CREATE TABLE IF NOT EXISTS "public"."task_project_update_reactions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "update_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "emoji" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."task_project_update_reactions" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_project_update_reactions" IS 'Emoji reactions on project updates (likes, hearts, etc.)';

CREATE TABLE IF NOT EXISTS "public"."task_project_updates" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "project_id" "uuid" NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "content" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "deleted_at" timestamp with time zone
);

ALTER TABLE
  "public"."task_project_updates" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_project_updates" IS 'Project updates feed - timeline of project progress and communication';

COMMENT ON COLUMN "public"."task_project_updates"."content" IS 'Rich text content stored as text (TipTap handles conversion)';

CREATE TABLE IF NOT EXISTS "public"."task_projects" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "archived" boolean DEFAULT false,
  "deleted" boolean DEFAULT false,
  "status" "text" DEFAULT 'active' :: "text",
  "description_yjs_state" "bytea",
  "priority" "public"."task_priority",
  "lead_id" "uuid",
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "health_status" "text",
  CONSTRAINT "chk_task_projects_health_status" CHECK (
    (
      "health_status" = ANY (
        ARRAY ['on_track'::"text", 'at_risk'::"text", 'off_track'::"text"]
      )
    )
  ),
  CONSTRAINT "chk_task_projects_start_le_end" CHECK (
    (
      ("start_date" IS NULL)
      OR ("end_date" IS NULL)
      OR ("start_date" <= "end_date")
    )
  ),
  CONSTRAINT "task_projects_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['backlog'::"text", 'planned'::"text", 'in_progress'::"text", 'in_review'::"text", 'in_testing'::"text", 'completed'::"text", 'cancelled'::"text", 'active'::"text", 'on_hold'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."task_projects" OWNER TO "postgres";

COMMENT ON COLUMN "public"."task_projects"."description" IS 'Rich text description stored as text (TipTap handles JSONContent conversion)';

COMMENT ON COLUMN "public"."task_projects"."description_yjs_state" IS 'Yjs CRDT state for real-time collaborative editing';

COMMENT ON COLUMN "public"."task_projects"."priority" IS 'Project priority: critical, high, normal, or low';

COMMENT ON COLUMN "public"."task_projects"."lead_id" IS 'User ID of the project lead (single person responsible)';

COMMENT ON COLUMN "public"."task_projects"."health_status" IS 'Project health indicator: on_track, at_risk, or off_track';

CREATE TABLE IF NOT EXISTS "public"."task_relationships" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "source_task_id" "uuid" NOT NULL,
  "target_task_id" "uuid" NOT NULL,
  "type" "public"."task_relationship_type" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_by" "uuid",
  CONSTRAINT "task_relationships_no_self_reference" CHECK (("source_task_id" <> "target_task_id"))
);

ALTER TABLE
  "public"."task_relationships" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_relationships" IS 'Unified table for task relationships: parent-child (sub-tasks), blocking dependencies, and related tasks';

COMMENT ON COLUMN "public"."task_relationships"."source_task_id" IS 'The source task. For parent_child: the parent. For blocks: the blocking task. For related: either task.';

COMMENT ON COLUMN "public"."task_relationships"."target_task_id" IS 'The target task. For parent_child: the child/sub-task. For blocks: the blocked task. For related: either task.';

COMMENT ON COLUMN "public"."task_relationships"."type" IS 'Type of relationship: parent_child (sub-task), blocks (dependency), or related (informational)';

CREATE TABLE IF NOT EXISTS "public"."task_reminder_sent" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "task_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "reminder_interval" "text" NOT NULL,
  "sent_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "notification_id" "uuid"
);

ALTER TABLE
  "public"."task_reminder_sent" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_reminder_sent" IS 'Tracks which deadline reminders have been sent to prevent duplicate notifications';

COMMENT ON COLUMN "public"."task_reminder_sent"."reminder_interval" IS 'The interval that was triggered (e.g., "24h", "1h", "30m")';

CREATE TABLE IF NOT EXISTS "public"."task_user_scheduling_settings" (
  "task_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "total_duration" real,
  "is_splittable" boolean DEFAULT false NOT NULL,
  "min_split_duration_minutes" real,
  "max_split_duration_minutes" real,
  "calendar_hours" "public"."calendar_hours",
  "auto_schedule" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."task_user_scheduling_settings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."task_watchers" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "task_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."task_watchers" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_watchers" IS 'Tracks users who are watching tasks for notifications (due date reminders, updates, etc.)';

CREATE TABLE IF NOT EXISTS "public"."tasks" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "list_id" "uuid",
  "completed" boolean DEFAULT false,
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "start_date" timestamp with time zone,
  "end_date" timestamp with time zone,
  "description" "text",
  "priority" "public"."task_priority" DEFAULT 'normal' :: "public"."task_priority",
  "estimation_points" smallint,
  "embedding" "extensions"."vector"(768),
  "fts" "tsvector" GENERATED ALWAYS AS (
    (
      "setweight"(
        "to_tsvector"(
          '"english"' :: "regconfig",
          COALESCE("name", '' :: "text")
        ),
        'A' :: "char"
      ) || "setweight"(
        "to_tsvector"(
          '"english"' :: "regconfig",
          COALESCE("description", '' :: "text")
        ),
        'B' :: "char"
      )
    )
  ) STORED,
  "sort_key" bigint DEFAULT 1000000000,
  "description_yjs_state" smallint [],
  "completed_at" timestamp with time zone,
  "closed_at" timestamp with time zone,
  "deleted_at" timestamp with time zone,
  "display_number" integer,
  "board_id" "uuid",
  CONSTRAINT "tasks_estimation_points_check" CHECK (
    (
      ("estimation_points" >= 0)
      AND ("estimation_points" <= 8)
    )
  )
);

ALTER TABLE
  "public"."tasks" OWNER TO "postgres";

COMMENT ON COLUMN "public"."tasks"."embedding" IS 'Google Gemini gemini-embedding-001 embedding vector (768 dimensions, SEMANTIC_SIMILARITY task type, using Matryoshka Representation Learning)';

COMMENT ON COLUMN "public"."tasks"."sort_key" IS 'BIGINT sort key for task ordering within lists. Uses integer math (multiply by 1000 compared to old DOUBLE PRECISION values) for exact precision without floating-point errors. Default spacing: 1000000 units apart.';

COMMENT ON COLUMN "public"."tasks"."completed_at" IS 'Timestamp when the task was marked as completed (moved to a done list)';

COMMENT ON COLUMN "public"."tasks"."closed_at" IS 'Timestamp when the task was marked as closed (moved to a closed list)';

COMMENT ON COLUMN "public"."tasks"."deleted_at" IS 'Timestamp when the task was soft-deleted (null means not deleted)';

COMMENT ON COLUMN "public"."tasks"."display_number" IS 'Sequential number within the board. Combined with board ticket_prefix to form human-readable ticket identifier.';

COMMENT ON COLUMN "public"."tasks"."board_id" IS 'Denormalized board_id from task_lists for efficient indexing and querying. Automatically maintained by trigger.';

CREATE TABLE IF NOT EXISTS "public"."team_members" (
  "team_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."team_members" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."time_tracker_daily_activity" AS WITH "session_days" AS (
  SELECT
    "s"."id",
    "s"."user_id",
    "s"."ws_id",
    "s"."start_time",
    "s"."end_time",
    "s"."duration_seconds",
    (
      "generate_series"(
        ("date"("s"."start_time")) :: timestamp with time zone,
        (
          "date"(COALESCE("s"."end_time", "s"."start_time"))
        ) :: timestamp with time zone,
        '1 day' :: interval
      )
    ) :: "date" AS "activity_date"
  FROM
    "public"."time_tracking_sessions" "s"
  WHERE
    ("s"."duration_seconds" IS NOT NULL)
)
SELECT
  "user_id",
  "ws_id",
  "activity_date",
  "sum"(
    CASE
      WHEN (
        "date"("start_time") = "date"(COALESCE("end_time", "start_time"))
      ) THEN ("duration_seconds") :: bigint
      ELSE (
        EXTRACT(
          epoch
          FROM
            (
              LEAST(
                (("activity_date" + '1 day' :: interval)) :: timestamp with time zone,
                COALESCE("end_time", CURRENT_TIMESTAMP)
              ) - GREATEST(
                (("activity_date") :: timestamp without time zone) :: timestamp with time zone,
                "start_time"
              )
            )
        )
      ) :: bigint
    END
  ) AS "total_duration",
  "count"(DISTINCT "id") AS "session_count"
FROM
  "session_days" "sd"
GROUP BY
  "user_id",
  "ws_id",
  "activity_date";

ALTER VIEW "public"."time_tracker_daily_activity" OWNER TO "postgres";

COMMENT ON VIEW "public"."time_tracker_daily_activity" IS 'Aggregates time tracking sessions by user, workspace, and date (UTC). Properly splits sessions that cross multiple days, calculating the exact duration that falls on each day.';

CREATE TABLE IF NOT EXISTS "public"."time_tracking_breaks" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "session_id" "uuid" NOT NULL,
  "break_type_id" "uuid",
  "break_type_name" "text",
  "break_start" timestamp with time zone NOT NULL,
  "break_end" timestamp with time zone,
  "break_duration_seconds" integer,
  "notes" "text",
  "created_by" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  CONSTRAINT "time_tracking_breaks_duration_match" CHECK (
    (
      ("break_duration_seconds" IS NULL)
      OR ("break_end" IS NULL)
      OR (
        "break_duration_seconds" = (
          EXTRACT(
            epoch
            FROM
              ("break_end" - "break_start")
          )
        ) :: integer
      )
    )
  ),
  CONSTRAINT "time_tracking_breaks_valid_duration" CHECK (
    (
      ("break_end" IS NULL)
      OR ("break_end" > "break_start")
    )
  )
);

ALTER TABLE
  "public"."time_tracking_breaks" OWNER TO "postgres";

COMMENT ON TABLE "public"."time_tracking_breaks" IS 'Individual break records within work sessions. Created when user pauses, completed when resumed. Links to parent session, not the paused session record.';

CREATE TABLE IF NOT EXISTS "public"."time_tracking_categories" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "color" "text" DEFAULT 'BLUE' :: "text",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."time_tracking_categories" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."time_tracking_goals" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "category_id" "uuid",
  "daily_goal_minutes" integer DEFAULT 480 NOT NULL,
  "weekly_goal_minutes" integer,
  "is_active" boolean DEFAULT true,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."time_tracking_goals" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."time_tracking_requests" (
  "id" "uuid" NOT NULL,
  "workspace_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "task_id" "uuid",
  "category_id" "uuid",
  "title" "text" NOT NULL,
  "description" "text",
  "start_time" timestamp with time zone NOT NULL,
  "end_time" timestamp with time zone NOT NULL,
  "images" "text" [],
  "approval_status" "public"."time_tracking_request_status" DEFAULT 'PENDING' :: "public"."time_tracking_request_status" NOT NULL,
  "approved_by" "uuid",
  "approved_at" timestamp with time zone,
  "rejected_by" "uuid",
  "rejected_at" timestamp with time zone,
  "rejection_reason" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "break_type_id" "uuid",
  "break_type_name" "text",
  "linked_session_id" "uuid",
  CONSTRAINT "chk_approved_data" CHECK (
    (
      (
        "approval_status" <> 'APPROVED' :: "public"."time_tracking_request_status"
      )
      OR (
        ("approved_by" IS NOT NULL)
        AND ("approved_at" IS NOT NULL)
      )
    )
  ),
  CONSTRAINT "chk_pending_data" CHECK (
    (
      (
        "approval_status" <> 'PENDING' :: "public"."time_tracking_request_status"
      )
      OR (
        ("approved_by" IS NULL)
        AND ("approved_at" IS NULL)
        AND ("rejected_by" IS NULL)
        AND ("rejected_at" IS NULL)
        AND ("rejection_reason" IS NULL)
      )
    )
  ),
  CONSTRAINT "chk_rejected_data" CHECK (
    (
      (
        "approval_status" <> 'REJECTED' :: "public"."time_tracking_request_status"
      )
      OR (
        ("rejected_by" IS NOT NULL)
        AND ("rejection_reason" IS NOT NULL)
      )
    )
  ),
  CONSTRAINT "chk_time_tracking_requests_images_limit" CHECK (("array_length"("images", 1) <= 5))
);

ALTER TABLE
  "public"."time_tracking_requests" OWNER TO "postgres";

COMMENT ON COLUMN "public"."time_tracking_requests"."break_type_id" IS 'Break type to create when this request is approved. Linked to workspace_break_types.';

COMMENT ON COLUMN "public"."time_tracking_requests"."break_type_name" IS 'Custom break type name when break_type_id is null (denormalized for historical data).';

COMMENT ON COLUMN "public"."time_tracking_requests"."linked_session_id" IS 'References an existing session that this request is approving. Used for break pauses where the session needs to remain for the break record. On approval, the session becomes visible; on rejection, the session is deleted.';

CREATE
OR REPLACE VIEW "public"."time_tracking_session_analytics" AS
SELECT
  "tts"."id",
  "tts"."ws_id",
  "tts"."user_id",
  "tts"."task_id",
  "tts"."category_id",
  "tts"."title",
  "tts"."description",
  "tts"."start_time",
  "tts"."end_time",
  "tts"."duration_seconds",
  "tts"."is_running",
  "tts"."tags",
  "tts"."created_at",
  "tts"."updated_at",
  "tts"."productivity_score",
  "tts"."was_resumed",
  "ttc"."name" AS "category_name",
  "ttc"."color" AS "category_color",
  "t"."name" AS "task_name",
  EXTRACT(
    hour
    FROM
      "tts"."start_time"
  ) AS "start_hour",
  EXTRACT(
    dow
    FROM
      "tts"."start_time"
  ) AS "day_of_week",
  "date_trunc"('day' :: "text", "tts"."start_time") AS "session_date",
  "date_trunc"('week' :: "text", "tts"."start_time") AS "session_week",
  "date_trunc"('month' :: "text", "tts"."start_time") AS "session_month",
  CASE
    WHEN ("tts"."duration_seconds" >= 7200) THEN 'long' :: "text"
    WHEN ("tts"."duration_seconds" >= 1800) THEN 'medium' :: "text"
    WHEN ("tts"."duration_seconds" >= 300) THEN 'short' :: "text"
    ELSE 'micro' :: "text"
  END AS "session_length_category"
FROM
  (
    (
      "public"."time_tracking_sessions" "tts"
      LEFT JOIN "public"."time_tracking_categories" "ttc" ON (("tts"."category_id" = "ttc"."id"))
    )
    LEFT JOIN "public"."tasks" "t" ON (("tts"."task_id" = "t"."id"))
  );

ALTER VIEW "public"."time_tracking_session_analytics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."timezones" (
  "value" "text" NOT NULL,
  "abbr" "text" NOT NULL,
  "offset" real NOT NULL,
  "isdst" boolean NOT NULL,
  "text" "text" NOT NULL,
  "utc" "text" [] NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."timezones" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."transaction_categories" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "is_expense" boolean DEFAULT true,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."transaction_categories" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."transaction_tags" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "color" "text" DEFAULT '#6366f1' :: "text" NOT NULL,
  "description" "text",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."transaction_tags" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_feedbacks" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "group_id" "uuid",
  "content" "text" NOT NULL,
  "creator_id" "uuid",
  "require_attention" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."user_feedbacks" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_group_linked_products" (
  "group_id" "uuid" NOT NULL,
  "product_id" "uuid" NOT NULL,
  "unit_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "warehouse_id" "uuid"
);

ALTER TABLE
  "public"."user_group_linked_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_group_tag_groups" (
  "tag_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "group_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_user_group_tag_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_group_tags" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "color" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_user_group_tags" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."user_groups_with_tags" WITH ("security_invoker" = 'on') AS
SELECT
  "id",
  "ws_id",
  "name",
  "created_at",
  "archived",
  "ending_date",
  "notes",
  "sessions",
  "starting_date",
  (
    SELECT
      "json_agg"("wugt"."id") AS "json_agg"
    FROM
      (
        "public"."workspace_user_group_tags" "wugt"
        JOIN "public"."workspace_user_group_tag_groups" "wugtg" ON (("wugt"."id" = "wugtg"."tag_id"))
      )
    WHERE
      ("wugtg"."group_id" = "wugt"."id")
  ) AS "tags",
  (
    SELECT
      "count"(*) AS "count"
    FROM
      (
        "public"."workspace_user_group_tags" "wugt"
        JOIN "public"."workspace_user_group_tag_groups" "wugtg" ON (("wugt"."id" = "wugtg"."tag_id"))
      )
    WHERE
      ("wugtg"."group_id" = "wugt"."id")
  ) AS "tag_count"
FROM
  "public"."workspace_user_groups" "wug";

ALTER VIEW "public"."user_groups_with_tags" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_indicators" (
  "user_id" "uuid" NOT NULL,
  "indicator_id" "uuid" NOT NULL,
  "value" numeric,
  "creator_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."user_indicators" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_linked_promotions" (
  "user_id" "uuid" NOT NULL,
  "promo_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."user_linked_promotions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_promotions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" DEFAULT '' :: "text",
  "description" "text" DEFAULT '' :: "text",
  "value" integer NOT NULL,
  "use_ratio" boolean DEFAULT false NOT NULL,
  "code" "text" DEFAULT '' :: "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "owner_id" "uuid",
  "promo_type" "public"."promotion_type" DEFAULT 'REGULAR' :: "public"."promotion_type" NOT NULL,
  CONSTRAINT "chk_referral_promo_must_have_owner" CHECK (
    (
      (
        "promo_type" <> 'REFERRAL' :: "public"."promotion_type"
      )
      OR ("owner_id" IS NOT NULL)
    )
  ),
  CONSTRAINT "chk_regular_promo_has_no_owner" CHECK (
    (
      (
        "promo_type" <> 'REGULAR' :: "public"."promotion_type"
      )
      OR ("owner_id" IS NULL)
    )
  )
);

ALTER TABLE
  "public"."workspace_promotions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_settings" (
  "ws_id" "uuid" NOT NULL,
  "referral_increment_percent" integer DEFAULT 5 NOT NULL,
  "referral_count_cap" integer DEFAULT 3 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "referral_promotion_id" "uuid",
  "guest_user_checkup_threshold" smallint,
  "missed_entry_date_threshold" integer,
  "break_enabled" boolean DEFAULT false,
  "break_duration_minutes" integer DEFAULT 15,
  "break_interval_minutes" integer DEFAULT 90,
  CONSTRAINT "chk_missed_entry_date_threshold" CHECK (("missed_entry_date_threshold" >= 0)),
  CONSTRAINT "workspace_settings_break_duration_check" CHECK (
    (
      ("break_duration_minutes" IS NULL)
      OR (
        ("break_duration_minutes" >= 5)
        AND (("break_duration_minutes" % 5) = 0)
      )
    )
  ),
  CONSTRAINT "workspace_settings_break_interval_check" CHECK (
    (
      ("break_interval_minutes" IS NULL)
      OR (
        ("break_interval_minutes" >= 15)
        AND (("break_interval_minutes" % 5) = 0)
      )
    )
  ),
  CONSTRAINT "workspace_settings_guest_user_checkup_threshold_check" CHECK (("guest_user_checkup_threshold" > 0))
);

ALTER TABLE
  "public"."workspace_settings" OWNER TO "postgres";

COMMENT ON COLUMN "public"."workspace_settings"."missed_entry_date_threshold" IS 'Setting for the maximum time before needing to request a time-entry to be added. NULL = no approval needed (default), 0 = all entries require approval, >0 = entries older than N days require approval';

COMMENT ON COLUMN "public"."workspace_settings"."break_enabled" IS 'Whether automatic breaks are enabled for this workspace';

COMMENT ON COLUMN "public"."workspace_settings"."break_duration_minutes" IS 'Duration of each break in minutes (must be multiple of 5, minimum 5)';

COMMENT ON COLUMN "public"."workspace_settings"."break_interval_minutes" IS 'Time between breaks in minutes - i.e., work duration before a break (must be multiple of 5, minimum 15)';

CREATE
OR REPLACE VIEW "public"."v_user_referral_discounts" AS WITH "referral_counts" AS (
  SELECT
    "workspace_users"."referred_by" AS "user_id",
    "count"(*) AS "active_referral_count"
  FROM
    "public"."workspace_users"
  WHERE
    (
      ("workspace_users"."referred_by" IS NOT NULL)
      AND ("workspace_users"."archived" = false)
    )
  GROUP BY
    "workspace_users"."referred_by"
)
SELECT
  "p"."id" AS "promo_id",
  "p"."owner_id" AS "user_id",
  "p"."code" AS "promo_code",
  (
    LEAST(
      COALESCE("rc"."active_referral_count", (0) :: bigint),
      ("s"."referral_count_cap") :: bigint
    ) * "s"."referral_increment_percent"
  ) AS "calculated_discount_value",
  "p"."ws_id"
FROM
  (
    (
      "public"."workspace_promotions" "p"
      LEFT JOIN "referral_counts" "rc" ON (("p"."owner_id" = "rc"."user_id"))
    )
    JOIN "public"."workspace_settings" "s" ON (("p"."ws_id" = "s"."ws_id"))
  )
WHERE
  (
    "p"."promo_type" = 'REFERRAL' :: "public"."promotion_type"
  );

ALTER VIEW "public"."v_user_referral_discounts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."vital_group_vitals" (
  "group_id" "uuid" NOT NULL,
  "vital_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."vital_group_vitals" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."wallet_transaction_tags" (
  "transaction_id" "uuid" NOT NULL,
  "tag_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."wallet_transaction_tags" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."wallet_transactions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "amount" numeric DEFAULT '0' :: numeric,
  "description" "text",
  "wallet_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "category_id" "uuid",
  "taken_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "report_opt_in" boolean DEFAULT true NOT NULL,
  "creator_id" "uuid",
  "invoice_id" "uuid",
  "is_amount_confidential" boolean DEFAULT false NOT NULL,
  "is_description_confidential" boolean DEFAULT false NOT NULL,
  "is_category_confidential" boolean DEFAULT false NOT NULL
);

ALTER TABLE
  "public"."wallet_transactions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_wallets" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "balance" numeric DEFAULT '0' :: numeric,
  "description" "text",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "ws_id" "uuid" NOT NULL,
  "type" "text" DEFAULT 'STANDARD' :: "text" NOT NULL,
  "currency" "text" DEFAULT 'VND' :: "text" NOT NULL,
  "report_opt_in" boolean DEFAULT true NOT NULL
);

ALTER TABLE
  "public"."workspace_wallets" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."wallet_transactions_secure" WITH ("security_invoker" = 'true') AS
SELECT
  "id",
  CASE
    WHEN (
      "is_amount_confidential"
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_wallets" "ww"
            WHERE
              (
                ("ww"."id" = "wt"."wallet_id")
                AND "public"."has_workspace_permission"(
                  "ww"."ws_id",
                  "auth"."uid"(),
                  'view_confidential_amount' :: "text"
                )
              )
          )
        )
      )
    ) THEN NULL :: numeric
    ELSE "amount"
  END AS "amount",
  CASE
    WHEN (
      "is_category_confidential"
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_wallets" "ww"
            WHERE
              (
                ("ww"."id" = "wt"."wallet_id")
                AND "public"."has_workspace_permission"(
                  "ww"."ws_id",
                  "auth"."uid"(),
                  'view_confidential_category' :: "text"
                )
              )
          )
        )
      )
    ) THEN NULL :: "uuid"
    ELSE "category_id"
  END AS "category_id",
  "created_at",
  "creator_id",
  CASE
    WHEN (
      "is_description_confidential"
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_wallets" "ww"
            WHERE
              (
                ("ww"."id" = "wt"."wallet_id")
                AND "public"."has_workspace_permission"(
                  "ww"."ws_id",
                  "auth"."uid"(),
                  'view_confidential_description' :: "text"
                )
              )
          )
        )
      )
    ) THEN '[CONFIDENTIAL]' :: "text"
    ELSE "description"
  END AS "description",
  "invoice_id",
  "report_opt_in",
  "taken_at",
  "wallet_id",
  "is_amount_confidential",
  "is_description_confidential",
  "is_category_confidential"
FROM
  "public"."wallet_transactions" "wt";

ALTER VIEW "public"."wallet_transactions_secure" OWNER TO "postgres";

COMMENT ON VIEW "public"."wallet_transactions_secure" IS 'Secure view of wallet_transactions with automatic field-level redaction based on user permissions. Always use this view instead of querying the base table directly to ensure confidential fields are properly redacted.';

CREATE TABLE IF NOT EXISTS "public"."wallet_types" ("id" "text" NOT NULL);

ALTER TABLE
  "public"."wallet_types" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_ai_executions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "api_key_id" "uuid" NOT NULL,
  "system_prompt" "text" NOT NULL,
  "input" "text" NOT NULL,
  "output" "text" NOT NULL,
  "input_tokens" integer NOT NULL,
  "output_tokens" integer NOT NULL,
  "reasoning_tokens" integer NOT NULL,
  "total_tokens" integer NOT NULL,
  "finish_reason" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "model_id" "text" NOT NULL
);

ALTER TABLE
  "public"."workspace_ai_executions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_ai_models" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "url" "text" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_ai_models" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_ai_prompts" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "input" "text" NOT NULL,
  "output" "text" NOT NULL,
  "model" "text" NOT NULL,
  "ws_id" "uuid",
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_ai_prompts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_api_key_usage_logs" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "api_key_id" "uuid" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "endpoint" "text" NOT NULL,
  "method" "text" NOT NULL,
  "status_code" integer NOT NULL,
  "ip_address" "text",
  "user_agent" "text",
  "response_time_ms" integer,
  "request_params" "jsonb",
  "error_message" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_api_key_usage_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_api_key_usage_logs" IS 'Detailed usage logs for API keys with 90-day retention';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."api_key_id" IS 'Reference to the API key that was used';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."ws_id" IS 'Reference to the workspace';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."endpoint" IS 'The API endpoint that was called (e.g., /api/v1/workspaces/[wsId]/datasets)';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."method" IS 'HTTP method used (GET, POST, PUT, DELETE, etc.)';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."status_code" IS 'HTTP response status code (200, 401, 500, etc.)';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."ip_address" IS 'IP address of the client making the request';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."user_agent" IS 'User agent string from the request';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."response_time_ms" IS 'Response time in milliseconds';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."request_params" IS 'Request parameters (query params and body) stored as JSONB';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."error_message" IS 'Error message if the request failed';

COMMENT ON COLUMN "public"."workspace_api_key_usage_logs"."created_at" IS 'Timestamp when the request was made';

CREATE TABLE IF NOT EXISTS "public"."workspace_api_keys" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "name" "text" NOT NULL,
  "scopes" "public"."workspace_api_key_scope" [] DEFAULT '{}' :: "public"."workspace_api_key_scope" [] NOT NULL,
  "key_hash" "text",
  "key_prefix" "text",
  "description" "text",
  "role_id" "uuid",
  "last_used_at" timestamp with time zone,
  "expires_at" timestamp with time zone,
  "created_by" "uuid",
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_api_keys" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_api_keys" IS 'API keys for external SDK authentication with role-based permissions. Uses secure scrypt-based key_hash storage.';

COMMENT ON COLUMN "public"."workspace_api_keys"."key_hash" IS 'Scrypt hash of the API key for secure storage';

COMMENT ON COLUMN "public"."workspace_api_keys"."key_prefix" IS 'First 12 characters of key (ttr_xxxx) for identification without exposing full key';

COMMENT ON COLUMN "public"."workspace_api_keys"."role_id" IS 'Workspace role that determines permissions for this API key';

COMMENT ON COLUMN "public"."workspace_api_keys"."last_used_at" IS 'Timestamp of when this key was last used for API requests';

COMMENT ON COLUMN "public"."workspace_api_keys"."expires_at" IS 'Optional expiration date for the API key';

CREATE TABLE IF NOT EXISTS "public"."workspace_boards" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "ws_id" "uuid" NOT NULL,
  "template_id" "uuid",
  "estimation_type" "public"."estimation_type",
  "extended_estimation" boolean DEFAULT false NOT NULL,
  "allow_zero_estimates" boolean DEFAULT true NOT NULL,
  "count_unestimated_issues" boolean DEFAULT false NOT NULL,
  "deleted_at" timestamp with time zone,
  "archived_at" timestamp with time zone,
  "ticket_prefix" "text",
  "next_task_number" integer DEFAULT 1 NOT NULL,
  "icon" "public"."workspace_board_icon"
);

ALTER TABLE
  "public"."workspace_boards" OWNER TO "postgres";

COMMENT ON COLUMN "public"."workspace_boards"."allow_zero_estimates" IS 'When enabled, issues can be estimated with zero points';

COMMENT ON COLUMN "public"."workspace_boards"."count_unestimated_issues" IS 'When enabled, unestimated issues count as 1 estimate point. When disabled, they count as 0';

COMMENT ON COLUMN "public"."workspace_boards"."deleted_at" IS 'Timestamp when the board was soft deleted. NULL means the board is active.';

COMMENT ON COLUMN "public"."workspace_boards"."archived_at" IS 'Timestamp when the board was archived. NULL means the board is active (not archived).';

COMMENT ON COLUMN "public"."workspace_boards"."ticket_prefix" IS 'Custom prefix for task ticket identifiers (e.g., "DEV", "BUG"). Combined with display_number to form ticket ID like "DEV-42".';

COMMENT ON COLUMN "public"."workspace_boards"."next_task_number" IS 'Persistent counter for the next task number. Never resets, even if all tasks are deleted. Atomically incremented by trigger.';

CREATE TABLE IF NOT EXISTS "public"."workspace_break_types" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "color" "text" DEFAULT 'AMBER' :: "text",
  "icon" "text",
  "is_default" boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  CONSTRAINT "workspace_break_types_color_check" CHECK (
    (
      "color" = ANY (
        ARRAY ['RED'::"text", 'ORANGE'::"text", 'AMBER'::"text", 'YELLOW'::"text", 'LIME'::"text", 'GREEN'::"text", 'EMERALD'::"text", 'TEAL'::"text", 'CYAN'::"text", 'SKY'::"text", 'BLUE'::"text", 'INDIGO'::"text", 'VIOLET'::"text", 'PURPLE'::"text", 'FUCHSIA'::"text", 'PINK'::"text", 'ROSE'::"text", 'SLATE'::"text", 'GRAY'::"text", 'ZINC'::"text", 'NEUTRAL'::"text", 'STONE'::"text"]
      )
    )
  ),
  CONSTRAINT "workspace_break_types_name_check" CHECK (
    (
      ("char_length"("name") >= 1)
      AND ("char_length"("name") <= 50)
    )
  )
);

ALTER TABLE
  "public"."workspace_break_types" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_break_types" IS 'Custom break type definitions per workspace. System types (coffee, lunch, personal, meeting) are created by default.';

CREATE TABLE IF NOT EXISTS "public"."workspace_calendar_categories" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "color" "text" DEFAULT 'BLUE' :: "text" NOT NULL,
  "position" integer DEFAULT 0 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_calendar_categories" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_calendar_events" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "title" "text" DEFAULT '' :: "text" NOT NULL,
  "description" "text" DEFAULT '' :: "text" NOT NULL,
  "start_at" timestamp with time zone NOT NULL,
  "end_at" timestamp with time zone NOT NULL,
  "color" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "locked" boolean DEFAULT false NOT NULL,
  "location" "text",
  "google_event_id" "text",
  "task_id" "uuid",
  "google_calendar_id" "text",
  "is_encrypted" boolean DEFAULT false NOT NULL,
  "source_calendar_id" "uuid",
  "external_calendar_id" "text",
  "external_event_id" "text",
  "provider" "public"."calendar_provider" DEFAULT 'tuturuuu' :: "public"."calendar_provider",
  "scheduling_source" "public"."calendar_scheduling_source" DEFAULT 'manual' :: "public"."calendar_scheduling_source",
  "scheduling_metadata" "jsonb"
);

ALTER TABLE
  "public"."workspace_calendar_events" OWNER TO "postgres";

COMMENT ON COLUMN "public"."workspace_calendar_events"."google_event_id" IS 'DEPRECATED: Use external_event_id with provider=google instead';

COMMENT ON COLUMN "public"."workspace_calendar_events"."google_calendar_id" IS 'DEPRECATED: Use external_calendar_id with provider=google instead';

CREATE TABLE IF NOT EXISTS "public"."workspace_calendar_hour_settings" (
  "ws_id" "uuid" NOT NULL,
  "type" "public"."calendar_hour_type" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "data" "jsonb" NOT NULL
);

ALTER TABLE
  "public"."workspace_calendar_hour_settings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_calendar_sync_coordination" (
  "ws_id" "uuid" NOT NULL,
  "last_upsert" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_calendar_sync_coordination" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_calendar_sync_log" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "google_account_email" "text",
  "sync_started_at" timestamp with time zone NOT NULL,
  "sync_ended_at" timestamp with time zone,
  "status" "text" NOT NULL,
  "error_message" "text",
  "event_snapshot_before" "jsonb" NOT NULL,
  "upserted_events" "jsonb",
  "deleted_events" "jsonb",
  "triggered_by" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  CONSTRAINT "workspace_calendar_sync_log_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['success'::"text", 'failed'::"text", 'in_progress'::"text", 'cancelled'::"text", 'partial_success'::"text"]
      )
    )
  ),
  CONSTRAINT "workspace_calendar_sync_log_timestamps_check" CHECK (
    (
      ("sync_ended_at" IS NULL)
      OR ("sync_ended_at" >= "sync_started_at")
    )
  ),
  CONSTRAINT "workspace_calendar_sync_log_triggered_by_check" CHECK (
    (
      "triggered_by" = ANY (
        ARRAY ['active_sync'::"text", 'trigger_dot_dev'::"text", 'manual'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."workspace_calendar_sync_log" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_calendars" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "color" "text",
  "calendar_type" "public"."workspace_calendar_type" DEFAULT 'custom' :: "public"."workspace_calendar_type" NOT NULL,
  "is_system" boolean DEFAULT false NOT NULL,
  "is_enabled" boolean DEFAULT true NOT NULL,
  "position" integer DEFAULT 0 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_calendars" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_chat_channels" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "is_private" boolean DEFAULT false,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "created_by" "uuid",
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_chat_channels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_chat_messages" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "channel_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "content" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "deleted_at" timestamp with time zone
);

ALTER TABLE
  "public"."workspace_chat_messages" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_chat_participants" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "channel_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "joined_at" timestamp with time zone DEFAULT "now"(),
  "last_read_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_chat_participants" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_chat_typing_indicators" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "channel_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_chat_typing_indicators" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_configs" (
  "id" "text" NOT NULL,
  "value" "text" NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_configs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_course_modules" (
  "name" "text" DEFAULT '' :: "text" NOT NULL,
  "is_published" boolean DEFAULT false NOT NULL,
  "is_public" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "course_id" "uuid" NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "content" "jsonb",
  "extra_content" "jsonb",
  "youtube_links" "text" []
);

ALTER TABLE
  "public"."workspace_course_modules" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_courses" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" DEFAULT '' :: "text" NOT NULL,
  "is_published" boolean DEFAULT false NOT NULL,
  "is_public" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "description" "text" DEFAULT '' :: "text",
  "cert_template" "public"."certificate_templates" DEFAULT 'original' :: "public"."certificate_templates" NOT NULL
);

ALTER TABLE
  "public"."workspace_courses" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_cron_executions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "job_id" "uuid" NOT NULL,
  "cron_run_id" bigint,
  "status" "text" NOT NULL,
  "start_time" timestamp with time zone,
  "end_time" timestamp with time zone,
  "response" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_cron_executions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_cron_jobs" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "dataset_id" "uuid" NOT NULL,
  "schedule" "text" NOT NULL,
  "active" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "cron_job_id" bigint,
  "name" "text" NOT NULL
);

ALTER TABLE
  "public"."workspace_cron_jobs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_dataset_cells" (
  "dataset_id" "uuid" NOT NULL,
  "column_id" "uuid" NOT NULL,
  "data" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "row_id" "uuid" NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."workspace_dataset_cells" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_dataset_columns" (
  "dataset_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "alias" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."workspace_dataset_columns" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_dataset_rows" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "dataset_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_dataset_rows" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_dataset_row_cells" WITH ("security_invoker" = 'on') AS
SELECT
  "wdr"."id" AS "row_id",
  "wdr"."dataset_id",
  "wdr"."created_at",
  "jsonb_object_agg"("wdc"."name", "wdc"."data") AS "cells"
FROM
  (
    "public"."workspace_dataset_rows" "wdr"
    LEFT JOIN LATERAL (
      SELECT
        "c"."data",
        "col"."name"
      FROM
        (
          "public"."workspace_dataset_cells" "c"
          JOIN "public"."workspace_dataset_columns" "col" ON (("col"."id" = "c"."column_id"))
        )
      WHERE
        ("c"."row_id" = "wdr"."id")
    ) "wdc" ON (true)
  )
GROUP BY
  "wdr"."id",
  "wdr"."dataset_id",
  "wdr"."created_at";

ALTER VIEW "public"."workspace_dataset_row_cells" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_datasets" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "description" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "url" "text"
);

ALTER TABLE
  "public"."workspace_datasets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_default_permissions" (
  "ws_id" "uuid" NOT NULL,
  "permission" "public"."workspace_role_permission" NOT NULL,
  "enabled" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_default_permissions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_documents" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "legacy_content" "text" DEFAULT '' :: "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" DEFAULT "gen_random_uuid"(),
  "is_public" boolean DEFAULT false,
  "content" "jsonb"
);

ALTER TABLE
  "public"."workspace_documents" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_education_access_requests" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "workspace_name" "text" NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "message" "text" NOT NULL,
  "status" "text" DEFAULT 'pending' :: "text" NOT NULL,
  "admin_notes" "text",
  "reviewed_by" "uuid",
  "reviewed_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "feature" "public"."feature_flag" DEFAULT 'ENABLE_EDUCATION' :: "public"."feature_flag" NOT NULL,
  CONSTRAINT "workspace_education_access_requests_status_check" CHECK (
    (
      "status" = ANY (
        ARRAY ['pending'::"text", 'approved'::"text", 'rejected'::"text"]
      )
    )
  )
);

ALTER TABLE
  "public"."workspace_education_access_requests" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_email_credentials" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "region" "text" DEFAULT 'ap-southeast-1' :: "text" NOT NULL,
  "access_id" "text" NOT NULL,
  "access_key" "text" NOT NULL,
  "source_name" "text" DEFAULT 'Tuturuuu' :: "text" NOT NULL,
  "source_email" "text" DEFAULT 'notifications@tuturuuu.com' :: "text" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_email_credentials" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_email_invites" (
  "ws_id" "uuid" NOT NULL,
  "email" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "invited_by" "uuid"
);

ALTER TABLE
  "public"."workspace_email_invites" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_encryption_keys" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "encrypted_key" "text" NOT NULL,
  "key_version" integer DEFAULT 1 NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_encryption_keys" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_encryption_keys" IS 'Stores per-workspace encryption keys for E2EE at rest. Keys are encrypted with a master key stored in environment variables.';

COMMENT ON COLUMN "public"."workspace_encryption_keys"."encrypted_key" IS 'AES-256 key encrypted with master key, base64 encoded';

COMMENT ON COLUMN "public"."workspace_encryption_keys"."key_version" IS 'Version number for key rotation support';

CREATE TABLE IF NOT EXISTS "public"."workspace_flashcards" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "front" "text" NOT NULL,
  "back" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_flashcards" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_habits" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "creator_id" "uuid",
  "name" "text" NOT NULL,
  "description" "text",
  "color" "text" DEFAULT 'BLUE' :: "text",
  "calendar_hours" "public"."calendar_hours" DEFAULT 'personal_hours' :: "public"."calendar_hours",
  "priority" "public"."task_priority" DEFAULT 'normal' :: "public"."task_priority",
  "duration_minutes" integer DEFAULT 30 NOT NULL,
  "min_duration_minutes" integer,
  "max_duration_minutes" integer,
  "ideal_time" time without time zone,
  "time_preference" "public"."time_of_day_preference",
  "frequency" "public"."habit_frequency" DEFAULT 'daily' :: "public"."habit_frequency" NOT NULL,
  "recurrence_interval" integer DEFAULT 1,
  "days_of_week" integer [],
  "monthly_type" "public"."monthly_recurrence_type",
  "day_of_month" integer,
  "week_of_month" integer,
  "day_of_week_monthly" integer,
  "start_date" "date" DEFAULT CURRENT_DATE NOT NULL,
  "end_date" "date",
  "is_active" boolean DEFAULT true,
  "auto_schedule" boolean DEFAULT true,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "deleted_at" timestamp with time zone,
  "is_visible_in_calendar" boolean DEFAULT true
);

ALTER TABLE
  "public"."workspace_habits" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_habits" IS 'Stores recurring habits that generate calendar events';

COMMENT ON COLUMN "public"."workspace_habits"."ideal_time" IS 'Preferred specific time for scheduling this habit';

COMMENT ON COLUMN "public"."workspace_habits"."time_preference" IS 'Preferred time of day if no specific time set';

COMMENT ON COLUMN "public"."workspace_habits"."frequency" IS 'How often the habit repeats: daily, weekly, monthly, yearly, or custom';

COMMENT ON COLUMN "public"."workspace_habits"."recurrence_interval" IS 'Repeat every N periods (e.g., every 2 weeks)';

COMMENT ON COLUMN "public"."workspace_habits"."days_of_week" IS 'For weekly habits: array of day numbers (0=Sunday to 6=Saturday)';

COMMENT ON COLUMN "public"."workspace_habits"."monthly_type" IS 'For monthly habits: by day of month or by weekday';

COMMENT ON COLUMN "public"."workspace_habits"."week_of_month" IS 'For monthly by weekday: which week (1-5, where 5 means last)';

COMMENT ON COLUMN "public"."workspace_habits"."is_visible_in_calendar" IS 'Whether the habit is visible in the calendar sidebar. Defaults to true.';

CREATE TABLE IF NOT EXISTS "public"."workspace_invite_link_uses" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "invite_link_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "joined_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_invite_link_uses" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_invite_links" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "code" "text" NOT NULL,
  "creator_id" "uuid" NOT NULL,
  "max_uses" integer,
  "expires_at" timestamp with time zone,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_invite_links" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_invite_links_with_stats" AS
SELECT
  "wil"."id",
  "wil"."ws_id",
  "wil"."code",
  "wil"."creator_id",
  "wil"."max_uses",
  "wil"."expires_at",
  "wil"."created_at",
  "wil"."updated_at",
  "count"("wilu"."id") AS "current_uses",
  CASE
    WHEN (
      ("wil"."expires_at" IS NOT NULL)
      AND ("wil"."expires_at" < "now"())
    ) THEN true
    ELSE false
  END AS "is_expired",
  CASE
    WHEN (
      ("wil"."max_uses" IS NOT NULL)
      AND ("count"("wilu"."id") >= "wil"."max_uses")
    ) THEN true
    ELSE false
  END AS "is_full"
FROM
  (
    "public"."workspace_invite_links" "wil"
    LEFT JOIN "public"."workspace_invite_link_uses" "wilu" ON (("wil"."id" = "wilu"."invite_link_id"))
  )
GROUP BY
  "wil"."id",
  "wil"."ws_id",
  "wil"."code",
  "wil"."creator_id",
  "wil"."max_uses",
  "wil"."expires_at",
  "wil"."created_at",
  "wil"."updated_at";

ALTER VIEW "public"."workspace_invite_links_with_stats" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_invites" (
  "ws_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

CREATE
OR REPLACE VIEW "public"."workspace_link_counts" AS
SELECT
  "ws"."id",
  "ws"."name",
  "ws"."logo_url",
  "count"("sl"."id") AS "link_count"
FROM
  (
    "public"."workspaces" "ws"
    LEFT JOIN "public"."shortened_links" "sl" ON (("ws"."id" = "sl"."ws_id"))
  )
GROUP BY
  "ws"."id",
  "ws"."name",
  "ws"."logo_url";

CREATE TABLE IF NOT EXISTS "public"."workspace_meetings" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "time" timestamp with time zone DEFAULT "now"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "creator_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_meetings" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_members_and_invites" WITH ("security_invoker" = 'on') AS
SELECT
  "wi"."ws_id",
  "u"."id",
  "u"."handle",
  NULL :: "text" AS "email",
  "u"."display_name",
  "u"."avatar_url",
  COALESCE("wm"."created_at", "wi"."created_at") AS "created_at",
  ("wm"."user_id" IS NULL) AS "pending"
FROM
  (
    (
      "public"."workspace_invites" "wi"
      LEFT JOIN "public"."workspace_members" "wm" ON (
        (
          ("wi"."user_id" = "wm"."user_id")
          AND ("wi"."ws_id" = "wm"."ws_id")
        )
      )
    )
    JOIN "public"."users" "u" ON (("wi"."user_id" = "u"."id"))
  )
UNION
SELECT
  "wm"."ws_id",
  "wm"."user_id" AS "id",
  "u"."handle",
  "upd"."email",
  "u"."display_name",
  "u"."avatar_url",
  "wm"."created_at",
  false AS "pending"
FROM
  (
    (
      "public"."workspace_members" "wm"
      JOIN "public"."users" "u" ON (("wm"."user_id" = "u"."id"))
    )
    JOIN "public"."user_private_details" "upd" ON (("upd"."user_id" = "u"."id"))
  )
UNION
SELECT
  "wei"."ws_id",
  NULL :: "uuid" AS "id",
  NULL :: "text" AS "handle",
  "wei"."email",
  NULL :: "text" AS "display_name",
  NULL :: "text" AS "avatar_url",
  "wei"."created_at",
  true AS "pending"
FROM
  "public"."workspace_email_invites" "wei";

ALTER VIEW "public"."workspace_members_and_invites" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_orders" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "ws_id" "uuid" NOT NULL,
  "polar_subscription_id" "text",
  "product_id" "uuid",
  "polar_order_id" "text" NOT NULL,
  "status" "public"."order_status" DEFAULT 'pending' :: "public"."order_status" NOT NULL,
  "total_amount" bigint,
  "currency" "text" DEFAULT 'usd' :: "text",
  "billing_reason" "public"."billing_reason",
  "user_id" "uuid"
);

ALTER TABLE
  "public"."workspace_orders" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_products" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "category_id" "uuid" NOT NULL,
  "name" "text",
  "manufacturer" "text",
  "usage" "text",
  "description" "text",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"(),
  "avatar_url" "text",
  "creator_id" "uuid"
);

ALTER TABLE
  "public"."workspace_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_quiz_attempt_answers" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "attempt_id" "uuid" NOT NULL,
  "quiz_id" "uuid" NOT NULL,
  "selected_option_id" "uuid" NOT NULL,
  "is_correct" boolean NOT NULL,
  "score_awarded" real NOT NULL
);

ALTER TABLE
  "public"."workspace_quiz_attempt_answers" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_quiz_attempts" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "user_id" "uuid" NOT NULL,
  "set_id" "uuid" NOT NULL,
  "attempt_number" integer NOT NULL,
  "started_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "completed_at" timestamp with time zone,
  "total_score" real,
  "duration_seconds" integer,
  "submitted_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_quiz_attempts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_quiz_sets" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" DEFAULT '' :: "text" NOT NULL,
  "ws_id" "uuid",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "attempt_limit" integer,
  "time_limit_minutes" integer,
  "allow_view_results" boolean DEFAULT true NOT NULL,
  "due_date" timestamp with time zone DEFAULT ("now"() + '7 days' :: interval) NOT NULL,
  "available_date" timestamp with time zone DEFAULT "now"() NOT NULL,
  "explanation_mode" smallint DEFAULT 0 NOT NULL,
  "instruction" "jsonb",
  "results_released" boolean DEFAULT false NOT NULL,
  "allow_view_old_attempts" boolean DEFAULT true NOT NULL
);

ALTER TABLE
  "public"."workspace_quiz_sets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_quizzes" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "question" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "score" integer DEFAULT 1 NOT NULL,
  "instruction" "jsonb"
);

ALTER TABLE
  "public"."workspace_quizzes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_role_members" (
  "role_id" "uuid" NOT NULL,
  "user_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_role_members" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_role_permissions" (
  "ws_id" "uuid" NOT NULL,
  "permission" "public"."workspace_role_permission" NOT NULL,
  "enabled" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "role_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_role_permissions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_roles" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_roles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_secrets" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "name" "text" DEFAULT '' :: "text" NOT NULL,
  "value" "text",
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_secrets" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_subscription_products" (
  "id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "name" "text",
  "description" "text",
  "price" bigint,
  "recurring_interval" "text" DEFAULT 'month' :: "text",
  "archived" boolean DEFAULT false NOT NULL,
  "tier" "public"."workspace_product_tier"
);

ALTER TABLE
  "public"."workspace_subscription_products" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_subscriptions" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "status" "public"."subscription_status",
  "polar_subscription_id" "text" NOT NULL,
  "current_period_start" timestamp with time zone,
  "current_period_end" timestamp with time zone,
  "cancel_at_period_end" boolean DEFAULT false,
  "updated_at" timestamp with time zone DEFAULT "now"(),
  "product_id" "uuid"
);

ALTER TABLE
  "public"."workspace_subscriptions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_task_labels" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "color" "text" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "creator_id" "uuid" DEFAULT "auth"."uid"(),
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_task_labels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_task_reminder_settings" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "reminder_intervals" "jsonb" DEFAULT '["24h", "1h"]' :: "jsonb" NOT NULL,
  "enabled" boolean DEFAULT true NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_task_reminder_settings" OWNER TO "postgres";

COMMENT ON TABLE "public"."workspace_task_reminder_settings" IS 'Per-workspace settings for task due date reminder intervals';

COMMENT ON COLUMN "public"."workspace_task_reminder_settings"."reminder_intervals" IS 'Array of interval strings: "24h", "12h", "6h", "1h", "30m", "2d", "7d"';

CREATE TABLE IF NOT EXISTS "public"."workspace_teams" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text",
  "created_at" timestamp with time zone DEFAULT "now"(),
  "deleted" boolean DEFAULT false,
  "ws_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_teams" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_fields" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "name" "text" NOT NULL,
  "type" "text" NOT NULL,
  "possible_values" "text" [],
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "description" "text",
  "notes" "text",
  "default_value" "text"
);

ALTER TABLE
  "public"."workspace_user_fields" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_user_groups_with_amount" AS
SELECT
  NULL :: "uuid" AS "id",
  NULL :: "uuid" AS "ws_id",
  NULL :: "text" AS "name",
  NULL :: timestamp with time zone AS "created_at",
  NULL :: boolean AS "archived",
  NULL :: timestamp with time zone AS "ending_date",
  NULL :: "text" AS "notes",
  NULL :: "date" [] AS "sessions",
  NULL :: timestamp with time zone AS "starting_date",
  NULL :: bigint AS "amount";

ALTER VIEW "public"."workspace_user_groups_with_amount" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_user_groups_with_guest" AS
SELECT
  NULL :: "uuid" AS "id",
  NULL :: "uuid" AS "ws_id",
  NULL :: "text" AS "name",
  NULL :: timestamp with time zone AS "created_at",
  NULL :: boolean AS "archived",
  NULL :: timestamp with time zone AS "ending_date",
  NULL :: "text" AS "notes",
  NULL :: "date" [] AS "sessions",
  NULL :: timestamp with time zone AS "starting_date",
  NULL :: boolean AS "is_guest",
  NULL :: bigint AS "amount";

ALTER VIEW "public"."workspace_user_groups_with_guest" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_linked_users" (
  "platform_user_id" "uuid" NOT NULL,
  "virtual_user_id" "uuid" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE
  "public"."workspace_user_linked_users" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_user_status_changes" (
  "user_id" "uuid" NOT NULL,
  "ws_id" "uuid" NOT NULL,
  "archived" boolean NOT NULL,
  "archived_until" timestamp with time zone,
  "creator_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);

ALTER TABLE
  "public"."workspace_user_status_changes" OWNER TO "postgres";

CREATE
OR REPLACE VIEW "public"."workspace_users_with_groups" AS
SELECT
  "id",
  "full_name",
  "email",
  "phone",
  "birthday",
  "gender",
  "ethnicity",
  "guardian",
  "address",
  "national_id",
  "note",
  "ws_id",
  "created_at",
  "balance",
  "avatar_url",
  "display_name",
  "archived",
  "archived_until",
  "created_by",
  "updated_at",
  "updated_by",
  (
    SELECT
      "json_agg"("wug"."id") AS "json_agg"
    FROM
      (
        "public"."workspace_user_groups" "wug"
        JOIN "public"."workspace_user_groups_users" "wugu" ON (("wug"."id" = "wugu"."group_id"))
      )
    WHERE
      ("wugu"."user_id" = "wu"."id")
  ) AS "groups",
  (
    SELECT
      "count"(*) AS "count"
    FROM
      (
        "public"."workspace_user_groups" "wug"
        JOIN "public"."workspace_user_groups_users" "wugu" ON (("wug"."id" = "wugu"."group_id"))
      )
    WHERE
      ("wugu"."user_id" = "wu"."id")
  ) AS "group_count",
  (
    SELECT
      "json_agg"("linked_users".*) AS "json_agg"
    FROM
      (
        SELECT
          DISTINCT ON ("wulu"."platform_user_id") "wulu"."platform_user_id",
          "u"."display_name"
        FROM
          (
            (
              "public"."workspace_user_linked_users" "wulu"
              JOIN "public"."users" "u" ON (("wulu"."platform_user_id" = "u"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("u"."id" = "wm"."user_id"))
          )
        WHERE
          (
            ("wm"."user_id" = "u"."id")
            AND ("wulu"."virtual_user_id" = "wu"."id")
          )
      ) "linked_users"
  ) AS "linked_users"
FROM
  "public"."workspace_users" "wu";

ALTER VIEW "public"."workspace_users_with_groups" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_wallet_transfers" (
  "from_transaction_id" "uuid" NOT NULL,
  "to_transaction_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE
  "public"."workspace_wallet_transfers" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workspace_whiteboards" (
  "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
  "title" "text" NOT NULL,
  "description" "text",
  "snapshot" "jsonb",
  "ws_id" "uuid" NOT NULL,
  "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "thumbnail_url" "text",
  "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
  "creator_id" "uuid" NOT NULL
);

ALTER TABLE
  "public"."workspace_whiteboards" OWNER TO "postgres";

ALTER TABLE
  ONLY "audit"."record_version"
ALTER COLUMN
  "id"
SET
  DEFAULT "nextval"('"audit"."record_version_id_seq"' :: "regclass");

ALTER TABLE
  ONLY "audit"."record_version"
ADD
  CONSTRAINT "record_version_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."abuse_events"
ADD
  CONSTRAINT "abuse_events_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."ai_chat_members"
ADD
  CONSTRAINT "ai_chat_members_pkey" PRIMARY KEY ("chat_id", "email");

ALTER TABLE
  ONLY "public"."ai_chat_messages"
ADD
  CONSTRAINT "ai_chat_messages_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."ai_chats"
ADD
  CONSTRAINT "ai_chats_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."ai_models"
ADD
  CONSTRAINT "ai_models_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."ai_providers"
ADD
  CONSTRAINT "ai_providers_name_key" UNIQUE ("name");

ALTER TABLE
  ONLY "public"."ai_providers"
ADD
  CONSTRAINT "ai_providers_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."ai_whitelisted_domains"
ADD
  CONSTRAINT "ai_whitelisted_domains_pkey" PRIMARY KEY ("domain");

ALTER TABLE
  ONLY "public"."ai_whitelisted_emails"
ADD
  CONSTRAINT "ai_whitelisted_emails_pkey" PRIMARY KEY ("email");

ALTER TABLE
  ONLY "public"."audio_chunks"
ADD
  CONSTRAINT "audio_chunks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."audio_chunks"
ADD
  CONSTRAINT "audio_chunks_session_id_chunk_order_key" UNIQUE ("session_id", "chunk_order");

ALTER TABLE
  ONLY "public"."aurora_ml_forecast"
ADD
  CONSTRAINT "aurora_ml_forecast_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."aurora_ml_metrics"
ADD
  CONSTRAINT "aurora_ml_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."aurora_statistical_forecast"
ADD
  CONSTRAINT "aurora_statistical_forecast_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."aurora_statistical_metrics"
ADD
  CONSTRAINT "aurora_statistical_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."blocked_ips"
ADD
  CONSTRAINT "blocked_ips_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."calendar_auth_tokens"
ADD
  CONSTRAINT "calendar_auth_tokens_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."calendar_connections"
ADD
  CONSTRAINT "calendar_connections_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."calendar_event_colors"
ADD
  CONSTRAINT "calendar_event_colors_pkey" PRIMARY KEY ("value");

ALTER TABLE
  ONLY "public"."calendar_event_participant_groups"
ADD
  CONSTRAINT "calendar_event_participant_groups_pkey" PRIMARY KEY ("event_id", "group_id");

ALTER TABLE
  ONLY "public"."calendar_event_platform_participants"
ADD
  CONSTRAINT "calendar_event_platform_participants_pkey" PRIMARY KEY ("event_id", "user_id");

ALTER TABLE
  ONLY "public"."calendar_event_virtual_participants"
ADD
  CONSTRAINT "calendar_event_virtual_participants_pkey" PRIMARY KEY ("event_id", "user_id");

ALTER TABLE
  ONLY "public"."calendar_sync_dashboard"
ADD
  CONSTRAINT "calendar_sync_dashboard_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."calendar_sync_states"
ADD
  CONSTRAINT "calendar_sync_states_pkey" PRIMARY KEY ("ws_id", "calendar_id");

ALTER TABLE
  ONLY "public"."changelog_entries"
ADD
  CONSTRAINT "changelog_entries_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."changelog_entries"
ADD
  CONSTRAINT "changelog_entries_slug_key" UNIQUE ("slug");

ALTER TABLE
  ONLY "public"."course_certificates"
ADD
  CONSTRAINT "course_certificates_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."course_module_completion_status"
ADD
  CONSTRAINT "course_module_completion_status_pkey" PRIMARY KEY ("completion_id");

ALTER TABLE
  ONLY "public"."course_module_flashcards"
ADD
  CONSTRAINT "course_module_flashcards_pkey" PRIMARY KEY ("module_id", "flashcard_id");

ALTER TABLE
  ONLY "public"."course_module_quiz_sets"
ADD
  CONSTRAINT "course_module_quiz_sets_pkey" PRIMARY KEY ("module_id", "set_id");

ALTER TABLE
  ONLY "public"."course_module_quizzes"
ADD
  CONSTRAINT "course_module_quizzes_pkey" PRIMARY KEY ("module_id", "quiz_id");

ALTER TABLE
  ONLY "public"."crawled_url_next_urls"
ADD
  CONSTRAINT "crawled_url_next_urls_pkey" PRIMARY KEY ("origin_id", "url");

ALTER TABLE
  ONLY "public"."crawled_urls"
ADD
  CONSTRAINT "crawled_urls_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."credit_wallets"
ADD
  CONSTRAINT "credit_wallets_pkey" PRIMARY KEY ("wallet_id");

ALTER TABLE
  ONLY "public"."cross_app_tokens"
ADD
  CONSTRAINT "cross_app_tokens_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."cross_app_tokens"
ADD
  CONSTRAINT "cross_app_tokens_token_key" UNIQUE ("token");

ALTER TABLE
  ONLY "public"."currencies"
ADD
  CONSTRAINT "currencies_code_key" UNIQUE ("code");

ALTER TABLE
  ONLY "public"."currencies"
ADD
  CONSTRAINT "currencies_name_key" UNIQUE ("name");

ALTER TABLE
  ONLY "public"."currencies"
ADD
  CONSTRAINT "currencies_pkey" PRIMARY KEY ("code");

ALTER TABLE
  ONLY "public"."discord_guild_members"
ADD
  CONSTRAINT "discord_guild_members_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."discord_integrations"
ADD
  CONSTRAINT "discord_integrations_discord_guild_id_key" UNIQUE ("discord_guild_id");

ALTER TABLE
  ONLY "public"."discord_integrations"
ADD
  CONSTRAINT "discord_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."discord_integrations"
ADD
  CONSTRAINT "discord_integrations_ws_id_key" UNIQUE ("ws_id");

ALTER TABLE
  ONLY "public"."email_audit"
ADD
  CONSTRAINT "email_audit_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."email_blacklist"
ADD
  CONSTRAINT "email_blacklist_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."email_blacklist"
ADD
  CONSTRAINT "email_blacklist_type_value_unique" UNIQUE ("entry_type", "value");

ALTER TABLE
  ONLY "public"."email_bounce_complaints"
ADD
  CONSTRAINT "email_bounce_complaints_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."external_user_monthly_report_logs"
ADD
  CONSTRAINT "external_user_monthly_report_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."external_user_monthly_reports"
ADD
  CONSTRAINT "external_user_monthly_reports_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."field_types"
ADD
  CONSTRAINT "field_types_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."finance_budgets"
ADD
  CONSTRAINT "finance_budgets_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."finance_invoice_products"
ADD
  CONSTRAINT "finance_invoice_products_pkey" PRIMARY KEY (
    "invoice_id",
    "product_name",
    "product_unit",
    "warehouse"
  );

ALTER TABLE
  ONLY "public"."finance_invoice_promotions"
ADD
  CONSTRAINT "finance_invoice_promotions_unique_combo" UNIQUE ("invoice_id", "code");

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_transaction_id_key" UNIQUE ("transaction_id");

ALTER TABLE
  ONLY "public"."poll_guest_votes"
ADD
  CONSTRAINT "guest_poll_votes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."guest_users_lead_generation"
ADD
  CONSTRAINT "guest_users_lead_generation_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."habit_calendar_events"
ADD
  CONSTRAINT "habit_calendar_events_habit_id_event_id_key" UNIQUE ("habit_id", "event_id");

ALTER TABLE
  ONLY "public"."habit_calendar_events"
ADD
  CONSTRAINT "habit_calendar_events_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."habit_completions"
ADD
  CONSTRAINT "habit_completions_habit_id_occurrence_date_key" UNIQUE ("habit_id", "occurrence_date");

ALTER TABLE
  ONLY "public"."habit_completions"
ADD
  CONSTRAINT "habit_completions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."handles"
ADD
  CONSTRAINT "handles_pkey" PRIMARY KEY ("value");

ALTER TABLE
  ONLY "public"."healthcare_checkup_vital_groups"
ADD
  CONSTRAINT "healthcare_checkup_vital_groups_pkey" PRIMARY KEY ("checkup_id", "group_id");

ALTER TABLE
  ONLY "public"."healthcare_checkup_vitals"
ADD
  CONSTRAINT "healthcare_checkup_vitals_pkey" PRIMARY KEY ("checkup_id", "vital_id");

ALTER TABLE
  ONLY "public"."healthcare_checkups"
ADD
  CONSTRAINT "healthcare_checkups_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."healthcare_diagnoses"
ADD
  CONSTRAINT "healthcare_diagnoses_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "healthcare_prescriptions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."healthcare_vital_groups"
ADD
  CONSTRAINT "healthcare_vital_groups_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."healthcare_vitals"
ADD
  CONSTRAINT "healthcare_vitals_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."internal_email_api_keys"
ADD
  CONSTRAINT "internal_email_api_keys_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."internal_email_api_keys"
ADD
  CONSTRAINT "internal_email_api_keys_user_id_key" UNIQUE ("user_id");

ALTER TABLE
  ONLY "public"."internal_emails"
ADD
  CONSTRAINT "internal_emails_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."inventory_batch_products"
ADD
  CONSTRAINT "inventory_batch_products_pkey" PRIMARY KEY ("batch_id", "product_id", "unit_id");

ALTER TABLE
  ONLY "public"."inventory_batches"
ADD
  CONSTRAINT "inventory_batches_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."inventory_products"
ADD
  CONSTRAINT "inventory_products_pkey" PRIMARY KEY ("product_id", "unit_id", "warehouse_id");

ALTER TABLE
  ONLY "public"."inventory_suppliers"
ADD
  CONSTRAINT "inventory_suppliers_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."inventory_units"
ADD
  CONSTRAINT "inventory_units_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."inventory_warehouses"
ADD
  CONSTRAINT "inventory_warehouses_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."link_analytics"
ADD
  CONSTRAINT "link_analytics_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."live_api_sessions"
ADD
  CONSTRAINT "live_api_sessions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."live_api_sessions"
ADD
  CONSTRAINT "live_api_sessions_user_id_ws_id_key" UNIQUE ("user_id", "ws_id");

ALTER TABLE
  ONLY "public"."meet_together_plans"
ADD
  CONSTRAINT "meet-together-plans_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."meet_together_guest_timeblocks"
ADD
  CONSTRAINT "meet_together_guest_timeblocks_combination_unique" UNIQUE (
    "plan_id",
    "user_id",
    "date",
    "start_time",
    "end_time"
  );

ALTER TABLE
  ONLY "public"."meet_together_guest_timeblocks"
ADD
  CONSTRAINT "meet_together_guest_timeblocks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."meet_together_guests"
ADD
  CONSTRAINT "meet_together_guests_id_name_unique" UNIQUE ("id", "name");

ALTER TABLE
  ONLY "public"."meet_together_guests"
ADD
  CONSTRAINT "meet_together_guests_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."meet_together_user_timeblocks"
ADD
  CONSTRAINT "meet_together_user_timeblocks_combination_unique" UNIQUE (
    "plan_id",
    "user_id",
    "date",
    "start_time",
    "end_time"
  );

ALTER TABLE
  ONLY "public"."meet_together_user_timeblocks"
ADD
  CONSTRAINT "meet_together_user_timeblocks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notes"
ADD
  CONSTRAINT "notes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notification_batches"
ADD
  CONSTRAINT "notification_batches_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notification_delivery_log"
ADD
  CONSTRAINT "notification_delivery_log_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notification_email_config"
ADD
  CONSTRAINT "notification_email_config_notification_type_key" UNIQUE ("notification_type");

ALTER TABLE
  ONLY "public"."notification_email_config"
ADD
  CONSTRAINT "notification_email_config_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notification_preferences"
ADD
  CONSTRAINT "notification_preferences_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."notifications"
ADD
  CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_challenge_criteria"
ADD
  CONSTRAINT "nova_challenge_criterias_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_challenge_manager_emails"
ADD
  CONSTRAINT "nova_challenge_manager_emails_pkey" PRIMARY KEY ("challenge_id", "email");

ALTER TABLE
  ONLY "public"."nova_sessions"
ADD
  CONSTRAINT "nova_challenge_status_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_challenge_whitelisted_emails"
ADD
  CONSTRAINT "nova_challenge_whitelisted_emails_pkey" PRIMARY KEY ("challenge_id", "email");

ALTER TABLE
  ONLY "public"."nova_challenges"
ADD
  CONSTRAINT "nova_challenges_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_problem_test_cases"
ADD
  CONSTRAINT "nova_problem_testcases_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_problems"
ADD
  CONSTRAINT "nova_problems_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."platform_email_roles"
ADD
  CONSTRAINT "nova_roles_email_citext_unique" UNIQUE ("email");

ALTER TABLE
  ONLY "public"."nova_submission_criteria"
ADD
  CONSTRAINT "nova_submission_criteria_pkey" PRIMARY KEY ("submission_id", "criteria_id");

ALTER TABLE
  ONLY "public"."nova_submission_test_cases"
ADD
  CONSTRAINT "nova_submission_test_cases_pkey" PRIMARY KEY ("submission_id", "test_case_id");

ALTER TABLE
  ONLY "public"."nova_submissions"
ADD
  CONSTRAINT "nova_submissions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."nova_team_emails"
ADD
  CONSTRAINT "nova_team_emails_pkey" PRIMARY KEY ("team_id", "email");

ALTER TABLE
  ONLY "public"."nova_team_members"
ADD
  CONSTRAINT "nova_team_members_pkey" PRIMARY KEY ("team_id", "user_id");

ALTER TABLE
  ONLY "public"."nova_teams"
ADD
  CONSTRAINT "nova_teams_name_unique" UNIQUE ("name");

ALTER TABLE
  ONLY "public"."nova_teams"
ADD
  CONSTRAINT "nova_teams_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."onboarding_progress"
ADD
  CONSTRAINT "onboarding_progress_pkey" PRIMARY KEY ("user_id");

ALTER TABLE
  ONLY "public"."workspace_invites"
ADD
  CONSTRAINT "org_invites_pkey" PRIMARY KEY ("ws_id", "user_id");

ALTER TABLE
  ONLY "public"."workspace_members"
ADD
  CONSTRAINT "org_members_pkey" PRIMARY KEY ("ws_id", "user_id");

ALTER TABLE
  ONLY "public"."workspaces"
ADD
  CONSTRAINT "orgs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."personal_notes"
ADD
  CONSTRAINT "personal_notes_pkey" PRIMARY KEY ("user_id", "owner_id");

ALTER TABLE
  ONLY "public"."platform_email_roles"
ADD
  CONSTRAINT "platform_email_roles_pkey" PRIMARY KEY ("email");

ALTER TABLE
  ONLY "public"."platform_user_roles"
ADD
  CONSTRAINT "platform_user_roles_pkey" PRIMARY KEY ("user_id");

ALTER TABLE
  ONLY "public"."poll_guest_permissions"
ADD
  CONSTRAINT "poll_guest_permissions_pkey" PRIMARY KEY ("poll_id");

ALTER TABLE
  ONLY "public"."poll_guest_permissions"
ADD
  CONSTRAINT "poll_guest_permissions_poll_id_key" UNIQUE ("poll_id");

ALTER TABLE
  ONLY "public"."poll_options"
ADD
  CONSTRAINT "poll_option_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."poll_user_permissions"
ADD
  CONSTRAINT "poll_user_permissions_pkey" PRIMARY KEY ("poll_id", "user_id");

ALTER TABLE
  ONLY "public"."polls"
ADD
  CONSTRAINT "polls_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."product_categories"
ADD
  CONSTRAINT "product_categories_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."team_members"
ADD
  CONSTRAINT "project_members_pkey" PRIMARY KEY ("team_id", "user_id");

ALTER TABLE
  ONLY "public"."workspace_teams"
ADD
  CONSTRAINT "projects_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_wallets"
ADD
  CONSTRAINT "projects_wallets_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."quiz_options"
ADD
  CONSTRAINT "quiz_options_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."quiz_set_quizzes"
ADD
  CONSTRAINT "quiz_set_quizzes_pkey" PRIMARY KEY ("set_id", "quiz_id");

ALTER TABLE
  ONLY "public"."realtime_log_aggregations"
ADD
  CONSTRAINT "realtime_log_aggregations_id_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."realtime_log_aggregations"
ADD
  CONSTRAINT "realtime_log_aggregations_unique_bucket" UNIQUE (
    "ws_id",
    "user_id",
    "channel_id",
    "time_bucket",
    "kind"
  );

ALTER TABLE
  ONLY "public"."recording_sessions"
ADD
  CONSTRAINT "recording_sessions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."recording_transcripts"
ADD
  CONSTRAINT "recording_transcripts_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."recording_transcripts"
ADD
  CONSTRAINT "recording_transcripts_session_id_key" UNIQUE ("session_id");

ALTER TABLE
  ONLY "public"."recurring_transactions"
ADD
  CONSTRAINT "recurring_transactions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."shortened_links"
ADD
  CONSTRAINT "shortened_links_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."shortened_links"
ADD
  CONSTRAINT "shortened_links_slug_key" UNIQUE ("slug");

ALTER TABLE
  ONLY "public"."support_inquiries"
ADD
  CONSTRAINT "support_inquiries_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_assignees"
ADD
  CONSTRAINT "task_assignees_pkey" PRIMARY KEY ("task_id", "user_id");

ALTER TABLE
  ONLY "public"."task_board_status_templates"
ADD
  CONSTRAINT "task_board_status_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_boards"
ADD
  CONSTRAINT "task_boards_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_calendar_events"
ADD
  CONSTRAINT "task_calendar_events_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_calendar_events"
ADD
  CONSTRAINT "task_calendar_events_task_id_event_id_key" UNIQUE ("task_id", "event_id");

ALTER TABLE
  ONLY "public"."task_cycle_tasks"
ADD
  CONSTRAINT "task_cycle_tasks_pkey" PRIMARY KEY ("task_id", "cycle_id");

ALTER TABLE
  ONLY "public"."task_cycles"
ADD
  CONSTRAINT "task_cycles_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_history"
ADD
  CONSTRAINT "task_history_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_initiatives"
ADD
  CONSTRAINT "task_initiatives_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_labels"
ADD
  CONSTRAINT "task_labels_pkey" PRIMARY KEY ("task_id", "label_id");

ALTER TABLE
  ONLY "public"."task_lists"
ADD
  CONSTRAINT "task_lists_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_project_initiatives"
ADD
  CONSTRAINT "task_project_initiatives_pkey" PRIMARY KEY ("project_id", "initiative_id");

ALTER TABLE
  ONLY "public"."task_project_tasks"
ADD
  CONSTRAINT "task_project_tasks_pkey" PRIMARY KEY ("task_id", "project_id");

ALTER TABLE
  ONLY "public"."task_project_update_attachments"
ADD
  CONSTRAINT "task_project_update_attachments_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_project_update_comments"
ADD
  CONSTRAINT "task_project_update_comments_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_project_update_reactions"
ADD
  CONSTRAINT "task_project_update_reactions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_project_update_reactions"
ADD
  CONSTRAINT "task_project_update_reactions_update_id_user_id_emoji_key" UNIQUE ("update_id", "user_id", "emoji");

ALTER TABLE
  ONLY "public"."task_project_updates"
ADD
  CONSTRAINT "task_project_updates_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_projects"
ADD
  CONSTRAINT "task_projects_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_relationships"
ADD
  CONSTRAINT "task_relationships_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_relationships"
ADD
  CONSTRAINT "task_relationships_unique_relationship" UNIQUE ("source_task_id", "target_task_id", "type");

ALTER TABLE
  ONLY "public"."task_reminder_sent"
ADD
  CONSTRAINT "task_reminder_sent_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_reminder_sent"
ADD
  CONSTRAINT "task_reminder_sent_task_id_user_id_reminder_interval_key" UNIQUE ("task_id", "user_id", "reminder_interval");

ALTER TABLE
  ONLY "public"."task_user_scheduling_settings"
ADD
  CONSTRAINT "task_user_scheduling_settings_pkey" PRIMARY KEY ("task_id", "user_id");

ALTER TABLE
  ONLY "public"."task_watchers"
ADD
  CONSTRAINT "task_watchers_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."task_watchers"
ADD
  CONSTRAINT "task_watchers_task_id_user_id_key" UNIQUE ("task_id", "user_id");

ALTER TABLE
  ONLY "public"."tasks"
ADD
  CONSTRAINT "tasks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."time_tracking_breaks"
ADD
  CONSTRAINT "time_tracking_breaks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."time_tracking_categories"
ADD
  CONSTRAINT "time_tracking_categories_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."time_tracking_goals"
ADD
  CONSTRAINT "time_tracking_goals_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."timezones"
ADD
  CONSTRAINT "timezones_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."timezones"
ADD
  CONSTRAINT "timezones_text_key" UNIQUE ("text");

ALTER TABLE
  ONLY "public"."timezones"
ADD
  CONSTRAINT "timezones_value_key" UNIQUE ("value");

ALTER TABLE
  ONLY "public"."transaction_categories"
ADD
  CONSTRAINT "transaction_categories_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."transaction_tags"
ADD
  CONSTRAINT "transaction_tags_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."transaction_tags"
ADD
  CONSTRAINT "transaction_tags_ws_id_name_key" UNIQUE ("ws_id", "name");

ALTER TABLE
  ONLY "public"."course_certificates"
ADD
  CONSTRAINT "uq_user_certificate" UNIQUE ("user_id", "course_id");

ALTER TABLE
  ONLY "public"."course_module_completion_status"
ADD
  CONSTRAINT "uq_user_module" UNIQUE ("user_id", "module_id");

ALTER TABLE
  ONLY "public"."user_feedbacks"
ADD
  CONSTRAINT "user_feedbacks_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."user_group_attendance"
ADD
  CONSTRAINT "user_group_attendance_pkey" PRIMARY KEY ("group_id", "user_id", "date");

ALTER TABLE
  ONLY "public"."user_group_linked_products"
ADD
  CONSTRAINT "user_group_linked_products_unique_combo" UNIQUE ("group_id", "product_id", "unit_id");

ALTER TABLE
  ONLY "public"."user_group_post_checks"
ADD
  CONSTRAINT "user_group_post_checks_email_id_key" UNIQUE ("email_id");

ALTER TABLE
  ONLY "public"."user_group_post_checks"
ADD
  CONSTRAINT "user_group_post_checks_pkey" PRIMARY KEY ("post_id", "user_id");

ALTER TABLE
  ONLY "public"."user_group_posts"
ADD
  CONSTRAINT "user_group_posts_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."user_indicators"
ADD
  CONSTRAINT "user_indicators_pkey" PRIMARY KEY ("user_id", "indicator_id");

ALTER TABLE
  ONLY "public"."user_indicators"
ADD
  CONSTRAINT "user_indicators_unique_user_indicator" UNIQUE ("user_id", "indicator_id");

ALTER TABLE
  ONLY "public"."user_linked_promotions"
ADD
  CONSTRAINT "user_linked_promotions_pkey" PRIMARY KEY ("user_id", "promo_id");

ALTER TABLE
  ONLY "public"."user_private_details"
ADD
  CONSTRAINT "user_private_details_pkey" PRIMARY KEY ("user_id");

ALTER TABLE
  ONLY "public"."users"
ADD
  CONSTRAINT "users_handle_key" UNIQUE ("handle");

ALTER TABLE
  ONLY "public"."users"
ADD
  CONSTRAINT "users_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."poll_user_votes"
ADD
  CONSTRAINT "users_poll_votes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."vital_group_vitals"
ADD
  CONSTRAINT "vital_group_vitals_pkey" PRIMARY KEY ("group_id", "vital_id");

ALTER TABLE
  ONLY "public"."wallet_transaction_tags"
ADD
  CONSTRAINT "wallet_transaction_tags_pkey" PRIMARY KEY ("transaction_id", "tag_id");

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_invoice_id_key" UNIQUE ("invoice_id");

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."wallet_types"
ADD
  CONSTRAINT "wallet_types_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_ai_executions"
ADD
  CONSTRAINT "workspace_ai_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_ai_models"
ADD
  CONSTRAINT "workspace_ai_models_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_ai_prompts"
ADD
  CONSTRAINT "workspace_ai_prompts_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_api_key_usage_logs"
ADD
  CONSTRAINT "workspace_api_key_usage_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_api_keys"
ADD
  CONSTRAINT "workspace_api_keys_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_break_types"
ADD
  CONSTRAINT "workspace_break_types_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_calendar_categories"
ADD
  CONSTRAINT "workspace_calendar_categories_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_calendar_events"
ADD
  CONSTRAINT "workspace_calendar_events_google_event_id_key" UNIQUE ("ws_id", "google_event_id");

ALTER TABLE
  ONLY "public"."workspace_calendar_events"
ADD
  CONSTRAINT "workspace_calendar_events_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_calendar_hour_settings"
ADD
  CONSTRAINT "workspace_calendar_hour_settings_pkey" PRIMARY KEY ("ws_id", "type");

ALTER TABLE
  ONLY "public"."workspace_calendar_sync_coordination"
ADD
  CONSTRAINT "workspace_calendar_sync_coordination_pkey" PRIMARY KEY ("ws_id");

ALTER TABLE
  ONLY "public"."workspace_calendar_sync_log"
ADD
  CONSTRAINT "workspace_calendar_sync_log_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_calendars"
ADD
  CONSTRAINT "workspace_calendars_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_chat_channels"
ADD
  CONSTRAINT "workspace_chat_channels_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_chat_messages"
ADD
  CONSTRAINT "workspace_chat_messages_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_chat_participants"
ADD
  CONSTRAINT "workspace_chat_participants_channel_id_user_id_key" UNIQUE ("channel_id", "user_id");

ALTER TABLE
  ONLY "public"."workspace_chat_participants"
ADD
  CONSTRAINT "workspace_chat_participants_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_chat_typing_indicators"
ADD
  CONSTRAINT "workspace_chat_typing_indicators_channel_id_user_id_key" UNIQUE ("channel_id", "user_id");

ALTER TABLE
  ONLY "public"."workspace_chat_typing_indicators"
ADD
  CONSTRAINT "workspace_chat_typing_indicators_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_configs"
ADD
  CONSTRAINT "workspace_configs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_course_modules"
ADD
  CONSTRAINT "workspace_course_modules_id_key" UNIQUE ("id");

ALTER TABLE
  ONLY "public"."workspace_course_modules"
ADD
  CONSTRAINT "workspace_course_modules_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_courses"
ADD
  CONSTRAINT "workspace_courses_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_cron_executions"
ADD
  CONSTRAINT "workspace_cron_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_cron_jobs"
ADD
  CONSTRAINT "workspace_cron_jobs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_dataset_cells"
ADD
  CONSTRAINT "workspace_dataset_cell_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_dataset_columns"
ADD
  CONSTRAINT "workspace_dataset_columns_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_dataset_rows"
ADD
  CONSTRAINT "workspace_dataset_rows_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_datasets"
ADD
  CONSTRAINT "workspace_datasets_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_default_permissions"
ADD
  CONSTRAINT "workspace_default_permissions_pkey" PRIMARY KEY ("ws_id", "permission");

ALTER TABLE
  ONLY "public"."workspace_documents"
ADD
  CONSTRAINT "workspace_documents_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_education_access_requests"
ADD
  CONSTRAINT "workspace_education_access_requests_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_email_credentials"
ADD
  CONSTRAINT "workspace_email_credentials_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_email_invites"
ADD
  CONSTRAINT "workspace_email_invites_pkey" PRIMARY KEY ("ws_id", "email");

ALTER TABLE
  ONLY "public"."workspace_encryption_keys"
ADD
  CONSTRAINT "workspace_encryption_keys_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_encryption_keys"
ADD
  CONSTRAINT "workspace_encryption_keys_ws_id_key" UNIQUE ("ws_id");

ALTER TABLE
  ONLY "public"."workspace_secrets"
ADD
  CONSTRAINT "workspace_external_api_configs_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_flashcards"
ADD
  CONSTRAINT "workspace_flashcards_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_habits"
ADD
  CONSTRAINT "workspace_habits_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_invite_link_uses"
ADD
  CONSTRAINT "workspace_invite_link_uses_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_invite_links"
ADD
  CONSTRAINT "workspace_invite_links_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_meetings"
ADD
  CONSTRAINT "workspace_meetings_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_members"
ADD
  CONSTRAINT "workspace_members_ws_id_user_id_sort_key_key" UNIQUE ("ws_id", "user_id", "sort_key");

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_polar_order_id_key" UNIQUE ("polar_order_id");

ALTER TABLE
  ONLY "public"."workspace_products"
ADD
  CONSTRAINT "workspace_products_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_promotions"
ADD
  CONSTRAINT "workspace_promotions_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_promotions"
ADD
  CONSTRAINT "workspace_promotions_ws_id_id_key" UNIQUE ("ws_id", "id");

ALTER TABLE
  ONLY "public"."workspace_quiz_attempts"
ADD
  CONSTRAINT "workspace_quiz_attempts_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_quiz_sets"
ADD
  CONSTRAINT "workspace_quiz_sets_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_quizzes"
ADD
  CONSTRAINT "workspace_quizzes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_role_members"
ADD
  CONSTRAINT "workspace_role_members_pkey" PRIMARY KEY ("role_id", "user_id");

ALTER TABLE
  ONLY "public"."workspace_role_permissions"
ADD
  CONSTRAINT "workspace_role_permissions_pkey" PRIMARY KEY ("ws_id", "permission", "role_id");

ALTER TABLE
  ONLY "public"."workspace_roles"
ADD
  CONSTRAINT "workspace_roles_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_scheduling_metadata"
ADD
  CONSTRAINT "workspace_scheduling_metadata_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_scheduling_metadata"
ADD
  CONSTRAINT "workspace_scheduling_metadata_ws_id_key" UNIQUE ("ws_id");

ALTER TABLE
  ONLY "public"."workspace_settings"
ADD
  CONSTRAINT "workspace_settings_pkey" PRIMARY KEY ("ws_id");

ALTER TABLE
  ONLY "public"."workspace_subscriptions"
ADD
  CONSTRAINT "workspace_subscription_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_subscriptions"
ADD
  CONSTRAINT "workspace_subscription_polar_subscription_id_unique" UNIQUE ("polar_subscription_id");

ALTER TABLE
  ONLY "public"."workspace_subscription_products"
ADD
  CONSTRAINT "workspace_subscription_products_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_task_labels"
ADD
  CONSTRAINT "workspace_task_labels_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_task_reminder_settings"
ADD
  CONSTRAINT "workspace_task_reminder_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_task_reminder_settings"
ADD
  CONSTRAINT "workspace_task_reminder_settings_ws_id_key" UNIQUE ("ws_id");

ALTER TABLE
  ONLY "public"."workspace_user_fields"
ADD
  CONSTRAINT "workspace_user_fields_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_user_group_tag_groups"
ADD
  CONSTRAINT "workspace_user_group_tag_groups_pkey" PRIMARY KEY ("tag_id", "group_id");

ALTER TABLE
  ONLY "public"."workspace_user_group_tags"
ADD
  CONSTRAINT "workspace_user_group_tags_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_user_linked_users"
ADD
  CONSTRAINT "workspace_user_linked_users_pkey" PRIMARY KEY ("platform_user_id", "ws_id");

ALTER TABLE
  ONLY "public"."workspace_user_groups"
ADD
  CONSTRAINT "workspace_user_roles_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_user_groups_users"
ADD
  CONSTRAINT "workspace_user_roles_users_pkey" PRIMARY KEY ("user_id", "group_id");

ALTER TABLE
  ONLY "public"."workspace_user_status_changes"
ADD
  CONSTRAINT "workspace_user_status_changes_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_users"
ADD
  CONSTRAINT "workspace_users_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_wallet_transfers"
ADD
  CONSTRAINT "workspace_wallet_transfers_pkey" PRIMARY KEY ("from_transaction_id", "to_transaction_id");

ALTER TABLE
  ONLY "public"."workspace_whiteboards"
ADD
  CONSTRAINT "workspace_whiteboards_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspaces"
ADD
  CONSTRAINT "workspaces_handle_key1" UNIQUE ("handle");

ALTER TABLE
  ONLY "public"."workspace_quiz_attempt_answers"
ADD
  CONSTRAINT "wq_answer_pkey" PRIMARY KEY ("id");

ALTER TABLE
  ONLY "public"."workspace_quiz_attempts"
ADD
  CONSTRAINT "wq_attempts_unique" UNIQUE ("user_id", "set_id", "attempt_number");

CREATE INDEX "record_version_old_record_id" ON "audit"."record_version" USING "btree" ("old_record_id")
WHERE
  ("old_record_id" IS NOT NULL);

CREATE INDEX "record_version_record_id" ON "audit"."record_version" USING "btree" ("record_id")
WHERE
  ("record_id" IS NOT NULL);

CREATE INDEX "record_version_table_oid" ON "audit"."record_version" USING "btree" ("table_oid");

CREATE INDEX "record_version_ts" ON "audit"."record_version" USING "brin" ("ts");

CREATE UNIQUE INDEX "calendar_auth_tokens_user_ws_provider_email_key" ON "public"."calendar_auth_tokens" USING "btree" ("user_id", "ws_id", "provider", "account_email")
WHERE
  ("account_email" IS NOT NULL);

CREATE INDEX "calendar_connections_auth_token_id_idx" ON "public"."calendar_connections" USING "btree" ("auth_token_id");

CREATE INDEX "calendar_connections_workspace_calendar_idx" ON "public"."calendar_connections" USING "btree" ("workspace_calendar_id");

CREATE UNIQUE INDEX "calendar_connections_ws_id_calendar_id_key" ON "public"."calendar_connections" USING "btree" ("ws_id", "calendar_id");

CREATE INDEX "calendar_sync_dashboard_status_idx" ON "public"."calendar_sync_dashboard" USING "btree" ("status");

CREATE INDEX "calendar_sync_dashboard_triggered_by_idx" ON "public"."calendar_sync_dashboard" USING "btree" ("triggered_by");

CREATE INDEX "calendar_sync_dashboard_ws_id_idx" ON "public"."calendar_sync_dashboard" USING "btree" ("ws_id");

CREATE INDEX "calendar_sync_states_calendar_id_idx" ON "public"."calendar_sync_states" USING "btree" ("calendar_id");

CREATE INDEX "calendar_sync_states_ws_id_idx" ON "public"."calendar_sync_states" USING "btree" ("ws_id");

CREATE INDEX "crawled_url_next_urls_url_idx" ON "public"."crawled_url_next_urls" USING "btree" ("url");

CREATE INDEX "crawled_urls_created_at_idx" ON "public"."crawled_urls" USING "btree" ("created_at");

CREATE INDEX "crawled_urls_url_idx" ON "public"."crawled_urls" USING "btree" ("url");

CREATE INDEX "finance_budgets_category_id_idx" ON "public"."finance_budgets" USING "btree" ("category_id");

CREATE INDEX "finance_budgets_is_active_idx" ON "public"."finance_budgets" USING "btree" ("is_active");

CREATE INDEX "finance_budgets_wallet_id_idx" ON "public"."finance_budgets" USING "btree" ("wallet_id");

CREATE INDEX "finance_budgets_ws_id_idx" ON "public"."finance_budgets" USING "btree" ("ws_id");

CREATE INDEX "finance_invoices_ws_id_created_at_idx" ON "public"."finance_invoices" USING "btree" ("ws_id", "created_at" DESC);

CREATE INDEX "idx_abuse_events_created_at" ON "public"."abuse_events" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_abuse_events_event_type" ON "public"."abuse_events" USING "btree" ("event_type");

CREATE INDEX "idx_abuse_events_ip_address" ON "public"."abuse_events" USING "btree" ("ip_address");

CREATE INDEX "idx_abuse_events_ip_type_created" ON "public"."abuse_events" USING "btree" ("ip_address", "event_type", "created_at" DESC);

CREATE INDEX "idx_blocked_ips_expires_at" ON "public"."blocked_ips" USING "btree" ("expires_at")
WHERE
  ("status" = 'active' :: "public"."ip_block_status");

CREATE INDEX "idx_blocked_ips_ip_address" ON "public"."blocked_ips" USING "btree" ("ip_address");

CREATE INDEX "idx_blocked_ips_ip_status_expires" ON "public"."blocked_ips" USING "btree" ("ip_address", "status", "expires_at");

CREATE INDEX "idx_blocked_ips_status" ON "public"."blocked_ips" USING "btree" ("status");

CREATE INDEX "idx_calendar_sync_dashboard_error_type" ON "public"."calendar_sync_dashboard" USING "btree" ("error_type")
WHERE
  ("error_type" IS NOT NULL);

CREATE INDEX "idx_calendar_sync_dashboard_timing_total" ON "public"."calendar_sync_dashboard" USING "btree" ("timing_total_ms")
WHERE
  ("timing_total_ms" IS NOT NULL);

CREATE INDEX "idx_calendar_sync_dashboard_triggered_from" ON "public"."calendar_sync_dashboard" USING "btree" ("triggered_from")
WHERE
  ("triggered_from" IS NOT NULL);

CREATE INDEX "idx_changelog_entries_category" ON "public"."changelog_entries" USING "btree" ("category");

CREATE INDEX "idx_changelog_entries_created_at" ON "public"."changelog_entries" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_changelog_entries_creator_id" ON "public"."changelog_entries" USING "btree" ("creator_id");

CREATE INDEX "idx_changelog_entries_published_at" ON "public"."changelog_entries" USING "btree" ("published_at" DESC)
WHERE
  ("is_published" = true);

CREATE INDEX "idx_changelog_entries_slug" ON "public"."changelog_entries" USING "btree" ("slug");

CREATE INDEX "idx_chat_channels_ws_id" ON "public"."workspace_chat_channels" USING "btree" ("ws_id");

CREATE INDEX "idx_chat_messages_channel_id" ON "public"."workspace_chat_messages" USING "btree" ("channel_id");

CREATE INDEX "idx_chat_messages_created_at" ON "public"."workspace_chat_messages" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_chat_participants_channel_id" ON "public"."workspace_chat_participants" USING "btree" ("channel_id");

CREATE INDEX "idx_chat_participants_user_id" ON "public"."workspace_chat_participants" USING "btree" ("user_id");

CREATE INDEX "idx_cross_app_tokens_token" ON "public"."cross_app_tokens" USING "btree" ("token");

CREATE INDEX "idx_cross_app_tokens_user_id" ON "public"."cross_app_tokens" USING "btree" ("user_id");

CREATE INDEX "idx_email_audit_created_at" ON "public"."email_audit" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_email_audit_entity" ON "public"."email_audit" USING "btree" ("entity_type", "entity_id")
WHERE
  (
    ("entity_type" IS NOT NULL)
    AND ("entity_id" IS NOT NULL)
  );

CREATE INDEX "idx_email_audit_message_id" ON "public"."email_audit" USING "btree" ("message_id")
WHERE
  ("message_id" IS NOT NULL);

CREATE INDEX "idx_email_audit_status" ON "public"."email_audit" USING "btree" ("status");

CREATE INDEX "idx_email_audit_template_type" ON "public"."email_audit" USING "btree" ("template_type")
WHERE
  ("template_type" IS NOT NULL);

CREATE INDEX "idx_email_audit_user_id" ON "public"."email_audit" USING "btree" ("user_id")
WHERE
  ("user_id" IS NOT NULL);

CREATE INDEX "idx_email_audit_ws_id" ON "public"."email_audit" USING "btree" ("ws_id");

CREATE INDEX "idx_email_audit_ws_status_created" ON "public"."email_audit" USING "btree" ("ws_id", "status", "created_at" DESC);

CREATE INDEX "idx_email_bounce_complaints_bounce_type" ON "public"."email_bounce_complaints" USING "btree" ("bounce_type")
WHERE
  ("bounce_type" IS NOT NULL);

CREATE INDEX "idx_email_bounce_complaints_email_hash" ON "public"."email_bounce_complaints" USING "btree" ("email_hash");

CREATE INDEX "idx_email_bounce_complaints_event_type" ON "public"."email_bounce_complaints" USING "btree" ("event_type", "created_at" DESC);

CREATE INDEX "idx_email_bounce_complaints_original_email" ON "public"."email_bounce_complaints" USING "btree" ("original_email_id")
WHERE
  ("original_email_id" IS NOT NULL);

CREATE INDEX "idx_habit_calendar_events_date" ON "public"."habit_calendar_events" USING "btree" ("habit_id", "occurrence_date");

CREATE INDEX "idx_habit_calendar_events_event_id" ON "public"."habit_calendar_events" USING "btree" ("event_id");

CREATE INDEX "idx_habit_calendar_events_habit_id" ON "public"."habit_calendar_events" USING "btree" ("habit_id");

CREATE INDEX "idx_habit_completions_date" ON "public"."habit_completions" USING "btree" ("habit_id", "occurrence_date");

CREATE INDEX "idx_habit_completions_habit_id" ON "public"."habit_completions" USING "btree" ("habit_id");

CREATE INDEX "idx_live_api_sessions_expires" ON "public"."live_api_sessions" USING "btree" ("expires_at");

CREATE INDEX "idx_live_api_sessions_user_ws" ON "public"."live_api_sessions" USING "btree" ("user_id", "ws_id");

CREATE INDEX "idx_notes_created_at" ON "public"."notes" USING "btree" ("created_at");

CREATE INDEX "idx_notes_creator_id" ON "public"."notes" USING "btree" ("creator_id");

CREATE INDEX "idx_notes_ws_id" ON "public"."notes" USING "btree" ("ws_id");

CREATE INDEX "idx_notification_batches_delivery_mode" ON "public"."notification_batches" USING "btree" ("delivery_mode", "status");

CREATE INDEX "idx_notification_batches_pending" ON "public"."notification_batches" USING "btree" ("status", "window_end", "channel")
WHERE
  ("status" = 'pending' :: "text");

CREATE INDEX "idx_notification_batches_status" ON "public"."notification_batches" USING "btree" ("status", "window_end");

CREATE INDEX "idx_notification_batches_user" ON "public"."notification_batches" USING "btree" ("user_id", "ws_id");

CREATE INDEX "idx_notification_delivery_log_batch" ON "public"."notification_delivery_log" USING "btree" ("batch_id");

CREATE INDEX "idx_notification_delivery_log_notification" ON "public"."notification_delivery_log" USING "btree" ("notification_id");

CREATE INDEX "idx_notification_delivery_log_pending" ON "public"."notification_delivery_log" USING "btree" ("status", "created_at")
WHERE
  ("status" = 'pending' :: "text");

CREATE INDEX "idx_notification_delivery_log_status" ON "public"."notification_delivery_log" USING "btree" ("status", "channel");

CREATE INDEX "idx_notification_email_config_mode" ON "public"."notification_email_config" USING "btree" ("delivery_mode")
WHERE
  (
    "delivery_mode" = 'immediate' :: "public"."notification_delivery_mode"
  );

CREATE INDEX "idx_notification_email_config_type" ON "public"."notification_email_config" USING "btree" ("notification_type");

CREATE INDEX "idx_notification_preferences_enabled" ON "public"."notification_preferences" USING "btree" ("user_id", "event_type", "channel", "enabled");

CREATE INDEX "idx_notification_preferences_user" ON "public"."notification_preferences" USING "btree" ("user_id", "ws_id");

CREATE UNIQUE INDEX "idx_notification_preferences_user_unique" ON "public"."notification_preferences" USING "btree" ("user_id", "event_type", "channel", "scope")
WHERE
  ("ws_id" IS NULL);

CREATE UNIQUE INDEX "idx_notification_preferences_workspace_unique" ON "public"."notification_preferences" USING "btree" (
  "ws_id",
  "user_id",
  "event_type",
  "channel",
  "scope"
)
WHERE
  ("ws_id" IS NOT NULL);

CREATE INDEX "idx_notifications_code" ON "public"."notifications" USING "btree" ("code")
WHERE
  ("code" IS NOT NULL);

CREATE INDEX "idx_notifications_created_at" ON "public"."notifications" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_notifications_email" ON "public"."notifications" USING "btree" ("email")
WHERE
  ("email" IS NOT NULL);

CREATE INDEX "idx_notifications_entity" ON "public"."notifications" USING "btree" ("entity_type", "entity_id");

CREATE INDEX "idx_notifications_expires_at" ON "public"."notifications" USING "btree" ("expires_at")
WHERE
  ("expires_at" IS NOT NULL);

CREATE INDEX "idx_notifications_parent_id" ON "public"."notifications" USING "btree" ("parent_id")
WHERE
  ("parent_id" IS NOT NULL);

CREATE INDEX "idx_notifications_priority" ON "public"."notifications" USING "btree" ("priority");

CREATE INDEX "idx_notifications_read_at" ON "public"."notifications" USING "btree" ("read_at");

CREATE INDEX "idx_notifications_scope" ON "public"."notifications" USING "btree" ("scope");

CREATE INDEX "idx_notifications_type" ON "public"."notifications" USING "btree" ("type");

CREATE INDEX "idx_notifications_user_created" ON "public"."notifications" USING "btree" ("user_id", "created_at" DESC, "id" DESC);

COMMENT ON INDEX "public"."idx_notifications_user_created" IS 'Composite index for consistent notification ordering by user. Ensures notifications are always returned in the same order (created_at DESC, id DESC) for efficient pagination and stable UI.';

CREATE INDEX "idx_notifications_user_id" ON "public"."notifications" USING "btree" ("user_id");

CREATE INDEX "idx_notifications_user_scope_created" ON "public"."notifications" USING "btree" ("user_id", "scope", "created_at" DESC, "id" DESC)
WHERE
  (
    ("scope" = 'user' :: "public"."notification_scope")
    AND ("ws_id" IS NULL)
  );

COMMENT ON INDEX "public"."idx_notifications_user_scope_created" IS 'Composite index for user-scoped notifications (null ws_id) with consistent ordering.';

CREATE INDEX "idx_notifications_user_scope_unread" ON "public"."notifications" USING "btree" ("user_id", "scope", "read_at")
WHERE
  ("read_at" IS NULL);

CREATE INDEX "idx_notifications_user_unread" ON "public"."notifications" USING "btree" ("user_id", "read_at")
WHERE
  ("read_at" IS NULL);

CREATE INDEX "idx_notifications_ws_created" ON "public"."notifications" USING "btree" ("ws_id", "created_at" DESC, "id" DESC)
WHERE
  ("ws_id" IS NOT NULL);

COMMENT ON INDEX "public"."idx_notifications_ws_created" IS 'Composite index for workspace-scoped notifications with consistent ordering.';

CREATE INDEX "idx_notifications_ws_id" ON "public"."notifications" USING "btree" ("ws_id");

CREATE INDEX "idx_nova_problem_test_cases_problem_id" ON "public"."nova_problem_test_cases" USING "btree" ("problem_id");

CREATE INDEX "idx_nova_submission_criteria_submission_id" ON "public"."nova_submission_criteria" USING "btree" ("submission_id");

CREATE INDEX "idx_nova_submission_test_cases_submission_id" ON "public"."nova_submission_test_cases" USING "btree" ("submission_id");

CREATE INDEX "idx_nova_submissions_problem_id" ON "public"."nova_submissions" USING "btree" ("problem_id");

CREATE INDEX "idx_onboarding_progress_team_workspace" ON "public"."onboarding_progress" USING "btree" ("team_workspace_id")
WHERE
  ("team_workspace_id" IS NOT NULL);

CREATE INDEX "idx_platform_email_roles_email" ON "public"."platform_email_roles" USING "btree" ("email");

CREATE INDEX "idx_shortened_links_creator_id" ON "public"."shortened_links" USING "btree" ("creator_id")
WHERE
  ("creator_id" IS NOT NULL);

CREATE INDEX "idx_shortened_links_domain" ON "public"."shortened_links" USING "btree" ("public"."extract_domain"("link"))
WHERE
  (
    ("link" IS NOT NULL)
    AND ("link" <> '' :: "text")
  );

CREATE INDEX "idx_task_calendar_events_event_id" ON "public"."task_calendar_events" USING "btree" ("event_id");

CREATE INDEX "idx_task_calendar_events_task_id" ON "public"."task_calendar_events" USING "btree" ("task_id");

CREATE INDEX "idx_task_cycles_creator_id" ON "public"."task_cycles" USING "btree" ("creator_id");

CREATE INDEX "idx_task_cycles_end_date" ON "public"."task_cycles" USING "btree" ("end_date");

CREATE INDEX "idx_task_cycles_start_date" ON "public"."task_cycles" USING "btree" ("start_date");

CREATE INDEX "idx_task_cycles_status" ON "public"."task_cycles" USING "btree" ("status");

CREATE INDEX "idx_task_cycles_ws_id" ON "public"."task_cycles" USING "btree" ("ws_id");

CREATE INDEX "idx_task_history_change_type" ON "public"."task_history" USING "btree" ("change_type")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_history_changed_at" ON "public"."task_history" USING "btree" ("changed_at" DESC)
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_history_changed_by" ON "public"."task_history" USING "btree" ("changed_by")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_history_task_changed" ON "public"."task_history" USING "btree" ("task_id", "changed_at" DESC)
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_history_task_id" ON "public"."task_history" USING "btree" ("task_id")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_initiatives_creator_id" ON "public"."task_initiatives" USING "btree" ("creator_id");

CREATE INDEX "idx_task_initiatives_status" ON "public"."task_initiatives" USING "btree" ("status");

CREATE INDEX "idx_task_initiatives_ws_id" ON "public"."task_initiatives" USING "btree" ("ws_id");

CREATE INDEX "idx_task_labels_label_id" ON "public"."task_labels" USING "btree" ("label_id");

CREATE INDEX "idx_task_labels_task_id" ON "public"."task_labels" USING "btree" ("task_id");

CREATE INDEX "idx_task_lists_board_status" ON "public"."task_lists" USING "btree" ("board_id", "status");

CREATE INDEX "idx_task_lists_status" ON "public"."task_lists" USING "btree" ("status");

CREATE INDEX "idx_task_project_update_attachments_deleted_at" ON "public"."task_project_update_attachments" USING "btree" ("deleted_at")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_project_update_attachments_update_id" ON "public"."task_project_update_attachments" USING "btree" ("update_id");

CREATE INDEX "idx_task_project_update_attachments_uploaded_by" ON "public"."task_project_update_attachments" USING "btree" ("uploaded_by");

CREATE INDEX "idx_task_project_update_comments_created_at" ON "public"."task_project_update_comments" USING "btree" ("created_at");

CREATE INDEX "idx_task_project_update_comments_deleted_at" ON "public"."task_project_update_comments" USING "btree" ("deleted_at")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_project_update_comments_parent_id" ON "public"."task_project_update_comments" USING "btree" ("parent_id");

CREATE INDEX "idx_task_project_update_comments_update_created" ON "public"."task_project_update_comments" USING "btree" ("update_id", "created_at");

CREATE INDEX "idx_task_project_update_comments_update_id" ON "public"."task_project_update_comments" USING "btree" ("update_id");

CREATE INDEX "idx_task_project_update_comments_user_id" ON "public"."task_project_update_comments" USING "btree" ("user_id");

CREATE INDEX "idx_task_project_update_reactions_update_id" ON "public"."task_project_update_reactions" USING "btree" ("update_id");

CREATE INDEX "idx_task_project_update_reactions_user_id" ON "public"."task_project_update_reactions" USING "btree" ("user_id");

CREATE INDEX "idx_task_project_updates_created_at" ON "public"."task_project_updates" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_task_project_updates_creator_id" ON "public"."task_project_updates" USING "btree" ("creator_id");

CREATE INDEX "idx_task_project_updates_deleted_at" ON "public"."task_project_updates" USING "btree" ("deleted_at")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_task_project_updates_project_created" ON "public"."task_project_updates" USING "btree" ("project_id", "created_at" DESC);

CREATE INDEX "idx_task_project_updates_project_id" ON "public"."task_project_updates" USING "btree" ("project_id");

CREATE INDEX "idx_task_projects_creator_id" ON "public"."task_projects" USING "btree" ("creator_id");

CREATE INDEX "idx_task_projects_dates" ON "public"."task_projects" USING "btree" ("start_date", "end_date");

CREATE INDEX "idx_task_projects_health_status" ON "public"."task_projects" USING "btree" ("health_status");

CREATE INDEX "idx_task_projects_lead_id" ON "public"."task_projects" USING "btree" ("lead_id");

CREATE INDEX "idx_task_projects_priority" ON "public"."task_projects" USING "btree" ("priority");

CREATE INDEX "idx_task_projects_status" ON "public"."task_projects" USING "btree" ("status");

CREATE INDEX "idx_task_projects_ws_id" ON "public"."task_projects" USING "btree" ("ws_id");

CREATE INDEX "idx_task_relationships_source" ON "public"."task_relationships" USING "btree" ("source_task_id");

CREATE INDEX "idx_task_relationships_source_type" ON "public"."task_relationships" USING "btree" ("source_task_id", "type");

CREATE INDEX "idx_task_relationships_target" ON "public"."task_relationships" USING "btree" ("target_task_id");

CREATE INDEX "idx_task_relationships_target_type" ON "public"."task_relationships" USING "btree" ("target_task_id", "type");

CREATE INDEX "idx_task_relationships_type" ON "public"."task_relationships" USING "btree" ("type");

CREATE INDEX "idx_task_reminder_sent_sent_at" ON "public"."task_reminder_sent" USING "btree" ("sent_at");

CREATE INDEX "idx_task_reminder_sent_task_user" ON "public"."task_reminder_sent" USING "btree" ("task_id", "user_id");

CREATE INDEX "idx_task_user_scheduling_settings_user_id" ON "public"."task_user_scheduling_settings" USING "btree" ("user_id");

CREATE INDEX "idx_task_watchers_task_id" ON "public"."task_watchers" USING "btree" ("task_id");

CREATE INDEX "idx_task_watchers_user_id" ON "public"."task_watchers" USING "btree" ("user_id");

CREATE UNIQUE INDEX "idx_tasks_board_display_number" ON "public"."tasks" USING "btree" ("board_id", "display_number")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_tasks_list_sort" ON "public"."tasks" USING "btree" ("list_id", "sort_key")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_time_tracking_breaks_active" ON "public"."time_tracking_breaks" USING "btree" ("session_id", "created_by")
WHERE
  ("break_end" IS NULL);

CREATE INDEX "idx_time_tracking_breaks_break_type_id" ON "public"."time_tracking_breaks" USING "btree" ("break_type_id");

CREATE INDEX "idx_time_tracking_breaks_created_by" ON "public"."time_tracking_breaks" USING "btree" ("created_by");

CREATE INDEX "idx_time_tracking_breaks_session_id" ON "public"."time_tracking_breaks" USING "btree" ("session_id");

CREATE INDEX "idx_time_tracking_requests_break_type_id" ON "public"."time_tracking_requests" USING "btree" ("break_type_id");

CREATE INDEX "idx_time_tracking_requests_linked_session" ON "public"."time_tracking_requests" USING "btree" ("linked_session_id")
WHERE
  ("linked_session_id" IS NOT NULL);

CREATE INDEX "idx_time_tracking_requests_workspace_user" ON "public"."time_tracking_requests" USING "btree" ("workspace_id", "user_id", "approval_status");

CREATE INDEX "idx_time_tracking_sessions_category_date" ON "public"."time_tracking_sessions" USING "btree" ("category_id", "start_time")
WHERE
  ("category_id" IS NOT NULL);

CREATE INDEX "idx_time_tracking_sessions_date" ON "public"."time_tracking_sessions" USING "btree" ("date");

CREATE INDEX "idx_time_tracking_sessions_date_range" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "user_id", "start_time");

CREATE INDEX "idx_time_tracking_sessions_duration" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "duration_seconds")
WHERE
  ("duration_seconds" IS NOT NULL);

CREATE INDEX "idx_time_tracking_sessions_parent_session_id" ON "public"."time_tracking_sessions" USING "btree" ("parent_session_id");

CREATE INDEX "idx_time_tracking_sessions_pending_approval" ON "public"."time_tracking_sessions" USING "btree" ("pending_approval")
WHERE
  ("pending_approval" = true);

CREATE INDEX "idx_time_tracking_sessions_root_sessions" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "user_id", "start_time")
WHERE
  ("parent_session_id" IS NULL);

CREATE INDEX "idx_time_tracking_sessions_running" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "is_running")
WHERE
  ("is_running" = true);

CREATE INDEX "idx_time_tracking_sessions_tags" ON "public"."time_tracking_sessions" USING "gin" ("tags");

CREATE INDEX "idx_time_tracking_sessions_task_date" ON "public"."time_tracking_sessions" USING "btree" ("task_id", "start_time")
WHERE
  ("task_id" IS NOT NULL);

CREATE INDEX "idx_time_tracking_sessions_title_trgm" ON "public"."time_tracking_sessions" USING "gin" ("title" "public"."gin_trgm_ops");

CREATE INDEX "idx_time_tracking_sessions_user_ws_start" ON "public"."time_tracking_sessions" USING "btree" ("user_id", "ws_id", "start_time" DESC)
WHERE
  ("duration_seconds" IS NOT NULL);

COMMENT ON INDEX "public"."idx_time_tracking_sessions_user_ws_start" IS 'Optimizes per-user time tracking queries';

CREATE INDEX "idx_time_tracking_sessions_was_resumed" ON "public"."time_tracking_sessions" USING "btree" ("was_resumed")
WHERE
  ("was_resumed" = true);

CREATE INDEX "idx_time_tracking_sessions_ws_date_range" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "start_time", "end_time")
WHERE
  ("duration_seconds" IS NOT NULL);

CREATE INDEX "idx_time_tracking_sessions_ws_start_time" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "start_time" DESC)
WHERE
  ("duration_seconds" IS NOT NULL);

COMMENT ON INDEX "public"."idx_time_tracking_sessions_ws_start_time" IS 'Optimizes workspace-wide time tracking queries by workspace and start time';

CREATE INDEX "idx_time_tracking_sessions_ws_user_date" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "user_id", "date");

CREATE INDEX "idx_time_tracking_sessions_ws_user_start" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "user_id", "start_time" DESC)
WHERE
  ("duration_seconds" IS NOT NULL);

COMMENT ON INDEX "public"."idx_time_tracking_sessions_ws_user_start" IS 'Composite index for workspace + user queries with completed sessions (used by daily reports)';

CREATE INDEX "idx_transaction_categories_ws_id" ON "public"."transaction_categories" USING "btree" ("ws_id");

CREATE INDEX "idx_typing_indicators_channel_id" ON "public"."workspace_chat_typing_indicators" USING "btree" ("channel_id");

CREATE INDEX "idx_typing_indicators_updated_at" ON "public"."workspace_chat_typing_indicators" USING "btree" ("updated_at");

CREATE INDEX "idx_users_created_at" ON "public"."users" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_wallet_transactions_category_id" ON "public"."wallet_transactions" USING "btree" ("category_id");

CREATE INDEX "idx_wallet_transactions_category_taken_at" ON "public"."wallet_transactions" USING "btree" ("category_id", "taken_at" DESC)
WHERE
  ("category_id" IS NOT NULL);

CREATE INDEX "idx_wallet_transactions_confidential_flags" ON "public"."wallet_transactions" USING "btree" (
  "is_amount_confidential",
  "is_description_confidential",
  "is_category_confidential"
)
WHERE
  (
    "is_amount_confidential"
    OR "is_description_confidential"
    OR "is_category_confidential"
  );

CREATE INDEX "idx_wallet_transactions_creator_taken_at" ON "public"."wallet_transactions" USING "btree" ("creator_id", "taken_at" DESC);

CREATE INDEX "idx_wallet_transactions_description_gin" ON "public"."wallet_transactions" USING "gin" ("description" "public"."gin_trgm_ops");

CREATE INDEX "idx_wallet_transactions_taken_at_created_at" ON "public"."wallet_transactions" USING "btree" ("taken_at" DESC, "created_at" DESC);

CREATE INDEX "idx_wallet_transactions_wallet_id" ON "public"."wallet_transactions" USING "btree" ("wallet_id");

CREATE INDEX "idx_wallet_transactions_wallet_taken_at" ON "public"."wallet_transactions" USING "btree" ("wallet_id", "taken_at" DESC);

CREATE INDEX "idx_whiteboards_creator_id" ON "public"."workspace_whiteboards" USING "btree" ("creator_id");

CREATE INDEX "idx_whiteboards_snapshot_gin" ON "public"."workspace_whiteboards" USING "gin" ("snapshot");

CREATE INDEX "idx_whiteboards_ws_id" ON "public"."workspace_whiteboards" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_ai_executions_ws_id_created_at" ON "public"."workspace_ai_executions" USING "btree" ("ws_id", "created_at" DESC);

COMMENT ON INDEX "public"."idx_workspace_ai_executions_ws_id_created_at" IS 'Optimizes queries for workspace-specific execution history';

CREATE INDEX "idx_workspace_ai_executions_ws_id_model_created" ON "public"."workspace_ai_executions" USING "btree" ("ws_id", "model_id", "created_at" DESC);

COMMENT ON INDEX "public"."idx_workspace_ai_executions_ws_id_model_created" IS 'Optimizes complex analytics queries with model and date filters';

CREATE INDEX "idx_workspace_ai_executions_ws_id_model_id" ON "public"."workspace_ai_executions" USING "btree" ("ws_id", "model_id");

COMMENT ON INDEX "public"."idx_workspace_ai_executions_ws_id_model_id" IS 'Optimizes model-specific analytics queries';

CREATE INDEX "idx_workspace_ai_executions_ws_id_model_tokens" ON "public"."workspace_ai_executions" USING "btree" (
  "ws_id",
  "model_id",
  "input_tokens",
  "output_tokens",
  "reasoning_tokens"
);

COMMENT ON INDEX "public"."idx_workspace_ai_executions_ws_id_model_tokens" IS 'Optimizes cost calculation queries';

CREATE INDEX "idx_workspace_ai_executions_ws_id_tokens" ON "public"."workspace_ai_executions" USING "btree" ("ws_id", "total_tokens" DESC);

COMMENT ON INDEX "public"."idx_workspace_ai_executions_ws_id_tokens" IS 'Optimizes token usage analytics';

CREATE INDEX "idx_workspace_api_key_usage_logs_api_key_id" ON "public"."workspace_api_key_usage_logs" USING "btree" ("api_key_id");

CREATE INDEX "idx_workspace_api_key_usage_logs_created_at" ON "public"."workspace_api_key_usage_logs" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_workspace_api_key_usage_logs_key_id_created" ON "public"."workspace_api_key_usage_logs" USING "btree" ("api_key_id", "created_at" DESC);

CREATE INDEX "idx_workspace_api_key_usage_logs_ws_id" ON "public"."workspace_api_key_usage_logs" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_api_keys_expires_at" ON "public"."workspace_api_keys" USING "btree" ("expires_at")
WHERE
  ("expires_at" IS NOT NULL);

CREATE INDEX "idx_workspace_api_keys_role_id" ON "public"."workspace_api_keys" USING "btree" ("role_id");

CREATE UNIQUE INDEX "idx_workspace_api_keys_ws_id_key_hash" ON "public"."workspace_api_keys" USING "btree" ("ws_id", "key_hash")
WHERE
  ("key_hash" IS NOT NULL);

CREATE UNIQUE INDEX "idx_workspace_api_keys_ws_id_key_prefix" ON "public"."workspace_api_keys" USING "btree" ("ws_id", "key_prefix")
WHERE
  ("key_prefix" IS NOT NULL);

CREATE INDEX "idx_workspace_boards_archived_at" ON "public"."workspace_boards" USING "btree" ("archived_at")
WHERE
  ("archived_at" IS NULL);

CREATE INDEX "idx_workspace_boards_deleted_at" ON "public"."workspace_boards" USING "btree" ("deleted_at")
WHERE
  ("deleted_at" IS NULL);

CREATE UNIQUE INDEX "idx_workspace_break_types_single_default" ON "public"."workspace_break_types" USING "btree" ("ws_id")
WHERE
  ("is_default" = true);

CREATE INDEX "idx_workspace_break_types_ws_id" ON "public"."workspace_break_types" USING "btree" ("ws_id");

CREATE UNIQUE INDEX "idx_workspace_break_types_ws_name_unique" ON "public"."workspace_break_types" USING "btree" ("ws_id", "lower"("name"));

CREATE INDEX "idx_workspace_calendar_events_end_at" ON "public"."workspace_calendar_events" USING "btree" ("end_at");

CREATE INDEX "idx_workspace_calendar_events_start_at" ON "public"."workspace_calendar_events" USING "btree" ("start_at");

CREATE INDEX "idx_workspace_calendar_events_task_id" ON "public"."workspace_calendar_events" USING "btree" ("task_id")
WHERE
  ("task_id" IS NOT NULL);

CREATE INDEX "idx_workspace_encryption_keys_ws_id" ON "public"."workspace_encryption_keys" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_habits_active" ON "public"."workspace_habits" USING "btree" ("ws_id", "is_active")
WHERE
  ("deleted_at" IS NULL);

CREATE INDEX "idx_workspace_habits_auto_schedule" ON "public"."workspace_habits" USING "btree" ("ws_id", "auto_schedule")
WHERE
  (
    ("is_active" = true)
    AND ("deleted_at" IS NULL)
  );

CREATE INDEX "idx_workspace_habits_creator" ON "public"."workspace_habits" USING "btree" ("creator_id")
WHERE
  ("creator_id" IS NOT NULL);

CREATE INDEX "idx_workspace_habits_ws_id" ON "public"."workspace_habits" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_members_ws_id" ON "public"."workspace_members" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_scheduling_metadata_last_scheduled" ON "public"."workspace_scheduling_metadata" USING "btree" ("last_scheduled_at" DESC);

CREATE INDEX "idx_workspace_scheduling_metadata_ws_id" ON "public"."workspace_scheduling_metadata" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_task_labels_ws_id" ON "public"."workspace_task_labels" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_task_reminder_settings_ws_id" ON "public"."workspace_task_reminder_settings" USING "btree" ("ws_id");

CREATE INDEX "idx_workspace_wallets_ws_id" ON "public"."workspace_wallets" USING "btree" ("ws_id");

CREATE INDEX "idx_workspaces_created_at" ON "public"."workspaces" USING "btree" ("created_at" DESC);

CREATE INDEX "link_analytics_browser_idx" ON "public"."link_analytics" USING "btree" ("browser");

CREATE INDEX "link_analytics_city_idx" ON "public"."link_analytics" USING "btree" ("city");

CREATE INDEX "link_analytics_clicked_at_idx" ON "public"."link_analytics" USING "btree" ("clicked_at");

CREATE INDEX "link_analytics_country_idx" ON "public"."link_analytics" USING "btree" ("country");

CREATE INDEX "link_analytics_device_type_idx" ON "public"."link_analytics" USING "btree" ("device_type");

CREATE INDEX "link_analytics_link_id_idx" ON "public"."link_analytics" USING "btree" ("link_id");

CREATE INDEX "link_analytics_os_idx" ON "public"."link_analytics" USING "btree" ("os");

CREATE INDEX "link_analytics_referrer_domain_idx" ON "public"."link_analytics" USING "btree" ("referrer_domain");

CREATE INDEX "link_analytics_vercel_region_idx" ON "public"."link_analytics" USING "btree" ("vercel_region");

CREATE UNIQUE INDEX "one_personal_workspace_per_creator" ON "public"."workspaces" USING "btree" ("creator_id")
WHERE
  ("personal" = true);

CREATE UNIQUE INDEX "one_referral_promo_per_user" ON "public"."workspace_promotions" USING "btree" ("owner_id")
WHERE
  (
    "promo_type" = 'REFERRAL' :: "public"."promotion_type"
  );

CREATE INDEX "posts_dashboard_view_created_at_idx" ON "public"."posts_dashboard_view" USING "btree" ("created_at" DESC);

CREATE INDEX "posts_dashboard_view_email_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("email_id");

CREATE INDEX "posts_dashboard_view_group_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("group_id");

CREATE UNIQUE INDEX "posts_dashboard_view_post_user_idx" ON "public"."posts_dashboard_view" USING "btree" ("post_id", "user_id");

CREATE INDEX "posts_dashboard_view_user_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("user_id");

CREATE INDEX "posts_dashboard_view_ws_id_created_at_idx" ON "public"."posts_dashboard_view" USING "btree" ("ws_id", "created_at" DESC);

CREATE INDEX "posts_dashboard_view_ws_id_group_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("ws_id", "group_id");

CREATE INDEX "posts_dashboard_view_ws_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("ws_id");

CREATE INDEX "posts_dashboard_view_ws_id_user_id_idx" ON "public"."posts_dashboard_view" USING "btree" ("ws_id", "user_id");

CREATE INDEX "realtime_log_aggregations_time_bucket_idx" ON "public"."realtime_log_aggregations" USING "btree" ("time_bucket" DESC);

CREATE INDEX "recurring_transactions_is_active_idx" ON "public"."recurring_transactions" USING "btree" ("is_active");

CREATE INDEX "recurring_transactions_next_occurrence_idx" ON "public"."recurring_transactions" USING "btree" ("next_occurrence");

CREATE INDEX "recurring_transactions_wallet_id_idx" ON "public"."recurring_transactions" USING "btree" ("wallet_id");

CREATE INDEX "recurring_transactions_ws_id_idx" ON "public"."recurring_transactions" USING "btree" ("ws_id");

CREATE INDEX "sent_emails_post_id_idx" ON "public"."sent_emails" USING "btree" ("post_id");

CREATE INDEX "sent_emails_receiver_id_idx" ON "public"."sent_emails" USING "btree" ("receiver_id");

CREATE INDEX "shortened_links_domain_idx" ON "public"."shortened_links" USING "btree" ("domain");

CREATE INDEX "tasks_closed_at_idx" ON "public"."tasks" USING "btree" ("closed_at")
WHERE
  ("closed_at" IS NOT NULL);

CREATE INDEX "tasks_completed_at_idx" ON "public"."tasks" USING "btree" ("completed_at")
WHERE
  ("completed_at" IS NOT NULL);

CREATE INDEX "tasks_deleted_at_idx" ON "public"."tasks" USING "btree" ("deleted_at")
WHERE
  ("deleted_at" IS NOT NULL);

CREATE INDEX "tasks_embedding_idx" ON "public"."tasks" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops");

CREATE INDEX "tasks_fts_idx" ON "public"."tasks" USING "gin" ("fts");

CREATE INDEX "time_tracking_sessions_is_running_idx" ON "public"."time_tracking_sessions" USING "btree" ("is_running");

CREATE UNIQUE INDEX "time_tracking_sessions_one_running_per_user" ON "public"."time_tracking_sessions" USING "btree" ("ws_id", "user_id")
WHERE
  ("is_running" = true);

CREATE INDEX "time_tracking_sessions_start_time_idx" ON "public"."time_tracking_sessions" USING "btree" ("start_time");

CREATE INDEX "time_tracking_sessions_task_id_idx" ON "public"."time_tracking_sessions" USING "btree" ("task_id");

CREATE INDEX "time_tracking_sessions_user_id_idx" ON "public"."time_tracking_sessions" USING "btree" ("user_id");

CREATE INDEX "time_tracking_sessions_ws_id_idx" ON "public"."time_tracking_sessions" USING "btree" ("ws_id");

CREATE INDEX "transaction_tags_ws_id_idx" ON "public"."transaction_tags" USING "btree" ("ws_id");

CREATE INDEX "user_group_post_checks_created_at_idx" ON "public"."user_group_post_checks" USING "btree" ("created_at" DESC);

CREATE INDEX "user_group_post_checks_user_id_created_at_idx" ON "public"."user_group_post_checks" USING "btree" ("user_id", "created_at" DESC);

CREATE INDEX "user_group_post_checks_user_id_idx" ON "public"."user_group_post_checks" USING "btree" ("user_id");

CREATE INDEX "user_group_posts_created_at_idx" ON "public"."user_group_posts" USING "btree" ("created_at" DESC);

CREATE INDEX "user_group_posts_group_id_idx" ON "public"."user_group_posts" USING "btree" ("group_id");

CREATE INDEX "wallet_transaction_tags_tag_id_idx" ON "public"."wallet_transaction_tags" USING "btree" ("tag_id");

CREATE INDEX "wallet_transaction_tags_transaction_id_idx" ON "public"."wallet_transaction_tags" USING "btree" ("transaction_id");

CREATE INDEX "wallet_transactions_description_idx" ON "public"."wallet_transactions" USING "gin" ("description" "public"."gin_trgm_ops");

CREATE INDEX "wallet_transactions_taken_at_created_at_idx" ON "public"."wallet_transactions" USING "btree" ("taken_at" DESC, "created_at" DESC);

CREATE INDEX "wm_user_ws_idx" ON "public"."workspace_members" USING "btree" ("user_id", "ws_id");

CREATE INDEX "workspace_calendar_categories_position_idx" ON "public"."workspace_calendar_categories" USING "btree" ("ws_id", "position");

CREATE INDEX "workspace_calendar_categories_ws_id_idx" ON "public"."workspace_calendar_categories" USING "btree" ("ws_id");

CREATE UNIQUE INDEX "workspace_calendar_categories_ws_id_name_unique" ON "public"."workspace_calendar_categories" USING "btree" ("ws_id", "lower"("name"));

CREATE INDEX "workspace_calendar_events_external_idx" ON "public"."workspace_calendar_events" USING "btree" (
  "ws_id",
  "provider",
  "external_calendar_id",
  "external_event_id"
);

CREATE INDEX "workspace_calendar_events_google_calendar_id_idx" ON "public"."workspace_calendar_events" USING "btree" ("google_calendar_id");

CREATE INDEX "workspace_calendar_events_provider_idx" ON "public"."workspace_calendar_events" USING "btree" ("ws_id", "provider");

CREATE INDEX "workspace_calendar_events_scheduling_idx" ON "public"."workspace_calendar_events" USING "btree" ("ws_id", "scheduling_source");

CREATE INDEX "workspace_calendar_events_source_calendar_idx" ON "public"."workspace_calendar_events" USING "btree" ("source_calendar_id");

CREATE INDEX "workspace_calendar_events_ws_id_google_calendar_id_idx" ON "public"."workspace_calendar_events" USING "btree" ("ws_id", "google_calendar_id");

CREATE INDEX "workspace_calendar_sync_log_status_idx" ON "public"."workspace_calendar_sync_log" USING "btree" ("status");

CREATE INDEX "workspace_calendar_sync_log_sync_started_at_idx" ON "public"."workspace_calendar_sync_log" USING "btree" ("sync_started_at");

CREATE INDEX "workspace_calendar_sync_log_workspace_id_idx" ON "public"."workspace_calendar_sync_log" USING "btree" ("ws_id");

CREATE INDEX "workspace_calendars_enabled_idx" ON "public"."workspace_calendars" USING "btree" ("ws_id", "is_enabled")
WHERE
  ("is_enabled" = true);

CREATE UNIQUE INDEX "workspace_calendars_system_type_unique" ON "public"."workspace_calendars" USING "btree" ("ws_id", "calendar_type")
WHERE
  (
    "calendar_type" = ANY (
      ARRAY ['primary'::"public"."workspace_calendar_type", 'tasks'::"public"."workspace_calendar_type", 'habits'::"public"."workspace_calendar_type"]
    )
  );

CREATE INDEX "workspace_calendars_ws_id_idx" ON "public"."workspace_calendars" USING "btree" ("ws_id");

CREATE INDEX "workspace_education_access_requests_created_at_idx" ON "public"."workspace_education_access_requests" USING "btree" ("created_at");

CREATE INDEX "workspace_education_access_requests_status_idx" ON "public"."workspace_education_access_requests" USING "btree" ("status");

CREATE UNIQUE INDEX "workspace_education_access_requests_unique_pending" ON "public"."workspace_education_access_requests" USING "btree" ("ws_id", "feature")
WHERE
  ("status" = 'pending' :: "text");

CREATE INDEX "workspace_education_access_requests_ws_id_idx" ON "public"."workspace_education_access_requests" USING "btree" ("ws_id");

CREATE INDEX "workspace_invite_link_uses_invite_link_id_idx" ON "public"."workspace_invite_link_uses" USING "btree" ("invite_link_id");

CREATE INDEX "workspace_invite_link_uses_user_id_idx" ON "public"."workspace_invite_link_uses" USING "btree" ("user_id");

CREATE INDEX "workspace_invite_link_uses_ws_id_idx" ON "public"."workspace_invite_link_uses" USING "btree" ("ws_id");

CREATE UNIQUE INDEX "workspace_invite_links_code_key" ON "public"."workspace_invite_links" USING "btree" ("code");

CREATE INDEX "workspace_invite_links_expires_at_idx" ON "public"."workspace_invite_links" USING "btree" ("expires_at");

CREATE INDEX "workspace_invite_links_ws_id_idx" ON "public"."workspace_invite_links" USING "btree" ("ws_id");

CREATE INDEX "workspace_orders_created_at_idx" ON "public"."workspace_orders" USING "btree" ("created_at" DESC);

CREATE INDEX "workspace_orders_polar_order_id_idx" ON "public"."workspace_orders" USING "btree" ("polar_order_id");

CREATE INDEX "workspace_orders_polar_subscription_id_idx" ON "public"."workspace_orders" USING "btree" ("polar_subscription_id");

CREATE INDEX "workspace_orders_status_idx" ON "public"."workspace_orders" USING "btree" ("status");

CREATE INDEX "workspace_orders_user_id_idx" ON "public"."workspace_orders" USING "btree" ("user_id");

CREATE INDEX "workspace_orders_ws_id_idx" ON "public"."workspace_orders" USING "btree" ("ws_id");

CREATE INDEX "workspace_user_fields_ws_id_created_at_idx" ON "public"."workspace_user_fields" USING "btree" ("ws_id", "created_at" DESC);

CREATE INDEX "workspace_user_groups_name_idx" ON "public"."workspace_user_groups" USING "btree" ("name");

CREATE INDEX "workspace_user_groups_users_group_id_idx" ON "public"."workspace_user_groups_users" USING "btree" ("group_id");

CREATE INDEX "workspace_user_groups_users_user_id_idx" ON "public"."workspace_user_groups_users" USING "btree" ("user_id");

CREATE INDEX "workspace_user_groups_ws_id_idx" ON "public"."workspace_user_groups" USING "btree" ("ws_id");

CREATE INDEX "workspace_user_linked_users_virtual_user_id_idx" ON "public"."workspace_user_linked_users" USING "btree" ("virtual_user_id");

CREATE INDEX "workspace_user_roles_users_role_id_index" ON "public"."workspace_user_groups_users" USING "btree" ("group_id");

CREATE INDEX "workspace_user_roles_ws_id_index" ON "public"."workspace_user_groups" USING "btree" ("ws_id");

CREATE INDEX "workspace_users_display_name_trgm_idx" ON "public"."workspace_users" USING "gin" ("display_name" "public"."gin_trgm_ops");

CREATE INDEX "workspace_users_full_name_idx" ON "public"."workspace_users" USING "btree" ("full_name");

CREATE INDEX "workspace_users_full_name_trgm_idx" ON "public"."workspace_users" USING "gin" ("full_name" "public"."gin_trgm_ops");

CREATE INDEX "workspace_users_ws_id_full_name_idx" ON "public"."workspace_users" USING "btree" ("ws_id", "full_name");

CREATE INDEX "workspace_users_ws_id_idx" ON "public"."workspace_users" USING "btree" ("ws_id");

CREATE INDEX "workspace_wallets_ws_id_idx" ON "public"."workspace_wallets" USING "btree" ("ws_id");

CREATE UNIQUE INDEX "workspaces_handle_key" ON "public"."workspaces" USING "btree" ("handle");

CREATE
OR REPLACE VIEW "public"."workspace_user_groups_with_amount" WITH ("security_invoker" = 'on') AS
SELECT
  "workspace_user_groups"."id",
  "workspace_user_groups"."ws_id",
  "workspace_user_groups"."name",
  "workspace_user_groups"."created_at",
  "workspace_user_groups"."archived",
  "workspace_user_groups"."ending_date",
  "workspace_user_groups"."notes",
  "workspace_user_groups"."sessions",
  "workspace_user_groups"."starting_date",
  "count"("workspace_user_groups_users".*) AS "amount"
FROM
  (
    "public"."workspace_user_groups"
    LEFT JOIN "public"."workspace_user_groups_users" ON (
      (
        "workspace_user_groups_users"."group_id" = "workspace_user_groups"."id"
      )
    )
  )
GROUP BY
  "workspace_user_groups"."id";

CREATE
OR REPLACE VIEW "public"."workspace_user_groups_with_guest" AS
SELECT
  "workspace_user_groups"."id",
  "workspace_user_groups"."ws_id",
  "workspace_user_groups"."name",
  "workspace_user_groups"."created_at",
  "workspace_user_groups"."archived",
  "workspace_user_groups"."ending_date",
  "workspace_user_groups"."notes",
  "workspace_user_groups"."sessions",
  "workspace_user_groups"."starting_date",
  "workspace_user_groups"."is_guest",
  "count"("workspace_user_groups_users".*) AS "amount"
FROM
  (
    "public"."workspace_user_groups"
    LEFT JOIN "public"."workspace_user_groups_users" ON (
      (
        "workspace_user_groups_users"."group_id" = "workspace_user_groups"."id"
      )
    )
  )
GROUP BY
  "workspace_user_groups"."id";

CREATE
OR REPLACE TRIGGER "add_ws_creator_tr"
AFTER
INSERT
  ON "public"."workspaces" FOR EACH ROW EXECUTE FUNCTION "public"."add_ws_creator"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."calendar_event_colors" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."calendar_event_participant_groups" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."calendar_event_platform_participants" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."calendar_event_virtual_participants" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."credit_wallets" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."currencies" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."finance_invoice_products" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."finance_invoices" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."handles" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_checkup_vital_groups" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_checkup_vitals" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_checkups" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_diagnoses" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_vital_groups" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."healthcare_vitals" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_batch_products" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_batches" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_products" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_suppliers" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_units" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_warehouses" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."personal_notes" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."product_categories" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."task_lists" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."team_members" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."transaction_categories" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."user_private_details" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."vital_group_vitals" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."wallet_transactions" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."wallet_types" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_boards" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_calendar_sync_coordination" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_invites" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_members" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_products" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_teams" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_user_groups" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_user_groups_users" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_users" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_wallet_transfers" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspace_wallets" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_i_u_d"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."workspaces" FOR EACH ROW EXECUTE FUNCTION "audit"."insert_update_delete_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."calendar_event_colors" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."calendar_event_participant_groups" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."calendar_event_platform_participants" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."calendar_event_virtual_participants" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."credit_wallets" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."currencies" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."finance_invoice_products" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."finance_invoices" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."handles" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_checkup_vital_groups" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_checkup_vitals" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_checkups" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_diagnoses" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_vital_groups" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."healthcare_vitals" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_batch_products" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_batches" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_products" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_suppliers" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_units" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."inventory_warehouses" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."personal_notes" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."product_categories" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."task_lists" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."team_members" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."transaction_categories" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."user_private_details" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."users" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."vital_group_vitals" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."wallet_transactions" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."wallet_types" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_boards" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_calendar_sync_coordination" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_invites" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_members" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_products" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_teams" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_user_groups" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_user_groups_users" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_users" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_wallet_transfers" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspace_wallets" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "audit_t"
AFTER
  TRUNCATE ON "public"."workspaces" FOR EACH STATEMENT EXECUTE FUNCTION "audit"."truncate_trigger"();

CREATE
OR REPLACE TRIGGER "auto_add_assignee_as_watcher_trigger"
AFTER
INSERT
  ON "public"."task_assignees" FOR EACH ROW EXECUTE FUNCTION "public"."auto_add_assignee_as_watcher"();

CREATE
OR REPLACE TRIGGER "before_insert_guest_lead_generation" BEFORE
INSERT
  ON "public"."guest_users_lead_generation" FOR EACH ROW EXECUTE FUNCTION "public"."check_guest_lead_generation_conditions"();

CREATE
OR REPLACE TRIGGER "changelog_entries_updated_at" BEFORE
UPDATE
  ON "public"."changelog_entries" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "check_challenge_attempt_limits" BEFORE
INSERT
  ON "public"."nova_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."check_challenge_attempt_limits"();

CREATE
OR REPLACE TRIGGER "check_personal_workspace_threshold" BEFORE
INSERT
  OR
UPDATE
  ON "public"."workspace_settings" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_personal_workspace_threshold_modification"();

COMMENT ON TRIGGER "check_personal_workspace_threshold" ON "public"."workspace_settings" IS 'Enforces that personal workspaces cannot have missed_entry_date_threshold configured.';

CREATE
OR REPLACE TRIGGER "cleanup_platform_email_roles_trigger"
AFTER
INSERT
  ON "public"."platform_user_roles" FOR EACH ROW EXECUTE FUNCTION "public"."cleanup_platform_email_roles"();

CREATE
OR REPLACE TRIGGER "create_default_lists_on_board_creation"
AFTER
INSERT
  ON "public"."workspace_boards" FOR EACH ROW EXECUTE FUNCTION "public"."create_default_lists_from_template"();

CREATE
OR REPLACE TRIGGER "create_system_calendars_on_workspace"
AFTER
INSERT
  ON "public"."workspaces" FOR EACH ROW EXECUTE FUNCTION "public"."create_workspace_system_calendars"();

CREATE
OR REPLACE TRIGGER "create_workspace_user_linked_user"
AFTER
INSERT
  ON "public"."workspace_members" FOR EACH ROW EXECUTE FUNCTION "public"."create_workspace_user_linked_user"();

CREATE
OR REPLACE TRIGGER "delete_complementary_transaction_tr"
AFTER
  DELETE ON "public"."workspace_wallet_transfers" FOR EACH ROW EXECUTE FUNCTION "public"."delete_complementary_transaction"();

CREATE
OR REPLACE TRIGGER "delete_invite_when_accepted_tr"
AFTER
INSERT
  ON "public"."workspace_members" FOR EACH ROW EXECUTE FUNCTION "public"."delete_invite_when_accepted"();

CREATE
OR REPLACE TRIGGER "delete_wallet_transaction"
AFTER
  DELETE ON "public"."finance_invoices" FOR EACH ROW EXECUTE FUNCTION "public"."delete_wallet_transaction"();

CREATE
OR REPLACE TRIGGER "delete_workspace_member_when_unlink"
AFTER
  DELETE ON "public"."workspace_user_linked_users" FOR EACH ROW EXECUTE FUNCTION "public"."delete_workspace_member_when_unlink"();

ALTER TABLE
  "public"."workspace_user_linked_users" DISABLE TRIGGER "delete_workspace_member_when_unlink";

CREATE
OR REPLACE TRIGGER "email_audit_updated_at" BEFORE
UPDATE
  ON "public"."email_audit" FOR EACH ROW EXECUTE FUNCTION "public"."update_email_audit_updated_at"();

CREATE
OR REPLACE TRIGGER "enforce_single_closed_list" BEFORE
INSERT
  OR
UPDATE
  ON "public"."task_lists" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_single_closed_list"();

CREATE
OR REPLACE TRIGGER "enforce_time_tracking_insert" BEFORE
INSERT
  ON "public"."time_tracking_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."check_time_tracking_session_insert"();

CREATE
OR REPLACE TRIGGER "enforce_time_tracking_request_update" BEFORE
UPDATE
  ON "public"."time_tracking_requests" FOR EACH ROW EXECUTE FUNCTION "public"."check_time_tracking_request_update"();

CREATE
OR REPLACE TRIGGER "enforce_time_tracking_update" BEFORE
UPDATE
  ON "public"."time_tracking_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."check_time_tracking_session_update"();

CREATE
OR REPLACE TRIGGER "habit_calendar_events_updated_at" BEFORE
UPDATE
  ON "public"."habit_calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "notify_on_task_assigned"
AFTER
INSERT
  ON "public"."task_assignees" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_assigned"();

COMMENT ON TRIGGER "notify_on_task_assigned" ON "public"."task_assignees" IS 'Creates notifications when users are assigned to tasks';

CREATE
OR REPLACE TRIGGER "notify_on_task_assignee_added"
AFTER
INSERT
  ON "public"."task_assignees" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_assignee_added"();

CREATE
OR REPLACE TRIGGER "notify_on_task_assignee_removed"
AFTER
  DELETE ON "public"."task_assignees" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_assignee_removed"();

CREATE
OR REPLACE TRIGGER "notify_on_task_label_added"
AFTER
INSERT
  ON "public"."task_labels" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_label_added"();

CREATE
OR REPLACE TRIGGER "notify_on_task_label_removed"
AFTER
  DELETE ON "public"."task_labels" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_label_removed"();

CREATE
OR REPLACE TRIGGER "notify_on_task_project_linked"
AFTER
INSERT
  ON "public"."task_project_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_project_linked"();

CREATE
OR REPLACE TRIGGER "notify_on_task_project_unlinked"
AFTER
  DELETE ON "public"."task_project_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_project_unlinked"();

CREATE
OR REPLACE TRIGGER "notify_on_task_updated"
AFTER
UPDATE
  ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_updated"();

CREATE
OR REPLACE TRIGGER "redirect_platform_email_roles_trigger" BEFORE
INSERT
  ON "public"."platform_email_roles" FOR EACH ROW EXECUTE FUNCTION "public"."redirect_platform_email_roles_insert"();

CREATE
OR REPLACE TRIGGER "set_task_project_update_comments_updated_at" BEFORE
UPDATE
  ON "public"."task_project_update_comments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

COMMENT ON TRIGGER "set_task_project_update_comments_updated_at" ON "public"."task_project_update_comments" IS 'Automatically updates updated_at timestamp when comment is modified (uses shared update_updated_at_column function)';

CREATE
OR REPLACE TRIGGER "stop_other_running_sessions_trigger"
AFTER
INSERT
  OR
UPDATE
  ON "public"."time_tracking_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."stop_other_running_sessions"();

CREATE
OR REPLACE TRIGGER "store_task_metadata_before_delete_trigger" BEFORE DELETE ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."store_task_metadata_before_delete"();

CREATE
OR REPLACE TRIGGER "sync_invoice_transaction"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."finance_invoices" FOR EACH ROW EXECUTE FUNCTION "public"."sync_invoice_transaction"();

CREATE
OR REPLACE TRIGGER "t_auto_link_referral_promo"
AFTER
INSERT
  ON "public"."workspace_promotions" FOR EACH ROW
  WHEN (
    (
      (
        "new"."promo_type" = 'REFERRAL' :: "public"."promotion_type"
      )
      AND ("new"."owner_id" IS NOT NULL)
    )
  ) EXECUTE FUNCTION "public"."auto_link_referral_promotion"();

CREATE
OR REPLACE TRIGGER "t_prevent_invalid_referral_link" BEFORE
INSERT
  ON "public"."user_linked_promotions" FOR EACH ROW EXECUTE FUNCTION "public"."fn_prevent_invalid_referral_link"();

CREATE
OR REPLACE TRIGGER "t_prevent_owner_referral_unlink" BEFORE DELETE ON "public"."user_linked_promotions" FOR EACH ROW EXECUTE FUNCTION "public"."fn_prevent_owner_referral_unlink"();

CREATE
OR REPLACE TRIGGER "task_calendar_events_updated_at" BEFORE
UPDATE
  ON "public"."task_calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_task_calendar_events_updated_at"();

CREATE
OR REPLACE TRIGGER "task_created_trigger"
AFTER
INSERT
  ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."notify_task_created"();

CREATE
OR REPLACE TRIGGER "task_timestamps_trigger" BEFORE
INSERT
  OR
UPDATE
  OF "list_id" ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."set_task_timestamps"();

CREATE
OR REPLACE TRIGGER "time_tracking_breaks_duration_trigger" BEFORE
INSERT
  OR
UPDATE
  ON "public"."time_tracking_breaks" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_time_tracking_break_duration"();

CREATE
OR REPLACE TRIGGER "time_tracking_breaks_updated_at_trigger" BEFORE
UPDATE
  ON "public"."time_tracking_breaks" FOR EACH ROW EXECUTE FUNCTION "public"."update_time_tracking_breaks_updated_at"();

CREATE
OR REPLACE TRIGGER "trg_create_personal_workspace_for_new_user"
AFTER
INSERT
  ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "public"."create_personal_workspace_for_new_user"();

CREATE
OR REPLACE TRIGGER "trg_enforce_extended_estimation"
AFTER
UPDATE
  OF "extended_estimation" ON "public"."workspace_boards" FOR EACH ROW EXECUTE FUNCTION "public"."enforce_extended_estimation"();

CREATE
OR REPLACE TRIGGER "trg_set_analytics_metadata" BEFORE
INSERT
  OR
UPDATE
  OF "referrer",
  "user_agent" ON "public"."link_analytics" FOR EACH ROW EXECUTE FUNCTION "public"."set_analytics_metadata"();

CREATE
OR REPLACE TRIGGER "trg_set_first_workspace_as_default"
AFTER
INSERT
  ON "public"."workspace_members" FOR EACH ROW EXECUTE FUNCTION "public"."set_first_workspace_as_default"();

CREATE
OR REPLACE TRIGGER "trg_set_shortened_links_domain" BEFORE
INSERT
  OR
UPDATE
  OF "link" ON "public"."shortened_links" FOR EACH ROW EXECUTE FUNCTION "public"."set_shortened_links_domain"();

CREATE
OR REPLACE TRIGGER "trg_task_user_scheduling_settings_updated_at" BEFORE
UPDATE
  ON "public"."task_user_scheduling_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "trg_update_workspace_invite_links_updated_at" BEFORE
UPDATE
  ON "public"."workspace_invite_links" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_invite_links_updated_at"();

CREATE
OR REPLACE TRIGGER "trigger_assign_task_display_number" BEFORE
INSERT
  OR
UPDATE
  OF "list_id" ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."assign_task_display_number"();

CREATE
OR REPLACE TRIGGER "trigger_cleanup_expired_cross_app_tokens"
AFTER
INSERT
  ON "public"."cross_app_tokens" FOR EACH STATEMENT EXECUTE FUNCTION "public"."trigger_cleanup_expired_cross_app_tokens"();

CREATE
OR REPLACE TRIGGER "trigger_enforce_single_parent" BEFORE
INSERT
  OR
UPDATE
  ON "public"."task_relationships" FOR EACH ROW EXECUTE FUNCTION "public"."enforce_single_parent_constraint"();

CREATE
OR REPLACE TRIGGER "trigger_handle_request_status_change" BEFORE
UPDATE
  ON "public"."time_tracking_requests" FOR EACH ROW EXECUTE FUNCTION "public"."handle_request_status_change"();

CREATE
OR REPLACE TRIGGER "trigger_normalize_related_relationship" BEFORE
INSERT
  OR
UPDATE
  ON "public"."task_relationships" FOR EACH ROW EXECUTE FUNCTION "public"."normalize_related_relationship"();

CREATE
OR REPLACE TRIGGER "trigger_notify_workspace_email_invite"
AFTER
INSERT
  ON "public"."workspace_email_invites" FOR EACH ROW EXECUTE FUNCTION "public"."notify_workspace_email_invite"();

CREATE
OR REPLACE TRIGGER "trigger_notify_workspace_user_invite"
AFTER
INSERT
  ON "public"."workspace_invites" FOR EACH ROW EXECUTE FUNCTION "public"."notify_workspace_user_invite"();

CREATE
OR REPLACE TRIGGER "trigger_prevent_circular_parent_child" BEFORE
INSERT
  OR
UPDATE
  ON "public"."task_relationships" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_circular_parent_child"();

CREATE
OR REPLACE TRIGGER "trigger_send_immediate_notification"
AFTER
INSERT
  ON "public"."notification_batches" FOR EACH ROW
  WHEN (
    (
      "new"."delivery_mode" = 'immediate' :: "public"."notification_delivery_mode"
    )
  ) EXECUTE FUNCTION "public"."trigger_immediate_notification_send"();

CREATE
OR REPLACE TRIGGER "trigger_update_workspace_encryption_keys_updated_at" BEFORE
UPDATE
  ON "public"."workspace_encryption_keys" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_encryption_keys_updated_at"();

CREATE
OR REPLACE TRIGGER "trigger_validate_task_relationship_scope" BEFORE
INSERT
  OR
UPDATE
  ON "public"."task_relationships" FOR EACH ROW EXECUTE FUNCTION "public"."validate_task_relationship_scope"();

CREATE
OR REPLACE TRIGGER "update_blocked_ips_updated_at" BEFORE
UPDATE
  ON "public"."blocked_ips" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "update_budget_spent_trigger"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."wallet_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_budget_spent"();

CREATE
OR REPLACE TRIGGER "update_calendar_connections_updated_at" BEFORE
UPDATE
  ON "public"."calendar_connections" FOR EACH ROW EXECUTE FUNCTION "public"."update_calendar_connections_updated_at"();

CREATE
OR REPLACE TRIGGER "update_chat_channels_updated_at" BEFORE
UPDATE
  ON "public"."workspace_chat_channels" FOR EACH ROW EXECUTE FUNCTION "public"."update_chat_updated_at"();

CREATE
OR REPLACE TRIGGER "update_chat_messages_updated_at" BEFORE
UPDATE
  ON "public"."workspace_chat_messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_chat_updated_at"();

CREATE
OR REPLACE TRIGGER "update_email_blacklist_updated_at"
AFTER
UPDATE
  ON "public"."email_blacklist" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "update_inventory_products_amount_trigger"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."inventory_batch_products" FOR EACH ROW EXECUTE FUNCTION "public"."update_inventory_product_amount"();

CREATE
OR REPLACE TRIGGER "update_inventory_products_from_invoice"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."finance_invoice_products" FOR EACH ROW EXECUTE FUNCTION "public"."update_inventory_products_from_invoice"();

CREATE
OR REPLACE TRIGGER "update_invoice_products_warehouse" BEFORE
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."finance_invoice_products" FOR EACH ROW EXECUTE FUNCTION "public"."update_invoice_products_warehouse"();

CREATE
OR REPLACE TRIGGER "update_notification_batches_updated_at" BEFORE
UPDATE
  ON "public"."notification_batches" FOR EACH ROW EXECUTE FUNCTION "public"."update_notification_batches_updated_at"();

CREATE
OR REPLACE TRIGGER "update_notification_delivery_log_updated_at" BEFORE
UPDATE
  ON "public"."notification_delivery_log" FOR EACH ROW EXECUTE FUNCTION "public"."update_notification_delivery_log_updated_at"();

CREATE
OR REPLACE TRIGGER "update_notification_email_config_updated_at" BEFORE
UPDATE
  ON "public"."notification_email_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_notification_email_config_updated_at"();

CREATE
OR REPLACE TRIGGER "update_notification_preferences_updated_at" BEFORE
UPDATE
  ON "public"."notification_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_notification_preferences_updated_at"();

CREATE
OR REPLACE TRIGGER "update_onboarding_progress_updated_at" BEFORE
UPDATE
  ON "public"."onboarding_progress" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "update_productivity_score_trigger" BEFORE
INSERT
  OR
UPDATE
  ON "public"."time_tracking_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_productivity_score"();

CREATE
OR REPLACE TRIGGER "update_recording_sessions_updated_at" BEFORE
UPDATE
  ON "public"."recording_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "update_session_duration_trigger" BEFORE
UPDATE
  ON "public"."time_tracking_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_session_duration"();

CREATE
OR REPLACE TRIGGER "update_task_project_updates_updated_at" BEFORE
UPDATE
  ON "public"."task_project_updates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "update_transaction_amount" BEFORE
UPDATE
  ON "public"."wallet_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_transaction_amount"();

CREATE
OR REPLACE TRIGGER "update_transfer_transaction_amount"
AFTER
UPDATE
  ON "public"."wallet_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."sync_transfer_transactions"();

CREATE
OR REPLACE TRIGGER "update_wallet_balance_tr"
AFTER
INSERT
  OR DELETE
  OR
UPDATE
  ON "public"."wallet_transactions" FOR EACH ROW EXECUTE FUNCTION "public"."update_wallet_balance"();

CREATE
OR REPLACE TRIGGER "update_wallet_transaction_amount"
AFTER
UPDATE
  OF "price",
  "total_diff" ON "public"."finance_invoices" FOR EACH ROW EXECUTE FUNCTION "public"."update_wallet_transaction_amount"();

CREATE
OR REPLACE TRIGGER "update_wallet_transactions"
AFTER
UPDATE
  OF "is_expense" ON "public"."transaction_categories" FOR EACH ROW EXECUTE FUNCTION "public"."update_wallet_transactions"();

CREATE
OR REPLACE TRIGGER "update_workspace_api_keys_updated_at" BEFORE
UPDATE
  ON "public"."workspace_api_keys" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_api_keys_updated_at"();

CREATE
OR REPLACE TRIGGER "update_workspace_calendar_sync_coordination_updated_at" BEFORE
UPDATE
  ON "public"."workspace_calendar_sync_coordination" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_calendar_sync_coordination_updated_at"();

CREATE
OR REPLACE TRIGGER "update_workspace_task_reminder_settings_updated_at" BEFORE
UPDATE
  ON "public"."workspace_task_reminder_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "workspace_break_types_updated_at_trigger" BEFORE
UPDATE
  ON "public"."workspace_break_types" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_break_types_updated_at"();

CREATE
OR REPLACE TRIGGER "workspace_calendar_categories_updated_at_trigger" BEFORE
UPDATE
  ON "public"."workspace_calendar_categories" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_calendar_categories_updated_at"();

CREATE
OR REPLACE TRIGGER "workspace_education_access_requests_updated_at" BEFORE
UPDATE
  ON "public"."workspace_education_access_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_workspace_education_access_requests_updated_at"();

CREATE
OR REPLACE TRIGGER "workspace_habits_updated_at" BEFORE
UPDATE
  ON "public"."workspace_habits" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE
OR REPLACE TRIGGER "workspace_scheduling_metadata_updated_at" BEFORE
UPDATE
  ON "public"."workspace_scheduling_metadata" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

ALTER TABLE
  ONLY "audit"."record_version"
ADD
  CONSTRAINT "record_version_auth_uid_fkey" FOREIGN KEY ("auth_uid") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."ai_chat_members"
ADD
  CONSTRAINT "ai_chat_members_chat_id_fkey" FOREIGN KEY ("chat_id") REFERENCES "public"."ai_chats"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."ai_chat_messages"
ADD
  CONSTRAINT "ai_chat_messages_chat_id_fkey" FOREIGN KEY ("chat_id") REFERENCES "public"."ai_chats"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."ai_chat_messages"
ADD
  CONSTRAINT "ai_chat_messages_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."ai_chats"
ADD
  CONSTRAINT "ai_chats_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."audio_chunks"
ADD
  CONSTRAINT "audio_chunks_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."recording_sessions"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."aurora_ml_forecast"
ADD
  CONSTRAINT "aurora_ml_forecast_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."aurora_ml_metrics"
ADD
  CONSTRAINT "aurora_ml_metrics_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."aurora_statistical_forecast"
ADD
  CONSTRAINT "aurora_statistical_forecast_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."aurora_statistical_metrics"
ADD
  CONSTRAINT "aurora_statistical_metrics_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."blocked_ips"
ADD
  CONSTRAINT "blocked_ips_unblocked_by_fkey" FOREIGN KEY ("unblocked_by") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."calendar_auth_tokens"
ADD
  CONSTRAINT "calendar_auth_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_auth_tokens"
ADD
  CONSTRAINT "calendar_auth_tokens_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_connections"
ADD
  CONSTRAINT "calendar_connections_auth_token_id_fkey" FOREIGN KEY ("auth_token_id") REFERENCES "public"."calendar_auth_tokens"("id") ON UPDATE CASCADE ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."calendar_connections"
ADD
  CONSTRAINT "calendar_connections_workspace_calendar_id_fkey" FOREIGN KEY ("workspace_calendar_id") REFERENCES "public"."workspace_calendars"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."calendar_connections"
ADD
  CONSTRAINT "calendar_connections_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_participant_groups"
ADD
  CONSTRAINT "calendar_event_participant_groups_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_participant_groups"
ADD
  CONSTRAINT "calendar_event_participant_groups_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_platform_participants"
ADD
  CONSTRAINT "calendar_event_platform_participants_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_platform_participants"
ADD
  CONSTRAINT "calendar_event_platform_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_virtual_participants"
ADD
  CONSTRAINT "calendar_event_virtual_participants_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_event_virtual_participants"
ADD
  CONSTRAINT "calendar_event_virtual_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_sync_dashboard"
ADD
  CONSTRAINT "calendar_sync_dashboard_triggered_by_fkey" FOREIGN KEY ("triggered_by") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_sync_dashboard"
ADD
  CONSTRAINT "calendar_sync_dashboard_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."calendar_sync_states"
ADD
  CONSTRAINT "calendar_sync_states_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."changelog_entries"
ADD
  CONSTRAINT "changelog_entries_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_certificates"
ADD
  CONSTRAINT "course_certificates_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."workspace_courses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_certificates"
ADD
  CONSTRAINT "course_certificates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_completion_status"
ADD
  CONSTRAINT "course_module_completion_status_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."workspace_course_modules"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_completion_status"
ADD
  CONSTRAINT "course_module_completion_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_flashcards"
ADD
  CONSTRAINT "course_module_flashcards_flashcard_id_fkey" FOREIGN KEY ("flashcard_id") REFERENCES "public"."workspace_flashcards"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_flashcards"
ADD
  CONSTRAINT "course_module_flashcards_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."workspace_course_modules"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_quiz_sets"
ADD
  CONSTRAINT "course_module_quiz_sets_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."workspace_course_modules"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_quiz_sets"
ADD
  CONSTRAINT "course_module_quiz_sets_set_id_fkey" FOREIGN KEY ("set_id") REFERENCES "public"."workspace_quiz_sets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_quizzes"
ADD
  CONSTRAINT "course_module_quizzes_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."workspace_course_modules"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."course_module_quizzes"
ADD
  CONSTRAINT "course_module_quizzes_quiz_id_fkey" FOREIGN KEY ("quiz_id") REFERENCES "public"."workspace_quizzes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."crawled_url_next_urls"
ADD
  CONSTRAINT "crawled_url_next_urls_origin_id_fkey" FOREIGN KEY ("origin_id") REFERENCES "public"."crawled_urls"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."crawled_urls"
ADD
  CONSTRAINT "crawled_urls_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."credit_wallets"
ADD
  CONSTRAINT "credit_wallets_wallet_id_fkey" FOREIGN KEY ("wallet_id") REFERENCES "public"."workspace_wallets"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."cross_app_tokens"
ADD
  CONSTRAINT "cross_app_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."discord_guild_members"
ADD
  CONSTRAINT "discord_guild_members_platform_user_id_fkey" FOREIGN KEY ("platform_user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."discord_integrations"
ADD
  CONSTRAINT "discord_integrations_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."discord_integrations"
ADD
  CONSTRAINT "discord_integrations_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."email_audit"
ADD
  CONSTRAINT "email_audit_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."email_audit"
ADD
  CONSTRAINT "email_audit_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."email_blacklist"
ADD
  CONSTRAINT "email_blacklist_added_by_user_id_fkey" FOREIGN KEY ("added_by_user_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."email_bounce_complaints"
ADD
  CONSTRAINT "email_bounce_complaints_original_email_id_fkey" FOREIGN KEY ("original_email_id") REFERENCES "public"."email_audit"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."external_user_monthly_report_logs"
ADD
  CONSTRAINT "external_user_monthly_report_logs_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."external_user_monthly_report_logs"
ADD
  CONSTRAINT "external_user_monthly_report_logs_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."external_user_monthly_report_logs"
ADD
  CONSTRAINT "external_user_monthly_report_logs_report_id_fkey" FOREIGN KEY ("report_id") REFERENCES "public"."external_user_monthly_reports"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."external_user_monthly_report_logs"
ADD
  CONSTRAINT "external_user_monthly_report_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."external_user_monthly_reports"
ADD
  CONSTRAINT "external_user_monthly_reports_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."external_user_monthly_reports"
ADD
  CONSTRAINT "external_user_monthly_reports_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id");

ALTER TABLE
  ONLY "public"."finance_budgets"
ADD
  CONSTRAINT "finance_budgets_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."transaction_categories"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_budgets"
ADD
  CONSTRAINT "finance_budgets_wallet_id_fkey" FOREIGN KEY ("wallet_id") REFERENCES "public"."workspace_wallets"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_budgets"
ADD
  CONSTRAINT "finance_budgets_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoice_products"
ADD
  CONSTRAINT "finance_invoice_products_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."finance_invoices"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoice_products"
ADD
  CONSTRAINT "finance_invoice_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_products"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."finance_invoice_products"
ADD
  CONSTRAINT "finance_invoice_products_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."inventory_units"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."finance_invoice_products"
ADD
  CONSTRAINT "finance_invoice_products_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."inventory_warehouses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoice_promotions"
ADD
  CONSTRAINT "finance_invoice_promotions_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."finance_invoices"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoice_promotions"
ADD
  CONSTRAINT "finance_invoice_promotions_promo_id_fkey" FOREIGN KEY ("promo_id") REFERENCES "public"."workspace_promotions"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."transaction_categories"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."wallet_transactions"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_wallet_id_fkey" FOREIGN KEY ("wallet_id") REFERENCES "public"."workspace_wallets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "finance_invoices_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."support_inquiries"
ADD
  CONSTRAINT "fk_support_inquiries_creator_id" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."tasks"
ADD
  CONSTRAINT "fk_tasks_board_id" FOREIGN KEY ("board_id") REFERENCES "public"."workspace_boards"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_promotions"
ADD
  CONSTRAINT "fk_workspace_promotions_owner" FOREIGN KEY ("owner_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_users"
ADD
  CONSTRAINT "fk_workspace_users_referred_by" FOREIGN KEY ("referred_by") REFERENCES "public"."workspace_users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."poll_guest_votes"
ADD
  CONSTRAINT "guest_poll_votes_guest_id_fkey" FOREIGN KEY ("guest_id") REFERENCES "public"."meet_together_guests"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_guest_votes"
ADD
  CONSTRAINT "guest_poll_votes_option_id_fkey" FOREIGN KEY ("option_id") REFERENCES "public"."poll_options"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."guest_users_lead_generation"
ADD
  CONSTRAINT "guest_users_lead_generation_mail_id_fkey" FOREIGN KEY ("mail_id") REFERENCES "public"."sent_emails"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."guest_users_lead_generation"
ADD
  CONSTRAINT "guest_users_lead_generation_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."guest_users_lead_generation"
ADD
  CONSTRAINT "guest_users_lead_generation_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."habit_calendar_events"
ADD
  CONSTRAINT "habit_calendar_events_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."habit_calendar_events"
ADD
  CONSTRAINT "habit_calendar_events_habit_id_fkey" FOREIGN KEY ("habit_id") REFERENCES "public"."workspace_habits"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."habit_completions"
ADD
  CONSTRAINT "habit_completions_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."habit_completions"
ADD
  CONSTRAINT "habit_completions_habit_id_fkey" FOREIGN KEY ("habit_id") REFERENCES "public"."workspace_habits"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."handles"
ADD
  CONSTRAINT "handles_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."healthcare_checkup_vital_groups"
ADD
  CONSTRAINT "healthcare_checkup_vital_groups_checkup_id_fkey" FOREIGN KEY ("checkup_id") REFERENCES "public"."healthcare_checkups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_checkup_vital_groups"
ADD
  CONSTRAINT "healthcare_checkup_vital_groups_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."healthcare_vital_groups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_checkup_vitals"
ADD
  CONSTRAINT "healthcare_checkup_vitals_checkup_id_fkey" FOREIGN KEY ("checkup_id") REFERENCES "public"."healthcare_checkups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_checkup_vitals"
ADD
  CONSTRAINT "healthcare_checkup_vitals_vital_id_fkey" FOREIGN KEY ("vital_id") REFERENCES "public"."healthcare_vitals"("id");

ALTER TABLE
  ONLY "public"."healthcare_checkups"
ADD
  CONSTRAINT "healthcare_checkups_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."healthcare_checkups"
ADD
  CONSTRAINT "healthcare_checkups_diagnosis_id_fkey" FOREIGN KEY ("diagnosis_id") REFERENCES "public"."healthcare_diagnoses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_checkups"
ADD
  CONSTRAINT "healthcare_checkups_patient_id_fkey" FOREIGN KEY ("patient_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_checkups"
ADD
  CONSTRAINT "healthcare_checkups_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_diagnoses"
ADD
  CONSTRAINT "healthcare_diagnoses_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_vital_groups"
ADD
  CONSTRAINT "healthcare_vital_groups_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."healthcare_vitals"
ADD
  CONSTRAINT "healthcare_vitals_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."internal_email_api_keys"
ADD
  CONSTRAINT "internal_email_api_keys_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."internal_email_api_keys"
ADD
  CONSTRAINT "internal_email_api_keys_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."internal_emails"
ADD
  CONSTRAINT "internal_emails_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."internal_emails"
ADD
  CONSTRAINT "internal_emails_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_batch_products"
ADD
  CONSTRAINT "inventory_batch_products_batch_id_fkey" FOREIGN KEY ("batch_id") REFERENCES "public"."inventory_batches"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_batch_products"
ADD
  CONSTRAINT "inventory_batch_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_products"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_batch_products"
ADD
  CONSTRAINT "inventory_batch_products_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."inventory_units"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_batches"
ADD
  CONSTRAINT "inventory_batches_supplier_id_fkey" FOREIGN KEY ("supplier_id") REFERENCES "public"."inventory_suppliers"("id") ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."inventory_batches"
ADD
  CONSTRAINT "inventory_batches_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."inventory_warehouses"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_products"
ADD
  CONSTRAINT "inventory_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_products"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_products"
ADD
  CONSTRAINT "inventory_products_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."inventory_units"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_products"
ADD
  CONSTRAINT "inventory_products_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."inventory_warehouses"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_suppliers"
ADD
  CONSTRAINT "inventory_suppliers_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_units"
ADD
  CONSTRAINT "inventory_units_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."inventory_warehouses"
ADD
  CONSTRAINT "inventory_warehouses_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."link_analytics"
ADD
  CONSTRAINT "link_analytics_link_id_fkey" FOREIGN KEY ("link_id") REFERENCES "public"."shortened_links"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."live_api_sessions"
ADD
  CONSTRAINT "live_api_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."live_api_sessions"
ADD
  CONSTRAINT "live_api_sessions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_guest_timeblocks"
ADD
  CONSTRAINT "meet_together_guest_timeblocks_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."meet_together_plans"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_guest_timeblocks"
ADD
  CONSTRAINT "meet_together_guest_timeblocks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."meet_together_guests"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_guests"
ADD
  CONSTRAINT "meet_together_guests_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."meet_together_plans"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_plans"
ADD
  CONSTRAINT "meet_together_plans_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."meet_together_plans"
ADD
  CONSTRAINT "meet_together_plans_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_user_timeblocks"
ADD
  CONSTRAINT "meet_together_user_timeblocks_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."meet_together_plans"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."meet_together_user_timeblocks"
ADD
  CONSTRAINT "meet_together_user_timeblocks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notes"
ADD
  CONSTRAINT "notes_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notes"
ADD
  CONSTRAINT "notes_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notification_batches"
ADD
  CONSTRAINT "notification_batches_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notification_delivery_log"
ADD
  CONSTRAINT "notification_delivery_log_batch_id_fkey" FOREIGN KEY ("batch_id") REFERENCES "public"."notification_batches"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notification_delivery_log"
ADD
  CONSTRAINT "notification_delivery_log_notification_id_fkey" FOREIGN KEY ("notification_id") REFERENCES "public"."notifications"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notification_preferences"
ADD
  CONSTRAINT "notification_preferences_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notifications"
ADD
  CONSTRAINT "notifications_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."notifications"
ADD
  CONSTRAINT "notifications_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."notifications"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."notifications"
ADD
  CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."notifications"
ADD
  CONSTRAINT "notifications_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_challenge_criteria"
ADD
  CONSTRAINT "nova_challenge_criteria_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."nova_challenges"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_challenge_manager_emails"
ADD
  CONSTRAINT "nova_challenge_manager_emails_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."nova_challenges"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_challenge_whitelisted_emails"
ADD
  CONSTRAINT "nova_challenge_whitelisted_emails_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."nova_challenges"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_problem_test_cases"
ADD
  CONSTRAINT "nova_problem_testcases_problem_id_fkey" FOREIGN KEY ("problem_id") REFERENCES "public"."nova_problems"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_problems"
ADD
  CONSTRAINT "nova_problems_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."nova_challenges"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_sessions"
ADD
  CONSTRAINT "nova_sessions_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."nova_challenges"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_sessions"
ADD
  CONSTRAINT "nova_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submission_criteria"
ADD
  CONSTRAINT "nova_submission_criteria_criteria_id_fkey" FOREIGN KEY ("criteria_id") REFERENCES "public"."nova_challenge_criteria"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submission_criteria"
ADD
  CONSTRAINT "nova_submission_criteria_submission_id_fkey" FOREIGN KEY ("submission_id") REFERENCES "public"."nova_submissions"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submission_test_cases"
ADD
  CONSTRAINT "nova_submission_test_cases_submission_id_fkey" FOREIGN KEY ("submission_id") REFERENCES "public"."nova_submissions"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submission_test_cases"
ADD
  CONSTRAINT "nova_submission_test_cases_test_case_id_fkey" FOREIGN KEY ("test_case_id") REFERENCES "public"."nova_problem_test_cases"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submissions"
ADD
  CONSTRAINT "nova_submissions_problem_id_fkey" FOREIGN KEY ("problem_id") REFERENCES "public"."nova_problems"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_submissions"
ADD
  CONSTRAINT "nova_submissions_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."nova_sessions"("id");

ALTER TABLE
  ONLY "public"."nova_submissions"
ADD
  CONSTRAINT "nova_submissions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_team_emails"
ADD
  CONSTRAINT "nova_team_emails_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."nova_teams"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_team_members"
ADD
  CONSTRAINT "nova_team_members_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."nova_teams"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."nova_team_members"
ADD
  CONSTRAINT "nova_team_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."onboarding_progress"
ADD
  CONSTRAINT "onboarding_progress_team_workspace_id_fkey" FOREIGN KEY ("team_workspace_id") REFERENCES "public"."workspaces"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."onboarding_progress"
ADD
  CONSTRAINT "onboarding_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."personal_notes"
ADD
  CONSTRAINT "personal_notes_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."personal_notes"
ADD
  CONSTRAINT "personal_notes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."platform_user_roles"
ADD
  CONSTRAINT "platform_user_roles_user_id_fkey1" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_guest_permissions"
ADD
  CONSTRAINT "poll_guest_permissions_poll_id_fkey" FOREIGN KEY ("poll_id") REFERENCES "public"."polls"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_options"
ADD
  CONSTRAINT "poll_option_poll_id_fkey" FOREIGN KEY ("poll_id") REFERENCES "public"."polls"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_user_permissions"
ADD
  CONSTRAINT "poll_user_permissions_poll_id_fkey" FOREIGN KEY ("poll_id") REFERENCES "public"."polls"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_user_permissions"
ADD
  CONSTRAINT "poll_user_permissions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."polls"
ADD
  CONSTRAINT "polls_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."polls"
ADD
  CONSTRAINT "polls_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."meet_together_plans"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."polls"
ADD
  CONSTRAINT "polls_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."product_categories"
ADD
  CONSTRAINT "product_categories_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_beneficiary_id_fkey" FOREIGN KEY ("beneficiary_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_products"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."inventory_units"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."product_stock_changes"
ADD
  CONSTRAINT "product_stock_changes_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."inventory_warehouses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_boards"
ADD
  CONSTRAINT "project_boards_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."team_members"
ADD
  CONSTRAINT "project_members_project_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."workspace_teams"("id");

ALTER TABLE
  ONLY "public"."team_members"
ADD
  CONSTRAINT "project_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."ai_chat_messages"
ADD
  CONSTRAINT "public_ai_chat_messages_model_fkey" FOREIGN KEY ("model") REFERENCES "public"."ai_models"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."ai_chats"
ADD
  CONSTRAINT "public_ai_chats_latest_summarized_message_id_fkey" FOREIGN KEY ("latest_summarized_message_id") REFERENCES "public"."ai_chat_messages"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."ai_chats"
ADD
  CONSTRAINT "public_ai_chats_model_fkey" FOREIGN KEY ("model") REFERENCES "public"."ai_models"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."ai_models"
ADD
  CONSTRAINT "public_ai_models_provider_fkey" FOREIGN KEY ("provider") REFERENCES "public"."ai_providers"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."external_user_monthly_reports"
ADD
  CONSTRAINT "public_external_user_monthly_reports_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."finance_invoices"
ADD
  CONSTRAINT "public_finance_invoices_user_group_id_fkey" FOREIGN KEY ("user_group_id") REFERENCES "public"."workspace_user_groups"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."healthcare_vitals"
ADD
  CONSTRAINT "public_healthcare_vitals_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_ai_prompts"
ADD
  CONSTRAINT "public_workspace_ai_prompts_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_ai_prompts"
ADD
  CONSTRAINT "public_workspace_ai_prompts_model_fkey" FOREIGN KEY ("model") REFERENCES "public"."ai_models"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_ai_prompts"
ADD
  CONSTRAINT "public_workspace_ai_prompts_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_configs"
ADD
  CONSTRAINT "public_workspace_configs_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_default_permissions"
ADD
  CONSTRAINT "public_workspace_default_permissions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_products"
ADD
  CONSTRAINT "public_workspace_products_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_promotions"
ADD
  CONSTRAINT "public_workspace_promotions_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_role_members"
ADD
  CONSTRAINT "public_workspace_role_members_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."workspace_roles"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_role_members"
ADD
  CONSTRAINT "public_workspace_role_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_role_permissions"
ADD
  CONSTRAINT "public_workspace_role_permissions_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."workspace_roles"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_role_permissions"
ADD
  CONSTRAINT "public_workspace_role_permissions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_roles"
ADD
  CONSTRAINT "public_workspace_roles_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_fields"
ADD
  CONSTRAINT "public_workspace_user_fields_type_fkey" FOREIGN KEY ("type") REFERENCES "public"."field_types"("id");

ALTER TABLE
  ONLY "public"."workspace_user_fields"
ADD
  CONSTRAINT "public_workspace_user_fields_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_group_tag_groups"
ADD
  CONSTRAINT "public_workspace_user_group_tag_groups_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_group_tag_groups"
ADD
  CONSTRAINT "public_workspace_user_group_tag_groups_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."workspace_user_group_tags"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_group_tags"
ADD
  CONSTRAINT "public_workspace_user_group_tags_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_users"
ADD
  CONSTRAINT "public_workspace_users_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."quiz_options"
ADD
  CONSTRAINT "quiz_options_quiz_id_fkey" FOREIGN KEY ("quiz_id") REFERENCES "public"."workspace_quizzes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."quiz_set_quizzes"
ADD
  CONSTRAINT "quiz_set_quizzes_quiz_id_fkey" FOREIGN KEY ("quiz_id") REFERENCES "public"."workspace_quizzes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."quiz_set_quizzes"
ADD
  CONSTRAINT "quiz_set_quizzes_set_id_fkey" FOREIGN KEY ("set_id") REFERENCES "public"."workspace_quiz_sets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."realtime_log_aggregations"
ADD
  CONSTRAINT "realtime_log_aggregations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."realtime_log_aggregations"
ADD
  CONSTRAINT "realtime_log_aggregations_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."recording_sessions"
ADD
  CONSTRAINT "recording_sessions_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."workspace_meetings"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."recording_sessions"
ADD
  CONSTRAINT "recording_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."recording_transcripts"
ADD
  CONSTRAINT "recording_transcripts_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."recording_sessions"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."recurring_transactions"
ADD
  CONSTRAINT "recurring_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."transaction_categories"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."recurring_transactions"
ADD
  CONSTRAINT "recurring_transactions_wallet_id_fkey" FOREIGN KEY ("wallet_id") REFERENCES "public"."workspace_wallets"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."recurring_transactions"
ADD
  CONSTRAINT "recurring_transactions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."user_group_posts"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_receiver_id_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."workspace_users"("id");

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_sender_id_fkey" FOREIGN KEY ("sender_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_sender_id_fkey1" FOREIGN KEY ("sender_id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."sent_emails"
ADD
  CONSTRAINT "sent_emails_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."shortened_links"
ADD
  CONSTRAINT "shortened_links_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."shortened_links"
ADD
  CONSTRAINT "shortened_links_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_assignees"
ADD
  CONSTRAINT "task_assignees_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_assignees"
ADD
  CONSTRAINT "task_assignees_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_calendar_events"
ADD
  CONSTRAINT "task_calendar_events_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."workspace_calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_calendar_events"
ADD
  CONSTRAINT "task_calendar_events_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_cycle_tasks"
ADD
  CONSTRAINT "task_cycle_tasks_cycle_id_fkey" FOREIGN KEY ("cycle_id") REFERENCES "public"."task_cycles"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_cycle_tasks"
ADD
  CONSTRAINT "task_cycle_tasks_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_cycles"
ADD
  CONSTRAINT "task_cycles_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_cycles"
ADD
  CONSTRAINT "task_cycles_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_history"
ADD
  CONSTRAINT "task_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_history"
ADD
  CONSTRAINT "task_history_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_initiatives"
ADD
  CONSTRAINT "task_initiatives_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_initiatives"
ADD
  CONSTRAINT "task_initiatives_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_labels"
ADD
  CONSTRAINT "task_labels_label_id_fkey" FOREIGN KEY ("label_id") REFERENCES "public"."workspace_task_labels"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_labels"
ADD
  CONSTRAINT "task_labels_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_lists"
ADD
  CONSTRAINT "task_lists_board_id_fkey" FOREIGN KEY ("board_id") REFERENCES "public"."workspace_boards"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_lists"
ADD
  CONSTRAINT "task_lists_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."task_project_initiatives"
ADD
  CONSTRAINT "task_project_initiatives_initiative_id_fkey" FOREIGN KEY ("initiative_id") REFERENCES "public"."task_initiatives"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_initiatives"
ADD
  CONSTRAINT "task_project_initiatives_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."task_projects"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_tasks"
ADD
  CONSTRAINT "task_project_tasks_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."task_projects"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_tasks"
ADD
  CONSTRAINT "task_project_tasks_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_attachments"
ADD
  CONSTRAINT "task_project_update_attachments_update_id_fkey" FOREIGN KEY ("update_id") REFERENCES "public"."task_project_updates"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_attachments"
ADD
  CONSTRAINT "task_project_update_attachments_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_comments"
ADD
  CONSTRAINT "task_project_update_comments_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."task_project_update_comments"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_comments"
ADD
  CONSTRAINT "task_project_update_comments_update_id_fkey" FOREIGN KEY ("update_id") REFERENCES "public"."task_project_updates"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_comments"
ADD
  CONSTRAINT "task_project_update_comments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_reactions"
ADD
  CONSTRAINT "task_project_update_reactions_update_id_fkey" FOREIGN KEY ("update_id") REFERENCES "public"."task_project_updates"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_update_reactions"
ADD
  CONSTRAINT "task_project_update_reactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_updates"
ADD
  CONSTRAINT "task_project_updates_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_project_updates"
ADD
  CONSTRAINT "task_project_updates_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."task_projects"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_projects"
ADD
  CONSTRAINT "task_projects_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_projects"
ADD
  CONSTRAINT "task_projects_lead_id_fkey" FOREIGN KEY ("lead_id") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_projects"
ADD
  CONSTRAINT "task_projects_lead_workspace_member_fkey" FOREIGN KEY ("ws_id", "lead_id") REFERENCES "public"."workspace_members"("ws_id", "user_id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_projects"
ADD
  CONSTRAINT "task_projects_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_relationships"
ADD
  CONSTRAINT "task_relationships_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_relationships"
ADD
  CONSTRAINT "task_relationships_source_task_id_fkey" FOREIGN KEY ("source_task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_relationships"
ADD
  CONSTRAINT "task_relationships_target_task_id_fkey" FOREIGN KEY ("target_task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_reminder_sent"
ADD
  CONSTRAINT "task_reminder_sent_notification_id_fkey" FOREIGN KEY ("notification_id") REFERENCES "public"."notifications"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."task_reminder_sent"
ADD
  CONSTRAINT "task_reminder_sent_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_reminder_sent"
ADD
  CONSTRAINT "task_reminder_sent_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_user_scheduling_settings"
ADD
  CONSTRAINT "task_user_scheduling_settings_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_user_scheduling_settings"
ADD
  CONSTRAINT "task_user_scheduling_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_watchers"
ADD
  CONSTRAINT "task_watchers_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."task_watchers"
ADD
  CONSTRAINT "task_watchers_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."tasks"
ADD
  CONSTRAINT "tasks_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."tasks"
ADD
  CONSTRAINT "tasks_list_id_fkey" FOREIGN KEY ("list_id") REFERENCES "public"."task_lists"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_breaks"
ADD
  CONSTRAINT "time_tracking_breaks_break_type_id_fkey" FOREIGN KEY ("break_type_id") REFERENCES "public"."workspace_break_types"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_breaks"
ADD
  CONSTRAINT "time_tracking_breaks_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_breaks"
ADD
  CONSTRAINT "time_tracking_breaks_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."time_tracking_sessions"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_categories"
ADD
  CONSTRAINT "time_tracking_categories_color_fkey" FOREIGN KEY ("color") REFERENCES "public"."calendar_event_colors"("value") ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."time_tracking_categories"
ADD
  CONSTRAINT "time_tracking_categories_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_goals"
ADD
  CONSTRAINT "time_tracking_goals_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."time_tracking_categories"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_goals"
ADD
  CONSTRAINT "time_tracking_goals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_goals"
ADD
  CONSTRAINT "time_tracking_goals_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_break_type_id_fkey" FOREIGN KEY ("break_type_id") REFERENCES "public"."workspace_break_types"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."time_tracking_categories"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_linked_session_id_fkey" FOREIGN KEY ("linked_session_id") REFERENCES "public"."time_tracking_sessions"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_rejected_by_fkey" FOREIGN KEY ("rejected_by") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_requests"
ADD
  CONSTRAINT "time_tracking_requests_workspace_id_fkey" FOREIGN KEY ("workspace_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."time_tracking_categories"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_parent_session_id_fkey" FOREIGN KEY ("parent_session_id") REFERENCES "public"."time_tracking_sessions"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."time_tracking_sessions"
ADD
  CONSTRAINT "time_tracking_sessions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."transaction_categories"
ADD
  CONSTRAINT "transaction_categories_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."transaction_tags"
ADD
  CONSTRAINT "transaction_tags_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_feedbacks"
ADD
  CONSTRAINT "user_feedbacks_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_feedbacks"
ADD
  CONSTRAINT "user_feedbacks_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_feedbacks"
ADD
  CONSTRAINT "user_feedbacks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_attendance"
ADD
  CONSTRAINT "user_group_attendance_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_attendance"
ADD
  CONSTRAINT "user_group_attendance_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_linked_products"
ADD
  CONSTRAINT "user_group_linked_products_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_linked_products"
ADD
  CONSTRAINT "user_group_linked_products_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_products"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_linked_products"
ADD
  CONSTRAINT "user_group_linked_products_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."inventory_units"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_linked_products"
ADD
  CONSTRAINT "user_group_linked_products_warehouse_id_fkey" FOREIGN KEY ("warehouse_id") REFERENCES "public"."inventory_warehouses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_post_checks"
ADD
  CONSTRAINT "user_group_post_checks_email_id_fkey" FOREIGN KEY ("email_id") REFERENCES "public"."sent_emails"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."user_group_post_checks"
ADD
  CONSTRAINT "user_group_post_checks_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "public"."user_group_posts"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_post_checks"
ADD
  CONSTRAINT "user_group_post_checks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_group_posts"
ADD
  CONSTRAINT "user_group_posts_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_indicators"
ADD
  CONSTRAINT "user_indicators_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."user_indicators"
ADD
  CONSTRAINT "user_indicators_indicator_id_fkey" FOREIGN KEY ("indicator_id") REFERENCES "public"."healthcare_vitals"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_indicators"
ADD
  CONSTRAINT "user_indicators_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_linked_promotions"
ADD
  CONSTRAINT "user_linked_promotions_promo_id_fkey" FOREIGN KEY ("promo_id") REFERENCES "public"."workspace_promotions"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_linked_promotions"
ADD
  CONSTRAINT "user_linked_promotions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."user_private_details"
ADD
  CONSTRAINT "user_private_details_default_workspace_id_fkey" FOREIGN KEY ("default_workspace_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."user_private_details"
ADD
  CONSTRAINT "user_private_details_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."users"
ADD
  CONSTRAINT "users_handle_fkey" FOREIGN KEY ("handle") REFERENCES "public"."handles"("value") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."poll_user_votes"
ADD
  CONSTRAINT "users_poll_votes_option_id_fkey" FOREIGN KEY ("option_id") REFERENCES "public"."poll_options"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."poll_user_votes"
ADD
  CONSTRAINT "users_poll_votes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."vital_group_vitals"
ADD
  CONSTRAINT "vital_group_vitals_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."healthcare_vital_groups"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."vital_group_vitals"
ADD
  CONSTRAINT "vital_group_vitals_vital_id_fkey" FOREIGN KEY ("vital_id") REFERENCES "public"."healthcare_vitals"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."wallet_transaction_tags"
ADD
  CONSTRAINT "wallet_transaction_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."transaction_tags"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."wallet_transaction_tags"
ADD
  CONSTRAINT "wallet_transaction_tags_transaction_id_fkey" FOREIGN KEY ("transaction_id") REFERENCES "public"."wallet_transactions"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."transaction_categories"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_invoice_id_fkey" FOREIGN KEY ("invoice_id") REFERENCES "public"."finance_invoices"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."wallet_transactions"
ADD
  CONSTRAINT "wallet_transactions_wallet_id_fkey" FOREIGN KEY ("wallet_id") REFERENCES "public"."workspace_wallets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_ai_executions"
ADD
  CONSTRAINT "workspace_ai_executions_api_key_fkey" FOREIGN KEY ("api_key_id") REFERENCES "public"."workspace_api_keys"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_ai_executions"
ADD
  CONSTRAINT "workspace_ai_executions_model_id_fkey" FOREIGN KEY ("model_id") REFERENCES "public"."ai_models"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_ai_executions"
ADD
  CONSTRAINT "workspace_ai_executions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_ai_models"
ADD
  CONSTRAINT "workspace_ai_models_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_api_key_usage_logs"
ADD
  CONSTRAINT "workspace_api_key_usage_logs_api_key_id_fkey" FOREIGN KEY ("api_key_id") REFERENCES "public"."workspace_api_keys"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_api_key_usage_logs"
ADD
  CONSTRAINT "workspace_api_key_usage_logs_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_api_keys"
ADD
  CONSTRAINT "workspace_api_keys_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_api_keys"
ADD
  CONSTRAINT "workspace_api_keys_role_id_fkey" FOREIGN KEY ("role_id") REFERENCES "public"."workspace_roles"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_api_keys"
ADD
  CONSTRAINT "workspace_api_keys_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_boards"
ADD
  CONSTRAINT "workspace_boards_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."task_board_status_templates"("id");

ALTER TABLE
  ONLY "public"."workspace_boards"
ADD
  CONSTRAINT "workspace_boards_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_break_types"
ADD
  CONSTRAINT "workspace_break_types_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendar_categories"
ADD
  CONSTRAINT "workspace_calendar_categories_color_fkey" FOREIGN KEY ("color") REFERENCES "public"."calendar_event_colors"("value") ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_calendar_categories"
ADD
  CONSTRAINT "workspace_calendar_categories_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendar_events"
ADD
  CONSTRAINT "workspace_calendar_events_color_fkey" FOREIGN KEY ("color") REFERENCES "public"."calendar_event_colors"("value") ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_calendar_events"
ADD
  CONSTRAINT "workspace_calendar_events_source_calendar_id_fkey" FOREIGN KEY ("source_calendar_id") REFERENCES "public"."workspace_calendars"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_calendar_events"
ADD
  CONSTRAINT "workspace_calendar_events_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendar_hour_settings"
ADD
  CONSTRAINT "workspace_calendar_hour_settings_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendar_sync_coordination"
ADD
  CONSTRAINT "workspace_calendar_sync_coordination_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendar_sync_log"
ADD
  CONSTRAINT "workspace_calendar_sync_log_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_calendars"
ADD
  CONSTRAINT "workspace_calendars_color_fkey" FOREIGN KEY ("color") REFERENCES "public"."calendar_event_colors"("value");

ALTER TABLE
  ONLY "public"."workspace_calendars"
ADD
  CONSTRAINT "workspace_calendars_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_channels"
ADD
  CONSTRAINT "workspace_chat_channels_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_chat_channels"
ADD
  CONSTRAINT "workspace_chat_channels_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_messages"
ADD
  CONSTRAINT "workspace_chat_messages_channel_id_fkey" FOREIGN KEY ("channel_id") REFERENCES "public"."workspace_chat_channels"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_messages"
ADD
  CONSTRAINT "workspace_chat_messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_participants"
ADD
  CONSTRAINT "workspace_chat_participants_channel_id_fkey" FOREIGN KEY ("channel_id") REFERENCES "public"."workspace_chat_channels"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_participants"
ADD
  CONSTRAINT "workspace_chat_participants_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_typing_indicators"
ADD
  CONSTRAINT "workspace_chat_typing_indicators_channel_id_fkey" FOREIGN KEY ("channel_id") REFERENCES "public"."workspace_chat_channels"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_chat_typing_indicators"
ADD
  CONSTRAINT "workspace_chat_typing_indicators_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_course_modules"
ADD
  CONSTRAINT "workspace_course_modules_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."workspace_courses"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_courses"
ADD
  CONSTRAINT "workspace_courses_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_cron_executions"
ADD
  CONSTRAINT "workspace_cron_executions_job_id_fkey" FOREIGN KEY ("job_id") REFERENCES "public"."workspace_cron_jobs"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_cron_jobs"
ADD
  CONSTRAINT "workspace_cron_jobs_dataset_id_fkey" FOREIGN KEY ("dataset_id") REFERENCES "public"."workspace_datasets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_cron_jobs"
ADD
  CONSTRAINT "workspace_cron_jobs_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_dataset_cells"
ADD
  CONSTRAINT "workspace_dataset_cell_column_id_fkey" FOREIGN KEY ("column_id") REFERENCES "public"."workspace_dataset_columns"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_dataset_cells"
ADD
  CONSTRAINT "workspace_dataset_cell_dataset_id_fkey" FOREIGN KEY ("dataset_id") REFERENCES "public"."workspace_datasets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_dataset_cells"
ADD
  CONSTRAINT "workspace_dataset_cell_row_id_fkey" FOREIGN KEY ("row_id") REFERENCES "public"."workspace_dataset_rows"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_dataset_columns"
ADD
  CONSTRAINT "workspace_dataset_columns_dataset_id_fkey" FOREIGN KEY ("dataset_id") REFERENCES "public"."workspace_datasets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_dataset_rows"
ADD
  CONSTRAINT "workspace_dataset_rows_dataset_id_fkey" FOREIGN KEY ("dataset_id") REFERENCES "public"."workspace_datasets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_datasets"
ADD
  CONSTRAINT "workspace_datasets_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_documents"
ADD
  CONSTRAINT "workspace_documents_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id");

ALTER TABLE
  ONLY "public"."workspace_education_access_requests"
ADD
  CONSTRAINT "workspace_education_access_requests_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_education_access_requests"
ADD
  CONSTRAINT "workspace_education_access_requests_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_education_access_requests"
ADD
  CONSTRAINT "workspace_education_access_requests_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_email_credentials"
ADD
  CONSTRAINT "workspace_email_credentials_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_email_invites"
ADD
  CONSTRAINT "workspace_email_invites_invited_by_fkey" FOREIGN KEY ("invited_by") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_email_invites"
ADD
  CONSTRAINT "workspace_email_invites_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_encryption_keys"
ADD
  CONSTRAINT "workspace_encryption_keys_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_flashcards"
ADD
  CONSTRAINT "workspace_flashcards_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_habits"
ADD
  CONSTRAINT "workspace_habits_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_habits"
ADD
  CONSTRAINT "workspace_habits_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invite_link_uses"
ADD
  CONSTRAINT "workspace_invite_link_uses_invite_link_id_fkey" FOREIGN KEY ("invite_link_id") REFERENCES "public"."workspace_invite_links"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invite_link_uses"
ADD
  CONSTRAINT "workspace_invite_link_uses_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invite_link_uses"
ADD
  CONSTRAINT "workspace_invite_link_uses_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invite_links"
ADD
  CONSTRAINT "workspace_invite_links_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invite_links"
ADD
  CONSTRAINT "workspace_invite_links_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invites"
ADD
  CONSTRAINT "workspace_invites_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_invites"
ADD
  CONSTRAINT "workspace_invites_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_meetings"
ADD
  CONSTRAINT "workspace_meetings_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_meetings"
ADD
  CONSTRAINT "workspace_meetings_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_members"
ADD
  CONSTRAINT "workspace_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");

ALTER TABLE
  ONLY "public"."workspace_members"
ADD
  CONSTRAINT "workspace_members_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_polar_subscription_id_fkey" FOREIGN KEY ("polar_subscription_id") REFERENCES "public"."workspace_subscriptions"("polar_subscription_id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_subscription_products"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_orders"
ADD
  CONSTRAINT "workspace_orders_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_products"
ADD
  CONSTRAINT "workspace_products_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."product_categories"("id") ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_products"
ADD
  CONSTRAINT "workspace_products_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_promotions"
ADD
  CONSTRAINT "workspace_promotions_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_sets"
ADD
  CONSTRAINT "workspace_quiz_sets_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quizzes"
ADD
  CONSTRAINT "workspace_quizzes_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_scheduling_metadata"
ADD
  CONSTRAINT "workspace_scheduling_metadata_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_secrets"
ADD
  CONSTRAINT "workspace_secrets_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_settings"
ADD
  CONSTRAINT "workspace_settings_referral_promo_fkey" FOREIGN KEY ("ws_id", "referral_promotion_id") REFERENCES "public"."workspace_promotions"("ws_id", "id") ON DELETE
SET
  NULL;

ALTER TABLE
  ONLY "public"."workspace_settings"
ADD
  CONSTRAINT "workspace_settings_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_subscriptions"
ADD
  CONSTRAINT "workspace_subscription_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."workspace_subscription_products"("id");

ALTER TABLE
  ONLY "public"."workspace_subscriptions"
ADD
  CONSTRAINT "workspace_subscription_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_task_labels"
ADD
  CONSTRAINT "workspace_task_labels_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_task_labels"
ADD
  CONSTRAINT "workspace_task_labels_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_task_reminder_settings"
ADD
  CONSTRAINT "workspace_task_reminder_settings_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_teams"
ADD
  CONSTRAINT "workspace_teams_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_linked_users"
ADD
  CONSTRAINT "workspace_user_linked_users_platform_user_id_fkey" FOREIGN KEY ("platform_user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_linked_users"
ADD
  CONSTRAINT "workspace_user_linked_users_virtual_user_id_fkey" FOREIGN KEY ("virtual_user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_linked_users"
ADD
  CONSTRAINT "workspace_user_linked_users_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_groups_users"
ADD
  CONSTRAINT "workspace_user_roles_users_role_id_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."workspace_user_groups"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_groups_users"
ADD
  CONSTRAINT "workspace_user_roles_users_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_groups"
ADD
  CONSTRAINT "workspace_user_roles_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_status_changes"
ADD
  CONSTRAINT "workspace_user_status_changes_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_user_status_changes"
ADD
  CONSTRAINT "workspace_user_status_changes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_user_status_changes"
ADD
  CONSTRAINT "workspace_user_status_changes_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_users"
ADD
  CONSTRAINT "workspace_users_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."workspace_users"("id") ON UPDATE CASCADE ON DELETE
SET
  DEFAULT;

ALTER TABLE
  ONLY "public"."workspace_users"
ADD
  CONSTRAINT "workspace_users_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_wallet_transfers"
ADD
  CONSTRAINT "workspace_wallet_transfers_from_transaction_id_fkey" FOREIGN KEY ("from_transaction_id") REFERENCES "public"."wallet_transactions"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_wallet_transfers"
ADD
  CONSTRAINT "workspace_wallet_transfers_to_transaction_id_fkey" FOREIGN KEY ("to_transaction_id") REFERENCES "public"."wallet_transactions"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_wallets"
ADD
  CONSTRAINT "workspace_wallets_currency_fkey" FOREIGN KEY ("currency") REFERENCES "public"."currencies"("code");

ALTER TABLE
  ONLY "public"."workspace_wallets"
ADD
  CONSTRAINT "workspace_wallets_type_fkey" FOREIGN KEY ("type") REFERENCES "public"."wallet_types"("id");

ALTER TABLE
  ONLY "public"."workspace_wallets"
ADD
  CONSTRAINT "workspace_wallets_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_whiteboards"
ADD
  CONSTRAINT "workspace_whiteboards_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_whiteboards"
ADD
  CONSTRAINT "workspace_whiteboards_ws_id_fkey" FOREIGN KEY ("ws_id") REFERENCES "public"."workspaces"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspaces"
ADD
  CONSTRAINT "workspaces_creator_id_fkey" FOREIGN KEY ("creator_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_attempt_answers"
ADD
  CONSTRAINT "wq_answer_attempt_fkey" FOREIGN KEY ("attempt_id") REFERENCES "public"."workspace_quiz_attempts"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_attempt_answers"
ADD
  CONSTRAINT "wq_answer_option_fkey" FOREIGN KEY ("selected_option_id") REFERENCES "public"."quiz_options"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_attempt_answers"
ADD
  CONSTRAINT "wq_answer_quiz_fkey" FOREIGN KEY ("quiz_id") REFERENCES "public"."workspace_quizzes"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_attempts"
ADD
  CONSTRAINT "wq_attempts_set_fkey" FOREIGN KEY ("set_id") REFERENCES "public"."workspace_quiz_sets"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  ONLY "public"."workspace_quiz_attempts"
ADD
  CONSTRAINT "wq_attempts_user_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE
  "audit"."record_version" ENABLE ROW LEVEL SECURITY;

CREATE POLICY " Allow all access for workspace member" ON "public"."course_module_quizzes" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quizzes" "wq"
        WHERE
          ("wq"."id" = "course_module_quizzes"."quiz_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          ("wcm"."id" = "course_module_quizzes"."module_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quizzes" "wq"
        WHERE
          ("wq"."id" = "course_module_quizzes"."quiz_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          ("wcm"."id" = "course_module_quizzes"."module_id")
      )
    )
  )
);

CREATE POLICY " Enable all access for challenge manager" ON "public"."nova_challenge_criteria" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY " Enable all access for challenge manager" ON "public"."nova_problem_test_cases" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY " Enable all access for challenge manager" ON "public"."nova_problems" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY " Enable all access for challenge manager" ON "public"."nova_submission_criteria" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY " Enable all access for challenge manager" ON "public"."nova_submission_test_cases" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Admin users can manage platform email roles" ON "public"."platform_email_roles" TO "authenticated" USING ("public"."is_nova_role_manager"());

CREATE POLICY "Admin users can manage platform user roles" ON "public"."platform_user_roles" TO "authenticated" USING ("public"."is_nova_role_manager"());

CREATE POLICY "Allow ALL operations for workspace members" ON "public"."workspace_settings" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow Tuturuuu emails to have full access on inquiries" ON "public"."support_inquiries" TO "authenticated" USING (
  (
    "substring"(("auth"."uid"()) :: "text", '@(.*)$' :: "text") = '@tuturuuu.com' :: "text"
  )
) WITH CHECK (
  (
    "substring"(("auth"."uid"()) :: "text", '@(.*)$' :: "text") = '@tuturuuu.com' :: "text"
  )
);

CREATE POLICY "Allow access for workspace users" ON "public"."calendar_event_virtual_participants" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_calendar_events" "e"
        WHERE
          (
            "e"."id" = "calendar_event_virtual_participants"."event_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          (
            "u"."id" = "calendar_event_virtual_participants"."user_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_calendar_events" "e"
        WHERE
          (
            "e"."id" = "calendar_event_virtual_participants"."event_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          (
            "u"."id" = "calendar_event_virtual_participants"."user_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow access for workspace users" ON "public"."user_feedbacks" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_feedbacks"."user_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          ("g"."id" = "user_feedbacks"."group_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_feedbacks"."user_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          ("g"."id" = "user_feedbacks"."group_id")
      )
    )
  )
);

CREATE POLICY "Allow access for workspace users" ON "public"."user_group_attendance" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_group_attendance"."user_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          ("g"."id" = "user_group_attendance"."group_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_group_attendance"."user_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          ("g"."id" = "user_group_attendance"."group_id")
      )
    )
  )
);

CREATE POLICY "Allow access for workspace users" ON "public"."user_group_linked_products" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          (
            "g"."id" = "user_group_linked_products"."group_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          (
            "p"."id" = "user_group_linked_products"."product_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          (
            "u"."id" = "user_group_linked_products"."unit_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_groups" "g"
        WHERE
          (
            "g"."id" = "user_group_linked_products"."group_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          (
            "p"."id" = "user_group_linked_products"."product_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          (
            "u"."id" = "user_group_linked_products"."unit_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow access for workspace users" ON "public"."user_group_posts" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_groups" "g"
      WHERE
        ("g"."id" = "user_group_posts"."group_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_groups" "g"
      WHERE
        ("g"."id" = "user_group_posts"."group_id")
    )
  )
);

CREATE POLICY "Allow all access for nova admins" ON "public"."nova_team_emails" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Allow all access for nova admins" ON "public"."nova_team_members" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Allow all access for nova admins" ON "public"."nova_teams" TO "authenticated" USING (
  (
    "public"."is_nova_challenge_manager"()
    OR "public"."is_nova_user_id_in_team"("auth"."uid"(), "id")
    OR "public"."is_nova_user_email_in_team"("auth"."email"(), "id")
  )
) WITH CHECK (
  (
    "public"."is_nova_challenge_manager"()
    OR "public"."is_nova_user_id_in_team"("auth"."uid"(), "id")
    OR "public"."is_nova_user_email_in_team"("auth"."email"(), "id")
  )
);

CREATE POLICY "Allow all access for workspace member" ON "public"."course_module_flashcards" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_flashcards" "wf"
        WHERE
          (
            "wf"."id" = "course_module_flashcards"."flashcard_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          (
            "wcm"."id" = "course_module_flashcards"."module_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_flashcards" "wf"
        WHERE
          (
            "wf"."id" = "course_module_flashcards"."flashcard_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          (
            "wcm"."id" = "course_module_flashcards"."module_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow all access for workspace member" ON "public"."course_module_quiz_sets" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quiz_sets" "wqs"
        WHERE
          ("wqs"."id" = "course_module_quiz_sets"."set_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          (
            "wcm"."id" = "course_module_quiz_sets"."module_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quiz_sets" "wqs"
        WHERE
          ("wqs"."id" = "course_module_quiz_sets"."set_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_course_modules" "wcm"
        WHERE
          (
            "wcm"."id" = "course_module_quiz_sets"."module_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow all access for workspace member" ON "public"."quiz_options" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_quizzes" "wq"
      WHERE
        ("wq"."id" = "quiz_options"."quiz_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_quizzes" "wq"
      WHERE
        ("wq"."id" = "quiz_options"."quiz_id")
    )
  )
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_course_modules" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_courses" "wc"
      WHERE
        (
          "wc"."id" = "workspace_course_modules"."course_id"
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_courses" "wc"
      WHERE
        (
          "wc"."id" = "workspace_course_modules"."course_id"
        )
    )
  )
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_courses" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_documents" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_flashcards" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_quiz_sets" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace member" ON "public"."workspace_quizzes" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace members" ON "public"."workspace_user_fields" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow all access for workspace users" ON "public"."workspace_ai_prompts" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "ws"
      WHERE
        ("ws"."id" = "workspace_ai_prompts"."ws_id")
    )
  )
);

CREATE POLICY "Allow all for poll creator" ON "public"."poll_guest_permissions" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."polls" "p"
      WHERE
        (
          ("p"."id" = "poll_guest_permissions"."poll_id")
          AND ("p"."creator_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."polls" "p"
      WHERE
        (
          ("p"."id" = "poll_guest_permissions"."poll_id")
          AND ("p"."creator_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow all for poll creator" ON "public"."poll_user_permissions" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."polls" "p"
      WHERE
        (
          ("p"."id" = "poll_user_permissions"."poll_id")
          AND ("p"."creator_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."polls" "p"
      WHERE
        (
          ("p"."id" = "poll_user_permissions"."poll_id")
          AND ("p"."creator_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow all for workspace members" ON "public"."aurora_ml_forecast" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_ml_forecast"."ws_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_ml_forecast"."ws_id")
    )
  )
);

CREATE POLICY "Allow all for workspace members" ON "public"."aurora_ml_metrics" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_ml_metrics"."ws_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_ml_metrics"."ws_id")
    )
  )
);

CREATE POLICY "Allow all for workspace members" ON "public"."aurora_statistical_forecast" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_statistical_forecast"."ws_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_statistical_forecast"."ws_id")
    )
  )
);

CREATE POLICY "Allow all for workspace members" ON "public"."aurora_statistical_metrics" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_statistical_metrics"."ws_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w"
      WHERE
        ("w"."id" = "aurora_statistical_metrics"."ws_id")
    )
  )
);

CREATE POLICY "Allow all for workspace users" ON "public"."product_stock_changes" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          ("p"."id" = "product_stock_changes"."product_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "product_stock_changes"."unit_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_warehouses" "w"
        WHERE
          (
            "w"."id" = "product_stock_changes"."warehouse_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          ("p"."id" = "product_stock_changes"."product_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "product_stock_changes"."unit_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_warehouses" "w"
        WHERE
          (
            "w"."id" = "product_stock_changes"."warehouse_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow all if the user is the creator and workspace member" ON "public"."meet_together_plans" TO "authenticated" USING (
  (
    ("creator_id" = "auth"."uid"())
    AND (
      ("ws_id" IS NULL)
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  )
) WITH CHECK (
  (
    ("creator_id" = "auth"."uid"())
    AND (
      ("ws_id" IS NULL)
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  )
);

CREATE POLICY "Allow all if the user is the creator and workspace member" ON "public"."polls" TO "authenticated" USING (
  (
    ("creator_id" = "auth"."uid"())
    AND (
      ("ws_id" IS NULL)
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  )
) WITH CHECK (
  (
    ("creator_id" = "auth"."uid"())
    AND (
      ("ws_id" IS NULL)
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  )
);

CREATE POLICY "Allow authenticated users to record invite link usage" ON "public"."workspace_invite_link_uses" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      ("auth"."uid"() = "user_id")
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_invite_links" "wil"
          WHERE
            (
              (
                "wil"."id" = "workspace_invite_link_uses"."invite_link_id"
              )
              AND (
                "wil"."ws_id" = "workspace_invite_link_uses"."ws_id"
              )
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_members" "wm"
          WHERE
            (
              (
                "wm"."ws_id" = "workspace_invite_link_uses"."ws_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Allow authenticated users to view analytics for workspace links" ON "public"."link_analytics" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."shortened_links" "sl"
            JOIN "public"."workspace_members" "wm" ON (("sl"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            ("sl"."id" = "link_analytics"."link_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow authorized members to create API keys" ON "public"."workspace_api_keys" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        (
          EXISTS (
            SELECT
              1
            FROM
              (
                (
                  "public"."workspace_role_members" "wrm"
                  JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
                )
                JOIN "public"."workspace_role_permissions" "wrp" ON (
                  (
                    ("wrp"."role_id" = "wrm"."role_id")
                    AND ("wrp"."ws_id" = "workspace_api_keys"."ws_id")
                  )
                )
              )
            WHERE
              (
                ("wrm"."user_id" = "auth"."uid"())
                AND ("wr"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wrp"."enabled" = true)
              )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_default_permissions" "wdp"
            WHERE
              (
                ("wdp"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wdp"."enabled" = true)
                AND (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      "public"."workspace_members" "wm"
                    WHERE
                      (
                        ("wm"."ws_id" = "workspace_api_keys"."ws_id")
                        AND ("wm"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow authorized members to delete API keys" ON "public"."workspace_api_keys" FOR DELETE TO "authenticated" USING (
  (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
    AND (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."workspace_role_members" "wrm"
                JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
              )
              JOIN "public"."workspace_role_permissions" "wrp" ON (
                (
                  ("wrp"."role_id" = "wrm"."role_id")
                  AND ("wrp"."ws_id" = "workspace_api_keys"."ws_id")
                )
              )
            )
          WHERE
            (
              ("wrm"."user_id" = "auth"."uid"())
              AND ("wr"."ws_id" = "workspace_api_keys"."ws_id")
              AND (
                "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
              )
              AND ("wrp"."enabled" = true)
            )
        )
      )
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_default_permissions" "wdp"
          WHERE
            (
              ("wdp"."ws_id" = "workspace_api_keys"."ws_id")
              AND (
                "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
              )
              AND ("wdp"."enabled" = true)
              AND (
                EXISTS (
                  SELECT
                    1
                  FROM
                    "public"."workspace_members" "wm"
                  WHERE
                    (
                      ("wm"."ws_id" = "workspace_api_keys"."ws_id")
                      AND ("wm"."user_id" = "auth"."uid"())
                    )
                )
              )
            )
        )
      )
    )
  )
);

CREATE POLICY "Allow authorized members to update API keys" ON "public"."workspace_api_keys" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        (
          EXISTS (
            SELECT
              1
            FROM
              (
                (
                  "public"."workspace_role_members" "wrm"
                  JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
                )
                JOIN "public"."workspace_role_permissions" "wrp" ON (
                  (
                    ("wrp"."role_id" = "wrm"."role_id")
                    AND ("wrp"."ws_id" = "workspace_api_keys"."ws_id")
                  )
                )
              )
            WHERE
              (
                ("wrm"."user_id" = "auth"."uid"())
                AND ("wr"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wrp"."enabled" = true)
              )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_default_permissions" "wdp"
            WHERE
              (
                ("wdp"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wdp"."enabled" = true)
                AND (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      "public"."workspace_members" "wm"
                    WHERE
                      (
                        ("wm"."ws_id" = "workspace_api_keys"."ws_id")
                        AND ("wm"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
          )
        )
      )
    )
  ) WITH CHECK (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        (
          EXISTS (
            SELECT
              1
            FROM
              (
                (
                  "public"."workspace_role_members" "wrm"
                  JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
                )
                JOIN "public"."workspace_role_permissions" "wrp" ON (
                  (
                    ("wrp"."role_id" = "wrm"."role_id")
                    AND ("wrp"."ws_id" = "workspace_api_keys"."ws_id")
                  )
                )
              )
            WHERE
              (
                ("wrm"."user_id" = "auth"."uid"())
                AND ("wr"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wrp"."enabled" = true)
              )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_default_permissions" "wdp"
            WHERE
              (
                ("wdp"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wdp"."enabled" = true)
                AND (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      "public"."workspace_members" "wm"
                    WHERE
                      (
                        ("wm"."ws_id" = "workspace_api_keys"."ws_id")
                        AND ("wm"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow authorized members to view API keys" ON "public"."workspace_api_keys" FOR
SELECT
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        (
          EXISTS (
            SELECT
              1
            FROM
              (
                (
                  "public"."workspace_role_members" "wrm"
                  JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
                )
                JOIN "public"."workspace_role_permissions" "wrp" ON (
                  (
                    ("wrp"."role_id" = "wrm"."role_id")
                    AND ("wrp"."ws_id" = "workspace_api_keys"."ws_id")
                  )
                )
              )
            WHERE
              (
                ("wrm"."user_id" = "auth"."uid"())
                AND ("wr"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wrp"."enabled" = true)
              )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_default_permissions" "wdp"
            WHERE
              (
                ("wdp"."ws_id" = "workspace_api_keys"."ws_id")
                AND (
                  "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wdp"."enabled" = true)
                AND (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      "public"."workspace_members" "wm"
                    WHERE
                      (
                        ("wm"."ws_id" = "workspace_api_keys"."ws_id")
                        AND ("wm"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow authorized members to view usage logs" ON "public"."workspace_api_key_usage_logs" FOR
SELECT
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        (
          EXISTS (
            SELECT
              1
            FROM
              (
                (
                  "public"."workspace_role_members" "wrm"
                  JOIN "public"."workspace_roles" "wr" ON (("wr"."id" = "wrm"."role_id"))
                )
                JOIN "public"."workspace_role_permissions" "wrp" ON (
                  (
                    ("wrp"."role_id" = "wrm"."role_id")
                    AND (
                      "wrp"."ws_id" = "workspace_api_key_usage_logs"."ws_id"
                    )
                  )
                )
              )
            WHERE
              (
                ("wrm"."user_id" = "auth"."uid"())
                AND (
                  "wr"."ws_id" = "workspace_api_key_usage_logs"."ws_id"
                )
                AND (
                  "wrp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wrp"."enabled" = true)
              )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_default_permissions" "wdp"
            WHERE
              (
                (
                  "wdp"."ws_id" = "workspace_api_key_usage_logs"."ws_id"
                )
                AND (
                  "wdp"."permission" = 'manage_api_keys' :: "public"."workspace_role_permission"
                )
                AND ("wdp"."enabled" = true)
                AND (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      "public"."workspace_members" "wm"
                    WHERE
                      (
                        (
                          "wm"."ws_id" = "workspace_api_key_usage_logs"."ws_id"
                        )
                        AND ("wm"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow chat owners to have full permissions" ON "public"."ai_chat_members" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."ai_chats" "ac"
      WHERE
        (
          ("ac"."id" = "ai_chat_members"."chat_id")
          AND ("ac"."creator_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."ai_chats" "ac"
      WHERE
        (
          ("ac"."id" = "ai_chat_members"."chat_id")
          AND ("ac"."creator_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow delete access for workspace members" ON "public"."workspace_wallet_transfers" FOR DELETE TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."wallet_transactions" "t"
        WHERE
          (
            "workspace_wallet_transfers"."from_transaction_id" = "t"."id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."wallet_transactions" "t"
        WHERE
          (
            "workspace_wallet_transfers"."to_transaction_id" = "t"."id"
          )
      )
    )
  )
);

CREATE POLICY "Allow delete for workspace members" ON "public"."calendar_connections" FOR DELETE TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow delete for workspace users and the participant" ON "public"."calendar_auth_tokens" FOR DELETE USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Allow delete for workspace users and the participant" ON "public"."calendar_event_platform_participants" FOR DELETE TO "authenticated" USING (
  (
    ("user_id" = "auth"."uid"())
    OR (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_calendar_events" "e",
          "public"."workspace_members" "m"
        WHERE
          (
            (
              "e"."id" = "calendar_event_platform_participants"."event_id"
            )
            AND (
              "m"."user_id" = "calendar_event_platform_participants"."user_id"
            )
            AND ("m"."ws_id" = "e"."ws_id")
          )
      )
    )
  )
);

CREATE POLICY "Allow delete if user is the chat creator" ON "public"."ai_chats" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "creator_id"));

CREATE POLICY "Allow full CRUD for workspace members via indicator" ON "public"."user_indicators" TO "authenticated" USING ("public"."can_manage_indicator"("indicator_id")) WITH CHECK ("public"."can_manage_indicator"("indicator_id"));

CREATE POLICY "Allow insert access for workspace users" ON "public"."external_user_monthly_reports" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              "wu"."id" = "external_user_monthly_reports"."user_id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_user_groups" "wug"
          WHERE
            (
              "wug"."id" = "external_user_monthly_reports"."group_id"
            )
        )
      )
    )
  );

CREATE POLICY "Allow insert access if both transaction have the same amount" ON "public"."workspace_wallet_transfers" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."transactions_have_same_abs_amount"("from_transaction_id", "to_transaction_id")
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."wallet_transactions" "t"
          WHERE
            (
              "t"."id" = "workspace_wallet_transfers"."from_transaction_id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."wallet_transactions" "t"
          WHERE
            (
              "t"."id" = "workspace_wallet_transfers"."to_transaction_id"
            )
        )
      )
    )
  );

CREATE POLICY "Allow insert for workspace members" ON "public"."calendar_connections" FOR
INSERT
  TO "authenticated" WITH CHECK (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow insert for workspace users" ON "public"."calendar_auth_tokens" FOR
INSERT
  TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "Allow insert for workspace users" ON "public"."calendar_event_platform_participants" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_calendar_events" "e",
          "public"."workspace_members" "m"
        WHERE
          (
            (
              "e"."id" = "calendar_event_platform_participants"."event_id"
            )
            AND (
              "m"."user_id" = "calendar_event_platform_participants"."user_id"
            )
            AND ("m"."ws_id" = "e"."ws_id")
          )
      )
    )
  );

CREATE POLICY "Allow insert for workspace users" ON "public"."workspace_user_linked_users" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        ("platform_user_id" = "auth"."uid"())
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_members" "wm"
            WHERE
              (
                (
                  "wm"."user_id" = "workspace_user_linked_users"."platform_user_id"
                )
                AND (
                  "wm"."ws_id" = "workspace_user_linked_users"."ws_id"
                )
              )
          )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              (
                "wu"."id" = "workspace_user_linked_users"."virtual_user_id"
              )
              AND (
                "wu"."ws_id" = "workspace_user_linked_users"."ws_id"
              )
            )
        )
      )
    )
  );

CREATE POLICY "Allow member managers to delete invites" ON "public"."workspace_invites" FOR DELETE TO "authenticated" USING (
  (
    ("auth"."uid"() = "user_id")
    OR (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  )
);

CREATE POLICY "Allow member managers to insert invites" ON "public"."workspace_invites" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (NOT "public"."is_org_member"("user_id", "ws_id"))
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_secrets" "wss"
            WHERE
              (
                ("wss"."ws_id" = "workspace_invites"."ws_id")
                AND ("wss"."name" = 'DISABLE_INVITE' :: "text")
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow member managers to manage report logs" ON "public"."external_user_monthly_report_logs" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wu"."ws_id"
      FROM
        "public"."workspace_users" "wu"
      WHERE
        (
          "wu"."id" = "external_user_monthly_report_logs"."user_id"
        )
    ),
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wu"."ws_id"
      FROM
        "public"."workspace_users" "wu"
      WHERE
        (
          "wu"."id" = "external_user_monthly_report_logs"."user_id"
        )
    ),
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
);

CREATE POLICY "Allow member managers to manage reports" ON "public"."external_user_monthly_reports" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wu"."ws_id"
      FROM
        "public"."workspace_users" "wu"
      WHERE
        (
          "wu"."id" = "external_user_monthly_reports"."user_id"
        )
    ),
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wu"."ws_id"
      FROM
        "public"."workspace_users" "wu"
      WHERE
        (
          "wu"."id" = "external_user_monthly_reports"."user_id"
        )
    ),
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
);

CREATE POLICY "Allow member managers to manage status changes" ON "public"."workspace_user_status_changes" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_members' :: "text"
  )
);

CREATE POLICY "Allow member managers to send email invites" ON "public"."workspace_email_invites" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."is_member_invited"("auth"."uid"(), "ws_id")
      OR (
        "public"."is_org_member"("auth"."uid"(), "ws_id")
        AND "public"."has_workspace_permission"(
          "ws_id",
          "auth"."uid"(),
          'manage_workspace_members' :: "text"
        )
      )
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_email_invites" "wei"
          WHERE
            (
              "lower"("wei"."email") = "lower"("auth"."email"())
            )
        )
      )
    )
  );

CREATE POLICY "Allow member managers to update email invites" ON "public"."workspace_email_invites" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  ) WITH CHECK (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  );

CREATE POLICY "Allow member managers to update invites" ON "public"."workspace_invites" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  ) WITH CHECK (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      AND "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  );

CREATE POLICY "Allow members to view invites" ON "public"."workspace_invites" FOR
SELECT
  TO "authenticated" USING (
    (
      ("auth"."uid"() = "user_id")
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  );

CREATE POLICY "Allow platform admins to insert products" ON "public"."workspace_subscription_products" FOR
INSERT
  TO "authenticated" WITH CHECK (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
  );

CREATE POLICY "Allow platform admins to manage requests" ON "public"."workspace_education_access_requests" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    '00000000-0000-0000-0000-000000000000' :: "uuid",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    '00000000-0000-0000-0000-000000000000' :: "uuid",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
);

CREATE POLICY "Allow platform admins to manage workspace secrets" ON "public"."workspace_secrets" TO "authenticated" USING (
  (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_workspace_secrets' :: "text"
    )
    AND "public"."is_org_member"(
      "auth"."uid"(),
      '00000000-0000-0000-0000-000000000000' :: "uuid"
    )
  )
) WITH CHECK (
  (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_workspace_secrets' :: "text"
    )
    AND "public"."is_org_member"(
      "auth"."uid"(),
      '00000000-0000-0000-0000-000000000000' :: "uuid"
    )
  )
);

CREATE POLICY "Allow platform admins to modify" ON "public"."timezones" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    '00000000-0000-0000-0000-000000000000' :: "uuid",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    '00000000-0000-0000-0000-000000000000' :: "uuid",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
);

CREATE POLICY "Allow platform admins to update products" ON "public"."workspace_subscription_products" FOR
UPDATE
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
  ) WITH CHECK (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
  );

CREATE POLICY "Allow read access for workspace members" ON "public"."workspace_wallet_transfers" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."wallet_transactions" "t"
          WHERE
            (
              "workspace_wallet_transfers"."from_transaction_id" = "t"."id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."wallet_transactions" "t"
          WHERE
            (
              "workspace_wallet_transfers"."to_transaction_id" = "t"."id"
            )
        )
      )
    )
  );

CREATE POLICY "Allow read access for workspace users" ON "public"."external_user_monthly_reports" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              "wu"."id" = "external_user_monthly_reports"."user_id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_user_groups" "wug"
          WHERE
            (
              "wug"."id" = "external_user_monthly_reports"."group_id"
            )
        )
      )
    )
  );

CREATE POLICY "Allow read access if user is the chat creator" ON "public"."ai_chats" FOR
SELECT
  TO "authenticated" USING (("auth"."uid"() = "creator_id"));

CREATE POLICY "Allow read for users that have access to the chat" ON "public"."ai_chat_messages" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."ai_chats" "ac"
        WHERE
          ("ac"."id" = "ai_chat_messages"."chat_id")
      )
    )
  );

CREATE POLICY "Allow role managers to manage default permissions" ON "public"."workspace_default_permissions" TO "authenticated" USING (
  (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
    OR (
      EXISTS (
        SELECT
          "wss"."id"
        FROM
          "public"."workspaces" "wss"
        WHERE
          (
            (
              "wss"."id" = "workspace_default_permissions"."ws_id"
            )
            AND ("wss"."creator_id" = "auth"."uid"())
          )
      )
    )
  )
) WITH CHECK (
  (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
    OR (
      EXISTS (
        SELECT
          "wss"."id"
        FROM
          "public"."workspaces" "wss"
        WHERE
          (
            (
              "wss"."id" = "workspace_default_permissions"."ws_id"
            )
            AND ("wss"."creator_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Allow role managers to manage permissions" ON "public"."workspace_role_permissions" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
);

CREATE POLICY "Allow role managers to manage role members" ON "public"."workspace_role_members" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wr"."ws_id"
      FROM
        "public"."workspace_roles" "wr"
      WHERE
        ("wr"."id" = "workspace_role_members"."role_id")
    ),
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    (
      SELECT
        "wr"."ws_id"
      FROM
        "public"."workspace_roles" "wr"
      WHERE
        ("wr"."id" = "workspace_role_members"."role_id")
    ),
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
);

CREATE POLICY "Allow role managers to manage roles" ON "public"."workspace_roles" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_roles' :: "text"
  )
);

CREATE POLICY "Allow role member to view" ON "public"."workspace_roles" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspaces" "wss"
        WHERE
          ("wss"."id" = "workspace_roles"."ws_id")
      )
    )
  );

CREATE POLICY "Allow role members to view" ON "public"."workspace_role_members" FOR
SELECT
  TO "authenticated" USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Allow root workspace users to manage blocked_ips" ON "public"."blocked_ips" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_linked_users"
      WHERE
        (
          (
            "workspace_user_linked_users"."platform_user_id" = "auth"."uid"()
          )
          AND (
            "workspace_user_linked_users"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
          )
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_linked_users"
      WHERE
        (
          (
            "workspace_user_linked_users"."platform_user_id" = "auth"."uid"()
          )
          AND (
            "workspace_user_linked_users"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
          )
        )
    )
  )
);

CREATE POLICY "Allow root workspace users to view abuse_events" ON "public"."abuse_events" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_user_linked_users"
        WHERE
          (
            (
              "workspace_user_linked_users"."platform_user_id" = "auth"."uid"()
            )
            AND (
              "workspace_user_linked_users"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
            )
          )
      )
    )
  );

CREATE POLICY "Allow select for workspace members" ON "public"."calendar_connections" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow select for workspace users" ON "public"."workspace_user_linked_users" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        ("platform_user_id" = "auth"."uid"())
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_members" "wm"
            WHERE
              (
                (
                  "wm"."user_id" = "workspace_user_linked_users"."platform_user_id"
                )
                AND (
                  "wm"."ws_id" = "workspace_user_linked_users"."ws_id"
                )
              )
          )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              (
                "wu"."id" = "workspace_user_linked_users"."virtual_user_id"
              )
              AND (
                "wu"."ws_id" = "workspace_user_linked_users"."ws_id"
              )
            )
        )
      )
    )
  );

CREATE POLICY "Allow select for workspace users and the participant" ON "public"."calendar_auth_tokens" FOR
SELECT
  TO "authenticated" USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Allow select for workspace users and the participant" ON "public"."calendar_event_participant_groups" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_calendar_events" "e",
        "public"."workspace_user_groups" "g"
      WHERE
        (
          (
            "e"."id" = "calendar_event_participant_groups"."event_id"
          )
          AND (
            "g"."id" = "calendar_event_participant_groups"."group_id"
          )
          AND ("g"."ws_id" = "e"."ws_id")
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_calendar_events" "e",
        "public"."workspace_user_groups" "g"
      WHERE
        (
          (
            "e"."id" = "calendar_event_participant_groups"."event_id"
          )
          AND (
            "g"."id" = "calendar_event_participant_groups"."group_id"
          )
          AND ("g"."ws_id" = "e"."ws_id")
        )
    )
  )
);

CREATE POLICY "Allow select for workspace users and the participant" ON "public"."calendar_event_platform_participants" FOR
SELECT
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_calendar_events" "e",
            "public"."workspace_members" "m"
          WHERE
            (
              (
                "e"."id" = "calendar_event_platform_participants"."event_id"
              )
              AND (
                "m"."user_id" = "calendar_event_platform_participants"."user_id"
              )
              AND ("m"."ws_id" = "e"."ws_id")
            )
        )
      )
    )
  );

CREATE POLICY "Allow service role to insert abuse_events" ON "public"."abuse_events" FOR
INSERT
  TO "service_role" WITH CHECK (true);

CREATE POLICY "Allow service role to manage blocked_ips" ON "public"."blocked_ips" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Allow settings managers to manage configs" ON "public"."workspace_configs" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
);

CREATE POLICY "Allow settings managers to manage reminder settings" ON "public"."workspace_task_reminder_settings" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
);

CREATE POLICY "Allow settings managers to manage tag groups" ON "public"."workspace_user_group_tag_groups" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_groups" "wug"
      WHERE
        (
          (
            "wug"."id" = "workspace_user_group_tag_groups"."group_id"
          )
          AND "public"."has_workspace_permission"(
            "wug"."ws_id",
            "auth"."uid"(),
            'manage_workspace_settings' :: "text"
          )
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_groups" "wug"
      WHERE
        (
          (
            "wug"."id" = "workspace_user_group_tag_groups"."group_id"
          )
          AND "public"."has_workspace_permission"(
            "wug"."ws_id",
            "auth"."uid"(),
            'manage_workspace_settings' :: "text"
          )
        )
    )
  )
);

CREATE POLICY "Allow settings managers to manage user group tags" ON "public"."workspace_user_group_tags" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_workspace_settings' :: "text"
  )
);

CREATE POLICY "Allow system to insert usage logs" ON "public"."workspace_api_key_usage_logs" FOR
INSERT
  TO "authenticated" WITH CHECK (false);

CREATE POLICY "Allow team members to insert" ON "public"."shortened_links" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "auth"."users"
        WHERE
          (
            ("users"."id" = "auth"."uid"())
            AND (
              ("users"."email") :: "text" ~~ '%@tuturuuu.com' :: "text"
            )
          )
      )
    )
  );

CREATE POLICY "Allow team members to select" ON "public"."shortened_links" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "auth"."users"
        WHERE
          (
            ("users"."id" = "auth"."uid"())
            AND (
              ("users"."email") :: "text" ~~ '%@tuturuuu.com' :: "text"
            )
          )
      )
    )
  );

CREATE POLICY "Allow team members to update team info" ON "public"."nova_teams" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."is_nova_user_id_in_team"("auth"."uid"(), "id")
      OR "public"."is_nova_user_email_in_team"("auth"."email"(), "id")
    )
  ) WITH CHECK (
    (
      "public"."is_nova_user_id_in_team"("auth"."uid"(), "id")
      OR "public"."is_nova_user_email_in_team"("auth"."email"(), "id")
    )
  );

CREATE POLICY "Allow update access for workspace_users" ON "public"."external_user_monthly_reports" FOR
UPDATE
  TO "authenticated" USING (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              "wu"."id" = "external_user_monthly_reports"."user_id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_user_groups" "wug"
          WHERE
            (
              "wug"."id" = "external_user_monthly_reports"."group_id"
            )
        )
      )
    )
  ) WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_users" "wu"
          WHERE
            (
              "wu"."id" = "external_user_monthly_reports"."user_id"
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_user_groups" "wug"
          WHERE
            (
              "wug"."id" = "external_user_monthly_reports"."group_id"
            )
        )
      )
    )
  );

CREATE POLICY "Allow update for workspace members" ON "public"."calendar_connections" FOR
UPDATE
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  ) WITH CHECK (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow update for workspace users and the participant" ON "public"."calendar_auth_tokens" FOR
UPDATE
  USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "Allow update for workspace users and the participant" ON "public"."calendar_event_platform_participants" FOR
UPDATE
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_calendar_events" "e",
            "public"."workspace_members" "m"
          WHERE
            (
              (
                "e"."id" = "calendar_event_platform_participants"."event_id"
              )
              AND (
                "m"."user_id" = "calendar_event_platform_participants"."user_id"
              )
              AND ("m"."ws_id" = "e"."ws_id")
            )
        )
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_calendar_events" "e",
            "public"."workspace_members" "m"
          WHERE
            (
              (
                "e"."id" = "calendar_event_platform_participants"."event_id"
              )
              AND (
                "m"."user_id" = "calendar_event_platform_participants"."user_id"
              )
              AND ("m"."ws_id" = "e"."ws_id")
            )
        )
      )
    )
  );

CREATE POLICY "Allow users from root workspace to manage the blacklist" ON "public"."email_blacklist" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_linked_users"
      WHERE
        (
          (
            "workspace_user_linked_users"."platform_user_id" = "auth"."uid"()
          )
          AND (
            "workspace_user_linked_users"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
          )
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_user_linked_users"
      WHERE
        (
          (
            "workspace_user_linked_users"."platform_user_id" = "auth"."uid"()
          )
          AND (
            "workspace_user_linked_users"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
          )
        )
    )
  )
);

CREATE POLICY "Allow users to delete their own sessions" ON "public"."time_tracking_sessions" USING (
  (
    ("user_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            ("wu"."ws_id" = "time_tracking_sessions"."ws_id")
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Allow users to insert their own sessions" ON "public"."time_tracking_sessions" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_members" "wu"
          WHERE
            (
              ("wu"."ws_id" = "time_tracking_sessions"."ws_id")
              AND ("wu"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Allow users to manage their own goals" ON "public"."time_tracking_goals" TO "authenticated" USING (
  (
    ("user_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            ("wu"."ws_id" = "time_tracking_goals"."ws_id")
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  )
) WITH CHECK (
  (
    ("user_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            ("wu"."ws_id" = "time_tracking_goals"."ws_id")
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Allow users to read their own goals" ON "public"."time_tracking_goals" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            ("wu"."ws_id" = "time_tracking_goals"."ws_id")
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow users to read their own sessions" ON "public"."time_tracking_sessions" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            ("wu"."ws_id" = "time_tracking_sessions"."ws_id")
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow users to update their own sessions" ON "public"."time_tracking_sessions" FOR
UPDATE
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_members" "wu"
          WHERE
            (
              ("wu"."ws_id" = "time_tracking_sessions"."ws_id")
              AND ("wu"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_members" "wu"
          WHERE
            (
              ("wu"."ws_id" = "time_tracking_sessions"."ws_id")
              AND ("wu"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Allow users who have access to workspace" ON "public"."discord_guild_members" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."discord_integrations" "di",
        "public"."workspace_members" "wm"
      WHERE
        (
          ("wm"."ws_id" = "di"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."discord_integrations" "di",
        "public"."workspace_members" "wm"
      WHERE
        (
          ("wm"."ws_id" = "di"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow users who have sufficient platform role" ON "public"."discord_integrations" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."platform_user_roles" "pur"
      WHERE
        (
          ("pur"."user_id" = "auth"."uid"())
          AND ("pur"."allow_discord_integrations" = true)
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."platform_user_roles" "pur"
      WHERE
        (
          ("pur"."user_id" = "auth"."uid"())
          AND ("pur"."allow_discord_integrations" = true)
        )
    )
  )
);

CREATE POLICY "Allow users with manage_user_report_templates permission" ON "public"."workspace_configs" TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_user_report_templates' :: "text"
  )
) WITH CHECK (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_user_report_templates' :: "text"
  )
);

COMMENT ON POLICY "Allow users with manage_user_report_templates permission" ON "public"."workspace_configs" IS 'Users must have the manage_user_report_templates permission in the workspace to perform any operation on workspace configs';

CREATE POLICY "Allow workspace managers to delete members" ON "public"."workspace_members" FOR DELETE TO "authenticated" USING (
  (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_members' :: "text"
    )
    OR ("auth"."uid"() = "user_id")
  )
);

CREATE POLICY "Allow workspace managers to insert members with constraints" ON "public"."workspace_members" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        (
          (
            (
              "public"."is_personal_workspace"("ws_id") = false
            )
            OR "public"."is_workspace_owner"("ws_id", "auth"."uid"())
          )
          AND (
            "public"."is_member_invited"("auth"."uid"(), "ws_id")
            OR (
              EXISTS (
                SELECT
                  1
                FROM
                  "public"."workspace_email_invites" "wei"
                WHERE
                  (
                    "lower"("wei"."email") = "lower"("auth"."email"())
                  )
              )
            )
          )
        )
        OR (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspaces" "w"
            WHERE
              (
                ("w"."id" = "workspace_members"."ws_id")
                AND ("w"."creator_id" = "auth"."uid"())
                AND (
                  NOT (
                    EXISTS (
                      SELECT
                        1
                      FROM
                        "public"."workspace_members" "wm"
                      WHERE
                        ("wm"."ws_id" = "wm"."ws_id")
                    )
                  )
                )
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow workspace managers to update members" ON "public"."workspace_members" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      OR ("auth"."uid"() = "user_id")
    )
  ) WITH CHECK (
    (
      "public"."has_workspace_permission"(
        "ws_id",
        "auth"."uid"(),
        'manage_workspace_members' :: "text"
      )
      OR ("auth"."uid"() = "user_id")
    )
  );

CREATE POLICY "Allow workspace members to create invite links" ON "public"."workspace_invite_links" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        "ws_id" IN (
          SELECT
            "wrp"."ws_id"
          FROM
            (
              "public"."workspace_role_members" "wrm"
              JOIN "public"."workspace_role_permissions" "wrp" ON (
                (
                  ("wrp"."role_id" = "wrm"."role_id")
                  AND ("wrp"."ws_id" = "workspace_invite_links"."ws_id")
                )
              )
            )
          WHERE
            (
              ("wrm"."user_id" = "auth"."uid"())
              AND (
                "wrp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
              )
              AND ("wrp"."enabled" = true)
            )
          UNION
          SELECT
            "wdp"."ws_id"
          FROM
            "public"."workspace_default_permissions" "wdp"
          WHERE
            (
              ("wdp"."ws_id" = "workspace_invite_links"."ws_id")
              AND (
                "wdp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
              )
              AND ("wdp"."enabled" = true)
              AND (
                EXISTS (
                  SELECT
                    1
                  FROM
                    "public"."workspace_members" "wm"
                  WHERE
                    (
                      ("wm"."ws_id" = "workspace_invite_links"."ws_id")
                      AND ("wm"."user_id" = "auth"."uid"())
                    )
                )
              )
            )
        )
      )
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_secrets" "wss"
            WHERE
              (
                ("wss"."ws_id" = "workspace_invite_links"."ws_id")
                AND ("wss"."name" = 'DISABLE_INVITE' :: "text")
              )
          )
        )
      )
    )
  );

CREATE POLICY "Allow workspace members to delete categories" ON "public"."workspace_calendar_categories" FOR DELETE TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wm"
      WHERE
        (
          (
            "wm"."ws_id" = "workspace_calendar_categories"."ws_id"
          )
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow workspace members to delete invite links" ON "public"."workspace_invite_links" FOR DELETE TO "authenticated" USING (
  (
    "ws_id" IN (
      SELECT
        "wrp"."ws_id"
      FROM
        (
          "public"."workspace_role_members" "wrm"
          JOIN "public"."workspace_role_permissions" "wrp" ON (
            (
              ("wrp"."role_id" = "wrm"."role_id")
              AND ("wrp"."ws_id" = "workspace_invite_links"."ws_id")
            )
          )
        )
      WHERE
        (
          ("wrm"."user_id" = "auth"."uid"())
          AND (
            "wrp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
          )
          AND ("wrp"."enabled" = true)
        )
      UNION
      SELECT
        "wdp"."ws_id"
      FROM
        "public"."workspace_default_permissions" "wdp"
      WHERE
        (
          ("wdp"."ws_id" = "workspace_invite_links"."ws_id")
          AND (
            "wdp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
          )
          AND ("wdp"."enabled" = true)
          AND (
            EXISTS (
              SELECT
                1
              FROM
                "public"."workspace_members" "wm"
              WHERE
                (
                  ("wm"."ws_id" = "workspace_invite_links"."ws_id")
                  AND ("wm"."user_id" = "auth"."uid"())
                )
            )
          )
        )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."audio_chunks" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm",
        "public"."recording_sessions" "rs"
      WHERE
        (
          ("rs"."meeting_id" = "wm"."id")
          AND ("rs"."id" = "audio_chunks"."session_id")
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm",
        "public"."recording_sessions" "rs"
      WHERE
        (
          ("rs"."meeting_id" = "wm"."id")
          AND ("rs"."id" = "audio_chunks"."session_id")
        )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."recording_sessions" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm"
      WHERE
        ("wm"."id" = "recording_sessions"."meeting_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm"
      WHERE
        ("wm"."id" = "recording_sessions"."meeting_id")
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."recording_transcripts" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm",
        "public"."recording_sessions" "rs"
      WHERE
        (
          ("rs"."meeting_id" = "wm"."id")
          AND ("rs"."id" = "recording_transcripts"."session_id")
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_meetings" "wm",
        "public"."recording_sessions" "rs"
      WHERE
        (
          ("rs"."meeting_id" = "wm"."id")
          AND ("rs"."id" = "recording_transcripts"."session_id")
        )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."workspace_dataset_cells" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_datasets" "wd"
        WHERE
          (
            "wd"."id" = "workspace_dataset_cells"."dataset_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_dataset_columns" "wdc"
        WHERE
          (
            "wdc"."id" = "workspace_dataset_cells"."column_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_datasets" "wd"
        WHERE
          (
            "wd"."id" = "workspace_dataset_cells"."dataset_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_dataset_columns" "wdc"
        WHERE
          (
            "wdc"."id" = "workspace_dataset_cells"."column_id"
          )
      )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."workspace_dataset_columns" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_datasets" "wd"
      WHERE
        (
          "wd"."id" = "workspace_dataset_columns"."dataset_id"
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_datasets" "wd"
      WHERE
        (
          "wd"."id" = "workspace_dataset_columns"."dataset_id"
        )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."workspace_dataset_rows" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_datasets" "wd"
      WHERE
        (
          "wd"."id" = "workspace_dataset_rows"."dataset_id"
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_datasets" "wd"
      WHERE
        (
          "wd"."id" = "workspace_dataset_rows"."dataset_id"
        )
    )
  )
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."workspace_datasets" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow workspace members to have full permissions" ON "public"."workspace_meetings" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Allow workspace members to insert" ON "public"."shortened_links" FOR
INSERT
  WITH CHECK (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow workspace members to insert categories" ON "public"."workspace_calendar_categories" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = "workspace_calendar_categories"."ws_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow workspace members to manage categories" ON "public"."time_tracking_categories" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wu"
      WHERE
        (
          (
            "wu"."ws_id" = "time_tracking_categories"."ws_id"
          )
          AND ("wu"."user_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wu"
      WHERE
        (
          (
            "wu"."ws_id" = "time_tracking_categories"."ws_id"
          )
          AND ("wu"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Allow workspace members to read categories" ON "public"."time_tracking_categories" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wu"
        WHERE
          (
            (
              "wu"."ws_id" = "time_tracking_categories"."ws_id"
            )
            AND ("wu"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow workspace members to read categories" ON "public"."workspace_calendar_categories" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = "workspace_calendar_categories"."ws_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow workspace members to select" ON "public"."shortened_links" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow workspace members to update categories" ON "public"."workspace_calendar_categories" FOR
UPDATE
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = "workspace_calendar_categories"."ws_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  ) WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = "workspace_calendar_categories"."ws_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Allow workspace members to update invite links" ON "public"."workspace_invite_links" FOR
UPDATE
  TO "authenticated" USING (
    (
      "ws_id" IN (
        SELECT
          "wrp"."ws_id"
        FROM
          (
            "public"."workspace_role_members" "wrm"
            JOIN "public"."workspace_role_permissions" "wrp" ON (
              (
                ("wrp"."role_id" = "wrm"."role_id")
                AND ("wrp"."ws_id" = "workspace_invite_links"."ws_id")
              )
            )
          )
        WHERE
          (
            ("wrm"."user_id" = "auth"."uid"())
            AND (
              "wrp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
            )
            AND ("wrp"."enabled" = true)
          )
        UNION
        SELECT
          "wdp"."ws_id"
        FROM
          "public"."workspace_default_permissions" "wdp"
        WHERE
          (
            ("wdp"."ws_id" = "workspace_invite_links"."ws_id")
            AND (
              "wdp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
            )
            AND ("wdp"."enabled" = true)
            AND (
              EXISTS (
                SELECT
                  1
                FROM
                  "public"."workspace_members" "wm"
                WHERE
                  (
                    ("wm"."ws_id" = "workspace_invite_links"."ws_id")
                    AND ("wm"."user_id" = "auth"."uid"())
                  )
              )
            )
          )
      )
    )
  ) WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "wrp"."ws_id"
        FROM
          (
            "public"."workspace_role_members" "wrm"
            JOIN "public"."workspace_role_permissions" "wrp" ON (
              (
                ("wrp"."role_id" = "wrm"."role_id")
                AND ("wrp"."ws_id" = "workspace_invite_links"."ws_id")
              )
            )
          )
        WHERE
          (
            ("wrm"."user_id" = "auth"."uid"())
            AND (
              "wrp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
            )
            AND ("wrp"."enabled" = true)
          )
        UNION
        SELECT
          "wdp"."ws_id"
        FROM
          "public"."workspace_default_permissions" "wdp"
        WHERE
          (
            ("wdp"."ws_id" = "workspace_invite_links"."ws_id")
            AND (
              "wdp"."permission" = 'manage_workspace_members' :: "public"."workspace_role_permission"
            )
            AND ("wdp"."enabled" = true)
            AND (
              EXISTS (
                SELECT
                  1
                FROM
                  "public"."workspace_members" "wm"
                WHERE
                  (
                    ("wm"."ws_id" = "workspace_invite_links"."ws_id")
                    AND ("wm"."user_id" = "auth"."uid"())
                  )
              )
            )
          )
      )
    )
  );

CREATE POLICY "Allow workspace members to view invite link uses" ON "public"."workspace_invite_link_uses" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow workspace members to view invite links" ON "public"."workspace_invite_links" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Allow workspace role manager to create requests" ON "public"."workspace_education_access_requests" FOR
INSERT
  TO "authenticated" WITH CHECK (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
  );

CREATE POLICY "Allow workspace role manager to view requests" ON "public"."workspace_education_access_requests" FOR
SELECT
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_roles' :: "text"
    )
  );

CREATE POLICY "Allow workspace settings managers to delete" ON "public"."workspaces" FOR DELETE TO "authenticated" USING (
  (
    (
      "id" <> '00000000-0000-0000-0000-000000000000' :: "uuid"
    )
    AND (
      NOT "public"."has_workspace_secret"("id", 'PREVENT_WORKSPACE_DELETION' :: "text")
    )
    AND "public"."has_workspace_permission"(
      "id",
      "auth"."uid"(),
      'manage_workspace_settings' :: "text"
    )
  )
);

CREATE POLICY "Allow workspace settings managers to update" ON "public"."workspaces" FOR
UPDATE
  TO "authenticated" USING (
    (
      (
        "id" <> '00000000-0000-0000-0000-000000000000' :: "uuid"
      )
      AND "public"."has_workspace_permission"(
        "id",
        "auth"."uid"(),
        'manage_workspace_settings' :: "text"
      )
    )
  ) WITH CHECK (
    (
      (
        "id" <> '00000000-0000-0000-0000-000000000000' :: "uuid"
      )
      AND "public"."has_workspace_permission"(
        "id",
        "auth"."uid"(),
        'manage_workspace_settings' :: "text"
      )
    )
  );

CREATE POLICY "Anyone can view published changelogs" ON "public"."changelog_entries" FOR
SELECT
  USING (
    (
      ("is_published" = true)
      AND ("published_at" IS NOT NULL)
    )
  );

CREATE POLICY "Approver can update status fields only" ON "public"."time_tracking_requests" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "workspace_id")
      AND ("auth"."uid"() <> "user_id")
      AND (
        "approval_status" = 'PENDING' :: "public"."time_tracking_request_status"
      )
    )
  ) WITH CHECK (
    (
      "public"."is_org_member"("auth"."uid"(), "workspace_id")
      AND (
        (
          "approval_status" = 'APPROVED' :: "public"."time_tracking_request_status"
        )
        OR (
          "approval_status" = 'REJECTED' :: "public"."time_tracking_request_status"
        )
      )
    )
  );

CREATE POLICY "Channel creators can delete their channels" ON "public"."workspace_chat_channels" FOR DELETE USING (("created_by" = "auth"."uid"()));

CREATE POLICY "Channel creators can update their channels" ON "public"."workspace_chat_channels" FOR
UPDATE
  USING (("created_by" = "auth"."uid"()));

CREATE POLICY "Denies all requests" ON "public"."crawled_url_next_urls" TO "authenticated" USING (false) WITH CHECK (false);

CREATE POLICY "Denies all requests" ON "public"."crawled_urls" TO "authenticated" USING (false) WITH CHECK (false);

CREATE POLICY "Disable access for all users" ON "public"."calendar_sync_states" USING (false) WITH CHECK (false);

CREATE POLICY "Disable access for everyone" ON "public"."poll_guest_votes" TO "authenticated" USING (false) WITH CHECK (false);

CREATE POLICY "Disable access for everyone" ON "public"."poll_options" TO "authenticated" USING (false) WITH CHECK (false);

CREATE POLICY "Enable access for note owners" ON "public"."personal_notes" TO "authenticated" USING (("owner_id" = "auth"."uid"())) WITH CHECK (("owner_id" = "auth"."uid"()));

CREATE POLICY "Enable access for workspace members" ON "public"."workspace_calendar_sync_coordination" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "workspace_calendar_sync_coordination"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "workspace_calendar_sync_coordination"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Enable all access for challenge manager" ON "public"."nova_challenge_whitelisted_emails" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Enable all access for challenge manager" ON "public"."nova_challenges" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Enable all access for challenge managers" ON "public"."nova_sessions" TO "authenticated" USING ("public"."is_nova_challenge_manager"()) WITH CHECK ("public"."is_nova_challenge_manager"());

CREATE POLICY "Enable all access for current user" ON "public"."nova_sessions" TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "Enable all access for current user" ON "public"."nova_submissions" TO "authenticated" USING (
  (
    ("user_id" = "auth"."uid"())
    OR "public"."is_nova_challenge_manager"()
  )
) WITH CHECK (
  (
    ("user_id" = "auth"."uid"())
    OR "public"."is_nova_challenge_manager"()
  )
);

CREATE POLICY "Enable all access for members of the task board" ON "public"."task_lists" TO "authenticated" USING (
  "public"."is_task_board_member"("auth"."uid"(), "board_id")
) WITH CHECK (
  "public"."is_task_board_member"("auth"."uid"(), "board_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."credit_wallets" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_wallets" "w"
      WHERE
        ("w"."id" = "credit_wallets"."wallet_id")
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_wallets" "w"
      WHERE
        ("w"."id" = "credit_wallets"."wallet_id")
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."finance_invoices" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_checkup_vital_groups" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_checkups" "c"
        WHERE
          (
            "c"."id" = "healthcare_checkup_vital_groups"."checkup_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vital_groups" "v"
        WHERE
          (
            "v"."id" = "healthcare_checkup_vital_groups"."group_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_checkups" "c"
        WHERE
          (
            "c"."id" = "healthcare_checkup_vital_groups"."checkup_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vital_groups" "v"
        WHERE
          (
            "v"."id" = "healthcare_checkup_vital_groups"."group_id"
          )
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_checkup_vitals" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_checkups" "c"
        WHERE
          (
            "c"."id" = "healthcare_checkup_vitals"."checkup_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vitals" "v"
        WHERE
          (
            "v"."id" = "healthcare_checkup_vitals"."vital_id"
          )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_checkups" "c"
        WHERE
          (
            "c"."id" = "healthcare_checkup_vitals"."checkup_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vitals" "v"
        WHERE
          (
            "v"."id" = "healthcare_checkup_vitals"."vital_id"
          )
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_checkups" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_diagnoses" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_vital_groups" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."healthcare_vitals" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_batch_products" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_batches" "b"
        WHERE
          ("b"."id" = "inventory_batch_products"."batch_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          (
            "p"."id" = "inventory_batch_products"."product_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "inventory_batch_products"."unit_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_batches" "b"
        WHERE
          ("b"."id" = "inventory_batch_products"."batch_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          (
            "p"."id" = "inventory_batch_products"."product_id"
          )
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "inventory_batch_products"."unit_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_batches" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_warehouses" "w"
        WHERE
          ("w"."id" = "inventory_batches"."warehouse_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_suppliers" "s"
        WHERE
          ("s"."id" = "inventory_batches"."supplier_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_warehouses" "w"
        WHERE
          ("w"."id" = "inventory_batches"."warehouse_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_suppliers" "s"
        WHERE
          ("s"."id" = "inventory_batches"."supplier_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_products" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          ("p"."id" = "inventory_products"."product_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "inventory_products"."unit_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_products" "p"
        WHERE
          ("p"."id" = "inventory_products"."product_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."inventory_units" "u"
        WHERE
          ("u"."id" = "inventory_products"."unit_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_suppliers" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_units" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."inventory_warehouses" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."product_categories" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."transaction_categories" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."vital_group_vitals" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vital_groups" "g"
        WHERE
          ("g"."id" = "vital_group_vitals"."group_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vitals" "v"
        WHERE
          ("v"."id" = "vital_group_vitals"."vital_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vital_groups" "g"
        WHERE
          ("g"."id" = "vital_group_vitals"."group_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."healthcare_vitals" "v"
        WHERE
          ("v"."id" = "vital_group_vitals"."vital_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for organization members" ON "public"."workspace_boards" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."workspace_products" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."workspace_teams" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."workspace_user_groups" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for organization members" ON "public"."workspace_user_groups_users" TO "authenticated" USING (
  "public"."is_org_member"(
    "auth"."uid"(),
    (
      SELECT
        "workspace_user_groups"."ws_id"
      FROM
        "public"."workspace_user_groups"
      WHERE
        (
          "workspace_user_groups"."id" = "workspace_user_groups_users"."group_id"
        )
    )
  )
) WITH CHECK (
  "public"."is_org_member"(
    "auth"."uid"(),
    (
      SELECT
        "workspace_user_groups"."ws_id"
      FROM
        "public"."workspace_user_groups"
      WHERE
        (
          "workspace_user_groups"."id" = "workspace_user_groups_users"."group_id"
        )
    )
  )
);

CREATE POLICY "Enable all access for role manager" ON "public"."platform_email_roles" TO "authenticated" USING ("public"."is_nova_role_manager"());

CREATE POLICY "Enable all access for tasks in accessible task list" ON "public"."tasks" TO "authenticated" USING (
  (
    ("list_id" IS NULL)
    OR (
      EXISTS (
        SELECT
          1
        FROM
          "public"."task_lists" "tl"
        WHERE
          ("tl"."id" = "tasks"."list_id")
      )
    )
  )
) WITH CHECK (
  (
    ("list_id" IS NULL)
    OR (
      EXISTS (
        SELECT
          1
        FROM
          "public"."task_lists" "tl"
        WHERE
          ("tl"."id" = "tasks"."list_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for timeblock creators" ON "public"."meet_together_user_timeblocks" TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "Enable all access for workspace members" ON "public"."finance_invoice_products" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."finance_invoices" "fi"
        WHERE
          (
            "fi"."id" = "finance_invoice_products"."invoice_id"
          )
      )
    )
    AND (
      ("unit_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."inventory_units" "iu"
          WHERE
            ("iu"."id" = "finance_invoice_products"."unit_id")
        )
      )
    )
    AND (
      ("product_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_products" "wp"
          WHERE
            (
              "wp"."id" = "finance_invoice_products"."product_id"
            )
        )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."finance_invoices" "fi"
        WHERE
          (
            "fi"."id" = "finance_invoice_products"."invoice_id"
          )
      )
    )
    AND (
      ("unit_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."inventory_units" "iu"
          WHERE
            ("iu"."id" = "finance_invoice_products"."unit_id")
        )
      )
    )
    AND (
      ("product_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_products" "wp"
          WHERE
            (
              "wp"."id" = "finance_invoice_products"."product_id"
            )
        )
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."finance_invoice_promotions" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."finance_invoices" "fi"
        WHERE
          (
            "fi"."id" = "finance_invoice_promotions"."invoice_id"
          )
      )
    )
    AND (
      ("promo_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_promotions" "wp"
          WHERE
            (
              "wp"."id" = "finance_invoice_promotions"."promo_id"
            )
        )
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."finance_invoices" "fi"
        WHERE
          (
            "fi"."id" = "finance_invoice_promotions"."invoice_id"
          )
      )
    )
    AND (
      ("promo_id" IS NULL)
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_promotions" "wp"
          WHERE
            (
              "wp"."id" = "finance_invoice_promotions"."promo_id"
            )
        )
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."quiz_set_quizzes" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quiz_sets" "wqs"
        WHERE
          ("wqs"."id" = "quiz_set_quizzes"."set_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quizzes" "wq"
        WHERE
          ("wq"."id" = "quiz_set_quizzes"."quiz_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quiz_sets" "wqs"
        WHERE
          ("wqs"."id" = "quiz_set_quizzes"."set_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_quizzes" "wq"
        WHERE
          ("wq"."id" = "quiz_set_quizzes"."quiz_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."sent_emails" TO "authenticated" USING (
  (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspaces" "wss"
          WHERE
            ("wss"."id" = "sent_emails"."ws_id")
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."user_group_posts" "ugp"
          WHERE
            ("ugp"."id" = "sent_emails"."post_id")
        )
      )
    )
    OR (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "wu"
        WHERE
          ("wu"."id" = "sent_emails"."receiver_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspaces" "wss"
          WHERE
            ("wss"."id" = "sent_emails"."ws_id")
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."user_group_posts" "ugp"
          WHERE
            ("ugp"."id" = "sent_emails"."post_id")
        )
      )
    )
    OR (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "wu"
        WHERE
          ("wu"."id" = "sent_emails"."receiver_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."user_linked_promotions" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_promotions" "p"
        WHERE
          ("p"."id" = "user_linked_promotions"."promo_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_linked_promotions"."user_id")
      )
    )
  )
) WITH CHECK (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_promotions" "p"
        WHERE
          ("p"."id" = "user_linked_promotions"."promo_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "u"
        WHERE
          ("u"."id" = "user_linked_promotions"."user_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_calendar_hour_settings" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_cron_executions" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_cron_jobs" "wcj"
      WHERE
        (
          "wcj"."id" = "workspace_cron_executions"."job_id"
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_cron_jobs" "wcj"
      WHERE
        (
          "wcj"."id" = "workspace_cron_executions"."job_id"
        )
    )
  )
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_cron_jobs" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_promotions" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_users" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for workspace members" ON "public"."workspace_wallets" TO "authenticated" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Enable all access for workspace users" ON "public"."user_group_post_checks" TO "authenticated" USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_users" "wu"
        WHERE
          ("wu"."id" = "user_group_post_checks"."user_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."user_group_posts" "ugp"
        WHERE
          ("ugp"."id" = "user_group_post_checks"."post_id")
      )
    )
  )
);

CREATE POLICY "Enable all access for workspace users" ON "public"."workspace_calendar_events" TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w",
        "public"."workspace_members" "wm"
      WHERE
        (
          ("w"."id" = "workspace_calendar_events"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
          AND ("wm"."ws_id" = "w"."id")
        )
    )
  )
) WITH CHECK (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspaces" "w",
        "public"."workspace_members" "wm"
      WHERE
        (
          ("w"."id" = "workspace_calendar_events"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
          AND ("wm"."ws_id" = "w"."id")
        )
    )
  )
);

CREATE POLICY "Enable current user to see their role" ON "public"."platform_email_roles" FOR
SELECT
  TO "authenticated" USING ((("email") :: "text" = "auth"."email"()));

CREATE POLICY "Enable delete for organization members and current user" ON "public"."workspace_email_invites" FOR DELETE TO "authenticated" USING (
  (
    ("lower"("auth"."email"()) = "lower"("email"))
    OR "public"."is_org_member"("auth"."uid"(), "ws_id")
  )
);

CREATE POLICY "Enable delete for users based on user_id" ON "public"."course_certificates" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid"() AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "Enable delete for users based on user_id" ON "public"."poll_user_votes" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT
        "auth"."uid"() AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "Enable delete for users who can access the task" ON "public"."task_assignees" FOR DELETE TO "authenticated" USING ("public"."is_task_accessible"("task_id"));

CREATE POLICY "Enable insert access for member of workspace" ON "public"."time_tracking_requests" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."is_org_member"("auth"."uid"(), "workspace_id")
      AND (
        "approval_status" = 'PENDING' :: "public"."time_tracking_request_status"
      )
      AND ("user_id" = "auth"."uid"())
    )
  );

CREATE POLICY "Enable insert for authenticated users only" ON "public"."ai_chats" FOR
INSERT
  TO "authenticated" WITH CHECK (("auth"."uid"() = "creator_id"));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."handles" FOR
INSERT
  TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."workspaces" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      ("creator_id" = "auth"."uid"())
      AND (
        "public"."is_tuturuuu_email"(
          (
            SELECT
              "user_private_details"."email"
            FROM
              "public"."user_private_details"
            WHERE
              (
                "user_private_details"."user_id" = "auth"."uid"()
              )
          )
        )
        OR (
          "public"."count_user_workspaces"("auth"."uid"()) < 10
        )
      )
    )
  );

CREATE POLICY "Enable insert for users based on user_id" ON "public"."course_certificates" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable insert for users based on user_id" ON "public"."course_module_completion_status" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable insert for users based on user_id" ON "public"."poll_user_votes" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable insert for users who can access the task" ON "public"."task_assignees" FOR
INSERT
  TO "authenticated" WITH CHECK ("public"."is_task_accessible"("task_id"));

CREATE POLICY "Enable insert for workspace members" ON "public"."workspace_email_invites" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      "public"."is_org_member"("auth"."uid"(), "ws_id")
      AND (
        NOT (
          EXISTS (
            SELECT
              1
            FROM
              "public"."workspace_secrets" "wss"
            WHERE
              (
                (
                  "wss"."ws_id" = "workspace_email_invites"."ws_id"
                )
                AND ("wss"."name" = 'DISABLE_INVITE' :: "text")
              )
          )
        )
      )
    )
  );

CREATE POLICY "Enable insert with creator and creation permission check" ON "public"."workspaces" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      ("creator_id" = "auth"."uid"())
      AND "public"."can_create_workspace"("auth"."uid"())
    )
  );

CREATE POLICY "Enable read access for all users" ON "public"."timezones" FOR
SELECT
  USING (true);

CREATE POLICY "Enable read access for authenticated users" ON "public"."calendar_event_colors" FOR
SELECT
  TO "authenticated" USING (true);

CREATE POLICY "Enable read access for authenticated users" ON "public"."internal_email_api_keys" FOR
SELECT
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      AND "public"."is_org_member"(
        "auth"."uid"(),
        '00000000-0000-0000-0000-000000000000' :: "uuid"
      )
    )
  );

CREATE POLICY "Enable read access for authenticated users" ON "public"."users" FOR
SELECT
  TO "authenticated" USING (true);

CREATE POLICY "Enable read access for current chat member" ON "public"."ai_chat_members" FOR
SELECT
  TO "authenticated" USING (("auth"."email"() = "email"));

CREATE POLICY "Enable read access for current user and workspace users" ON "public"."user_private_details" FOR
SELECT
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_members" "wm"
          WHERE
            (
              "wm"."user_id" = "user_private_details"."user_id"
            )
        )
      )
    )
  );

CREATE POLICY "Enable read access for everyone if plan is public" ON "public"."meet_together_plans" FOR
SELECT
  USING (
    (
      "is_public"
      AND ("ws_id" IS NULL)
    )
  );

CREATE POLICY "Enable read access for member of workspace" ON "public"."time_tracking_requests" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "workspace_id")
  );

CREATE POLICY "Enable read access for normal users" ON "public"."nova_problem_test_cases" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."nova_problems" "np"
        WHERE
          (
            "np"."id" = "nova_problem_test_cases"."problem_id"
          )
      )
    )
  );

CREATE POLICY "Enable read access for organization members" ON "public"."workspace_members" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Enable read access for organization members" ON "public"."workspace_user_status_changes" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Enable read access for organization members and current user" ON "public"."workspace_email_invites" FOR
SELECT
  TO "authenticated" USING (
    (
      ("lower"("auth"."email"()) = "lower"("email"))
      OR "public"."is_org_member"("auth"."uid"(), "ws_id")
    )
  );

CREATE POLICY "Enable read access for organization members or invited members" ON "public"."workspaces" FOR
SELECT
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "id")
      OR "public"."is_member_invited"("auth"."uid"(), "id")
      OR (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_email_invites" "wei"
          WHERE
            (
              (
                "lower"("wei"."email") = "lower"("auth"."email"())
              )
              AND ("wei"."ws_id" = "workspaces"."id")
            )
        )
      )
      OR ("creator_id" = "auth"."uid"())
    )
  );

CREATE POLICY "Enable read access for workspace members" ON "public"."calendar_sync_dashboard" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Enable read access for workspace members if plan is public" ON "public"."meet_together_plans" FOR
SELECT
  TO "authenticated" USING (
    (
      "is_public"
      AND (
        ("ws_id" IS NULL)
        OR "public"."is_org_member"("auth"."uid"(), "ws_id")
      )
    )
  );

CREATE POLICY "Enable read access for workspace users" ON "public"."workspace_default_permissions" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"("auth"."uid"(), "ws_id")
  );

CREATE POLICY "Enable read access for workspace users" ON "public"."workspace_role_permissions" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_role_members" "wrm"
        WHERE
          (
            "wrm"."role_id" = "workspace_role_permissions"."role_id"
          )
      )
    )
  );

CREATE POLICY "Enable select for assignees who has access to the task" ON "public"."task_assignees" FOR
SELECT
  TO "authenticated" USING ("public"."is_task_accessible"("task_id"));

CREATE POLICY "Enable update for chat creator" ON "public"."ai_chats" FOR
UPDATE
  TO "authenticated" USING (("creator_id" = "auth"."uid"())) WITH CHECK (("creator_id" = "auth"."uid"()));

CREATE POLICY "Enable update for users based on email" ON "public"."user_private_details" FOR
UPDATE
  TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "Enable update for users based on their uid" ON "public"."users" FOR
UPDATE
  TO "authenticated" USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));

CREATE POLICY "Enable update for users based on user_id" ON "public"."course_certificates" FOR
UPDATE
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  ) WITH CHECK (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable update for users based on user_id" ON "public"."course_module_completion_status" FOR
UPDATE
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  ) WITH CHECK (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable update respecting personal workspace and roles" ON "public"."workspaces" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."has_workspace_permission"(
        "id",
        "auth"."uid"(),
        'manage_workspace_settings' :: "text"
      )
      AND (
        ("personal" = false)
        OR ("public"."get_workspace_member_count"("id") = 1)
      )
    )
  ) WITH CHECK (
    (
      "public"."has_workspace_permission"(
        "id",
        "auth"."uid"(),
        'manage_workspace_settings' :: "text"
      )
      AND (
        ("personal" = false)
        OR ("public"."get_workspace_member_count"("id") = 1)
      )
    )
  );

CREATE POLICY "Enable users to view their own data only" ON "public"."course_certificates" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable users to view their own data only" ON "public"."course_module_completion_status" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Enable users to view their own data only" ON "public"."support_inquiries" FOR
SELECT
  TO "authenticated" USING (
    (
      (
        SELECT
          "auth"."uid"() AS "uid"
      ) = "creator_id"
    )
  );

CREATE POLICY "Everyone can insert" ON "public"."support_inquiries" FOR
INSERT
  WITH CHECK (true);

CREATE POLICY "Full access for organization members" ON "public"."guest_users_lead_generation" USING (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
) WITH CHECK (
  "public"."is_org_member"("auth"."uid"(), "ws_id")
);

CREATE POLICY "Internal users can view emails" ON "public"."internal_emails" FOR
SELECT
  TO "authenticated" USING (
    (
      ("user_id" = "auth"."uid"())
      AND "public"."is_org_member"(
        "user_id",
        '00000000-0000-0000-0000-000000000000' :: "uuid"
      )
    )
  );

CREATE POLICY "Owner can delete PENDING request" ON "public"."time_tracking_requests" FOR DELETE TO "authenticated" USING (
  (
    "public"."is_org_member"("auth"."uid"(), "workspace_id")
    AND ("auth"."uid"() = "user_id")
    AND (
      "approval_status" = 'PENDING' :: "public"."time_tracking_request_status"
    )
  )
);

CREATE POLICY "Participants can send messages" ON "public"."workspace_chat_messages" FOR
INSERT
  WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."workspace_chat_channels" "c"
              JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
            )
          WHERE
            (
              (
                "c"."id" = "workspace_chat_messages"."channel_id"
              )
              AND ("m"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Participants can view messages in their channels" ON "public"."workspace_chat_messages" FOR
SELECT
  USING (
    (
      "public"."user_is_in_channel"("channel_id", "auth"."uid"())
      AND ("deleted_at" IS NULL)
    )
  );

CREATE POLICY "Root workspace users can view all email audit" ON "public"."email_audit" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Root workspace users can view bounces" ON "public"."email_bounce_complaints" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = '00000000-0000-0000-0000-000000000000' :: "uuid"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Service role can manage email config" ON "public"."notification_email_config" USING (("auth"."role"() = 'service_role' :: "text")) WITH CHECK (("auth"."role"() = 'service_role' :: "text"));

CREATE POLICY "Service role can manage reminders" ON "public"."task_reminder_sent" USING (("auth"."role"() = 'service_role' :: "text")) WITH CHECK (("auth"."role"() = 'service_role' :: "text"));

CREATE POLICY "Service role full access on bounces" ON "public"."email_bounce_complaints" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role full access on email_audit" ON "public"."email_audit" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role only access" ON "public"."workspace_encryption_keys" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Status templates are manageable by authenticated users" ON "public"."task_board_status_templates" TO "authenticated" USING (true);

CREATE POLICY "Status templates are readable by everyone" ON "public"."task_board_status_templates" FOR
SELECT
  TO "authenticated" USING (true);

CREATE POLICY "System access only" ON "public"."workspace_email_credentials" TO "authenticated" USING (false) WITH CHECK (false);

CREATE POLICY "System can insert delivery logs" ON "public"."notification_delivery_log" FOR
INSERT
  WITH CHECK (false);

CREATE POLICY "System can manage batches" ON "public"."notification_batches" USING (false) WITH CHECK (false);

CREATE POLICY "System can update delivery logs" ON "public"."notification_delivery_log" FOR
UPDATE
  USING (false) WITH CHECK (false);

CREATE POLICY "Tuturuuu employees can view aggregated logs" ON "public"."realtime_log_aggregations" FOR
SELECT
  TO "authenticated" USING (
    "public"."is_org_member"(
      "auth"."uid"(),
      '00000000-0000-0000-0000-000000000000' :: "uuid"
    )
  );

CREATE POLICY "User can update their own PENDING request" ON "public"."time_tracking_requests" FOR
UPDATE
  TO "authenticated" USING (
    (
      "public"."is_org_member"("auth"."uid"(), "workspace_id")
      AND ("auth"."uid"() = "user_id")
      AND (
        "approval_status" = 'PENDING' :: "public"."time_tracking_request_status"
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND "public"."is_org_member"("auth"."uid"(), "workspace_id")
      AND (
        "approval_status" = 'PENDING' :: "public"."time_tracking_request_status"
      )
    )
  );

CREATE POLICY "Users can add attachments to project updates" ON "public"."task_project_update_attachments" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."task_project_updates" "tpu"
                JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              (
                "tpu"."id" = "task_project_update_attachments"."update_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
              AND ("tpu"."deleted_at" IS NULL)
            )
        )
      )
      AND ("uploaded_by" = "auth"."uid"())
    )
  );

CREATE POLICY "Users can add reactions to project updates" ON "public"."task_project_update_reactions" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."task_project_updates" "tpu"
                JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              (
                "tpu"."id" = "task_project_update_reactions"."update_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
              AND ("tpu"."deleted_at" IS NULL)
            )
        )
      )
      AND ("user_id" = "auth"."uid"())
    )
  );

CREATE POLICY "Users can add themselves as watchers" ON "public"."task_watchers" FOR
INSERT
  WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                (
                  "public"."tasks" "t"
                  JOIN "public"."task_lists" "tl" ON (("t"."list_id" = "tl"."id"))
                )
                JOIN "public"."workspace_boards" "wb" ON (("tl"."board_id" = "wb"."id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
            )
          WHERE
            (
              ("t"."id" = "task_watchers"."task_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can create budgets in their workspace" ON "public"."finance_budgets" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "finance_budgets"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create comments on project updates" ON "public"."task_project_update_comments" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."task_project_updates" "tpu"
                JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              (
                "tpu"."id" = "task_project_update_comments"."update_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
              AND ("tpu"."deleted_at" IS NULL)
            )
        )
      )
      AND ("user_id" = "auth"."uid"())
    )
  );

CREATE POLICY "Users can create habit completions in their workspaces" ON "public"."habit_completions" FOR
INSERT
  WITH CHECK (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can create habit events in their workspaces" ON "public"."habit_calendar_events" FOR
INSERT
  WITH CHECK (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can create habits in their workspaces" ON "public"."workspace_habits" FOR
INSERT
  WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can create labels in their workspaces" ON "public"."workspace_task_labels" FOR
INSERT
  WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can create notes in their workspaces" ON "public"."notes" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "notes"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create project updates in their workspaces" ON "public"."task_project_updates" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."task_projects" "tp"
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              ("tp"."id" = "task_project_updates"."project_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
      AND ("creator_id" = "auth"."uid"())
    )
  );

CREATE POLICY "Users can create recurring transactions in their workspace" ON "public"."recurring_transactions" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "recurring_transactions"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create tags in their workspace" ON "public"."transaction_tags" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "transaction_tags"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create task cycles in their workspaces" ON "public"."task_cycles" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_cycles"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create task initiatives in their workspaces" ON "public"."task_initiatives" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_initiatives"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create task projects in their workspaces" ON "public"."task_projects" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_projects"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can create task relationships in their workspaces" ON "public"."task_relationships" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."tasks" "t"
                JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
            )
          WHERE
            (
              ("t"."id" = "task_relationships"."source_task_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."tasks" "t"
                JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
            )
          WHERE
            (
              ("t"."id" = "task_relationships"."target_task_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can create their typing indicator" ON "public"."workspace_chat_typing_indicators" FOR
INSERT
  WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."workspace_chat_channels" "c"
              JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
            )
          WHERE
            (
              (
                "c"."id" = "workspace_chat_typing_indicators"."channel_id"
              )
              AND ("m"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can create transaction tags in their workspace" ON "public"."wallet_transaction_tags" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."wallet_transactions" "wt"
              JOIN "public"."workspace_wallets" "ww" ON (("wt"."wallet_id" = "ww"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("ww"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            (
              "wt"."id" = "wallet_transaction_tags"."transaction_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can delete break types for workspaces they belong to" ON "public"."workspace_break_types" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "workspace_break_types"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete budgets in their workspace" ON "public"."finance_budgets" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "finance_budgets"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete habit completions in their workspaces" ON "public"."habit_completions" FOR DELETE USING (
  (
    "habit_id" IN (
      SELECT
        "workspace_habits"."id"
      FROM
        "public"."workspace_habits"
      WHERE
        (
          "workspace_habits"."ws_id" IN (
            SELECT
              "workspace_members"."ws_id"
            FROM
              "public"."workspace_members"
            WHERE
              ("workspace_members"."user_id" = "auth"."uid"())
          )
        )
    )
  )
);

CREATE POLICY "Users can delete habit events in their workspaces" ON "public"."habit_calendar_events" FOR DELETE USING (
  (
    "habit_id" IN (
      SELECT
        "workspace_habits"."id"
      FROM
        "public"."workspace_habits"
      WHERE
        (
          "workspace_habits"."ws_id" IN (
            SELECT
              "workspace_members"."ws_id"
            FROM
              "public"."workspace_members"
            WHERE
              ("workspace_members"."user_id" = "auth"."uid"())
          )
        )
    )
  )
);

CREATE POLICY "Users can delete habits in their workspaces" ON "public"."workspace_habits" FOR DELETE USING (
  (
    "ws_id" IN (
      SELECT
        "workspace_members"."ws_id"
      FROM
        "public"."workspace_members"
      WHERE
        ("workspace_members"."user_id" = "auth"."uid"())
    )
  )
);

CREATE POLICY "Users can delete labels in their workspaces" ON "public"."workspace_task_labels" FOR DELETE USING (
  (
    "ws_id" IN (
      SELECT
        "workspace_members"."ws_id"
      FROM
        "public"."workspace_members"
      WHERE
        ("workspace_members"."user_id" = "auth"."uid"())
    )
  )
);

CREATE POLICY "Users can delete recurring transactions in their workspace" ON "public"."recurring_transactions" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "recurring_transactions"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete tags in their workspace" ON "public"."transaction_tags" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members"
      WHERE
        (
          (
            "workspace_members"."ws_id" = "transaction_tags"."ws_id"
          )
          AND ("workspace_members"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete task cycles in their workspaces" ON "public"."task_cycles" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wm"
      WHERE
        (
          ("wm"."ws_id" = "task_cycles"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete task events in their workspaces" ON "public"."task_calendar_events" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          (
            "public"."tasks" "t"
            LEFT JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
          )
          LEFT JOIN "public"."workspace_members" "wm" ON (
            (
              ("wb"."ws_id" = "wm"."ws_id")
              OR (
                EXISTS (
                  SELECT
                    1
                  FROM
                    (
                      (
                        "public"."task_lists" "tl"
                        JOIN "public"."workspace_boards" "wb2" ON (("tl"."board_id" = "wb2"."id"))
                      )
                      JOIN "public"."workspace_members" "wm2" ON (("wb2"."ws_id" = "wm2"."ws_id"))
                    )
                  WHERE
                    (
                      ("tl"."id" = "t"."list_id")
                      AND ("wm2"."user_id" = "auth"."uid"())
                    )
                )
              )
            )
          )
        )
      WHERE
        (
          ("t"."id" = "task_calendar_events"."task_id")
          AND (
            ("wm"."user_id" = "auth"."uid"())
            OR ("wm"."user_id" IS NULL)
          )
        )
    )
  )
);

CREATE POLICY "Users can delete task initiatives in their workspaces" ON "public"."task_initiatives" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wm"
      WHERE
        (
          ("wm"."ws_id" = "task_initiatives"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete task labels for tasks in their workspaces" ON "public"."task_labels" FOR DELETE USING (
  (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."tasks" "t"
        WHERE
          ("t"."id" = "task_labels"."task_id")
      )
    )
    AND (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_task_labels" "tl"
        WHERE
          ("tl"."id" = "task_labels"."label_id")
      )
    )
  )
);

CREATE POLICY "Users can delete task projects in their workspaces" ON "public"."task_projects" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        "public"."workspace_members" "wm"
      WHERE
        (
          ("wm"."ws_id" = "task_projects"."ws_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete task relationships in their workspaces" ON "public"."task_relationships" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          (
            "public"."tasks" "t"
            JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
          )
          JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
        )
      WHERE
        (
          ("t"."id" = "task_relationships"."source_task_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete their own attachments" ON "public"."task_project_update_attachments" FOR DELETE USING (
  (
    ("uploaded_by" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_attachments"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Users can delete their own comments" ON "public"."task_project_update_comments" FOR DELETE USING (
  (
    ("user_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_comments"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Users can delete their own notes" ON "public"."notes" FOR DELETE USING (("creator_id" = "auth"."uid"()));

CREATE POLICY "Users can delete their own project updates" ON "public"."task_project_updates" FOR DELETE USING (
  (
    ("creator_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."task_projects" "tp"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            ("tp"."id" = "task_project_updates"."project_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Users can delete their own reactions" ON "public"."task_project_update_reactions" FOR DELETE USING (
  (
    ("user_id" = "auth"."uid"())
    AND (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_reactions"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  )
);

CREATE POLICY "Users can delete their typing indicator" ON "public"."workspace_chat_typing_indicators" FOR DELETE USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can delete transaction tags in their workspace" ON "public"."wallet_transaction_tags" FOR DELETE USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          (
            "public"."wallet_transactions" "wt"
            JOIN "public"."workspace_wallets" "ww" ON (("wt"."wallet_id" = "ww"."id"))
          )
          JOIN "public"."workspace_members" "wm" ON (("ww"."ws_id" = "wm"."ws_id"))
        )
      WHERE
        (
          (
            "wt"."id" = "wallet_transaction_tags"."transaction_id"
          )
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can delete workspace preferences" ON "public"."notification_preferences" FOR DELETE USING (
  (
    ("user_id" = "auth"."uid"())
    AND (
      (
        (
          "scope" = 'workspace' :: "public"."notification_scope"
        )
        AND (
          "ws_id" IN (
            SELECT
              "workspace_members"."ws_id"
            FROM
              "public"."workspace_members"
            WHERE
              ("workspace_members"."user_id" = "auth"."uid"())
          )
        )
      )
      OR (
        "scope" <> 'workspace' :: "public"."notification_scope"
      )
    )
  )
);

CREATE POLICY "Users can insert break types for workspaces they belong to" ON "public"."workspace_break_types" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "workspace_break_types"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can insert scheduling metadata in their workspaces" ON "public"."workspace_scheduling_metadata" FOR
INSERT
  WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can insert task events in their workspaces" ON "public"."task_calendar_events" FOR
INSERT
  WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              LEFT JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
            )
            LEFT JOIN "public"."workspace_members" "wm" ON (
              (
                ("wb"."ws_id" = "wm"."ws_id")
                OR (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      (
                        (
                          "public"."task_lists" "tl"
                          JOIN "public"."workspace_boards" "wb2" ON (("tl"."board_id" = "wb2"."id"))
                        )
                        JOIN "public"."workspace_members" "wm2" ON (("wb2"."ws_id" = "wm2"."ws_id"))
                      )
                    WHERE
                      (
                        ("tl"."id" = "t"."list_id")
                        AND ("wm2"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
            )
          )
        WHERE
          (
            ("t"."id" = "task_calendar_events"."task_id")
            AND (
              ("wm"."user_id" = "auth"."uid"())
              OR ("wm"."user_id" IS NULL)
            )
          )
      )
    )
  );

CREATE POLICY "Users can insert task labels for tasks in their workspaces" ON "public"."task_labels" FOR
INSERT
  WITH CHECK (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."tasks" "t"
          WHERE
            ("t"."id" = "task_labels"."task_id")
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_task_labels" "tl"
          WHERE
            ("tl"."id" = "task_labels"."label_id")
        )
      )
    )
  );

CREATE POLICY "Users can insert their own onboarding progress" ON "public"."onboarding_progress" FOR
INSERT
  TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can insert workspace preferences" ON "public"."notification_preferences" FOR
INSERT
  WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        (
          (
            "scope" = 'workspace' :: "public"."notification_scope"
          )
          AND (
            "ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
        )
        OR (
          "scope" <> 'workspace' :: "public"."notification_scope"
        )
      )
    )
  );

CREATE POLICY "Users can join channels in their workspace" ON "public"."workspace_chat_participants" FOR
INSERT
  WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."workspace_chat_channels" "c"
              JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
            )
          WHERE
            (
              (
                "c"."id" = "workspace_chat_participants"."channel_id"
              )
              AND ("m"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can leave channels" ON "public"."workspace_chat_participants" FOR DELETE USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can manage task cycle tasks in their workspaces" ON "public"."task_cycle_tasks" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          "public"."task_cycles" "tc"
          JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tc"."ws_id"))
        )
      WHERE
        (
          ("tc"."id" = "task_cycle_tasks"."cycle_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can manage task project initiatives in their workspaces" ON "public"."task_project_initiatives" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          "public"."task_projects" "tp"
          JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
        )
      WHERE
        (
          (
            "tp"."id" = "task_project_initiatives"."project_id"
          )
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can manage task project tasks in their workspaces" ON "public"."task_project_tasks" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          "public"."task_projects" "tp"
          JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
        )
      WHERE
        (
          ("tp"."id" = "task_project_tasks"."project_id")
          AND ("wm"."user_id" = "auth"."uid"())
        )
    )
  )
);

CREATE POLICY "Users can manage their own sessions" ON "public"."live_api_sessions" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can only create breaks for their own sessions" ON "public"."time_tracking_breaks" FOR
INSERT
  WITH CHECK (
    (
      ("created_by" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."time_tracking_sessions"
          WHERE
            (
              (
                "time_tracking_sessions"."id" = "time_tracking_breaks"."session_id"
              )
              AND (
                "time_tracking_sessions"."user_id" = "auth"."uid"()
              )
            )
        )
      )
    )
  );

CREATE POLICY "Users can only delete their own breaks" ON "public"."time_tracking_breaks" FOR DELETE USING (("created_by" = "auth"."uid"()));

CREATE POLICY "Users can only update their own breaks" ON "public"."time_tracking_breaks" FOR
UPDATE
  USING (("created_by" = "auth"."uid"()));

CREATE POLICY "Users can remove themselves as watchers" ON "public"."task_watchers" FOR DELETE USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can see their own onboarding progress" ON "public"."onboarding_progress" FOR
SELECT
  TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can see their own roles" ON "public"."platform_user_roles" FOR
SELECT
  TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can soft delete their own messages" ON "public"."workspace_chat_messages" FOR DELETE USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can update break types for workspaces they belong to" ON "public"."workspace_break_types" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "workspace_break_types"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update budgets in their workspace" ON "public"."finance_budgets" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "finance_budgets"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update habit completions in their workspaces" ON "public"."habit_completions" FOR
UPDATE
  USING (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can update habit events in their workspaces" ON "public"."habit_calendar_events" FOR
UPDATE
  USING (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can update habits in their workspaces" ON "public"."workspace_habits" FOR
UPDATE
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can update labels in their workspaces" ON "public"."workspace_task_labels" FOR
UPDATE
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can update recurring transactions in their workspace" ON "public"."recurring_transactions" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "recurring_transactions"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update scheduling metadata in their workspaces" ON "public"."workspace_scheduling_metadata" FOR
UPDATE
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can update tags in their workspace" ON "public"."transaction_tags" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "transaction_tags"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update task cycles in their workspaces" ON "public"."task_cycles" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_cycles"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update task events in their workspaces" ON "public"."task_calendar_events" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              LEFT JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
            )
            LEFT JOIN "public"."workspace_members" "wm" ON (
              (
                ("wb"."ws_id" = "wm"."ws_id")
                OR (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      (
                        (
                          "public"."task_lists" "tl"
                          JOIN "public"."workspace_boards" "wb2" ON (("tl"."board_id" = "wb2"."id"))
                        )
                        JOIN "public"."workspace_members" "wm2" ON (("wb2"."ws_id" = "wm2"."ws_id"))
                      )
                    WHERE
                      (
                        ("tl"."id" = "t"."list_id")
                        AND ("wm2"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
            )
          )
        WHERE
          (
            ("t"."id" = "task_calendar_events"."task_id")
            AND (
              ("wm"."user_id" = "auth"."uid"())
              OR ("wm"."user_id" IS NULL)
            )
          )
      )
    )
  );

CREATE POLICY "Users can update task initiatives in their workspaces" ON "public"."task_initiatives" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_initiatives"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update task projects in their workspaces" ON "public"."task_projects" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_projects"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update task relationships in their workspaces" ON "public"."task_relationships" FOR
UPDATE
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            ("t"."id" = "task_relationships"."source_task_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can update their own comments" ON "public"."task_project_update_comments" FOR
UPDATE
  USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."task_project_updates" "tpu"
                JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              (
                "tpu"."id" = "task_project_update_comments"."update_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
              AND ("tpu"."deleted_at" IS NULL)
            )
        )
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              (
                "public"."task_project_updates" "tpu"
                JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
              )
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              (
                "tpu"."id" = "task_project_update_comments"."update_id"
              )
              AND ("wm"."user_id" = "auth"."uid"())
              AND ("tpu"."deleted_at" IS NULL)
            )
        )
      )
    )
  );

CREATE POLICY "Users can update their own messages" ON "public"."workspace_chat_messages" FOR
UPDATE
  USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can update their own notes" ON "public"."notes" FOR
UPDATE
  USING (("creator_id" = "auth"."uid"()));

CREATE POLICY "Users can update their own onboarding progress" ON "public"."onboarding_progress" FOR
UPDATE
  TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Users can update their own project updates" ON "public"."task_project_updates" FOR
UPDATE
  USING (
    (
      ("creator_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."task_projects" "tp"
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              ("tp"."id" = "task_project_updates"."project_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  ) WITH CHECK (
    (
      ("creator_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."task_projects" "tp"
              JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
            )
          WHERE
            (
              ("tp"."id" = "task_project_updates"."project_id")
              AND ("wm"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can update their participant status" ON "public"."workspace_chat_participants" FOR
UPDATE
  USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        EXISTS (
          SELECT
            1
          FROM
            (
              "public"."workspace_chat_channels" "c"
              JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
            )
          WHERE
            (
              (
                "c"."id" = "workspace_chat_participants"."channel_id"
              )
              AND ("m"."user_id" = "auth"."uid"())
            )
        )
      )
    )
  );

CREATE POLICY "Users can update their typing indicator" ON "public"."workspace_chat_typing_indicators" FOR
UPDATE
  USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can update workspace preferences" ON "public"."notification_preferences" FOR
UPDATE
  USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        (
          (
            "scope" = 'workspace' :: "public"."notification_scope"
          )
          AND (
            "ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
        )
        OR (
          "scope" <> 'workspace' :: "public"."notification_scope"
        )
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      AND (
        (
          (
            "scope" = 'workspace' :: "public"."notification_scope"
          )
          AND (
            "ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
        )
        OR (
          "scope" <> 'workspace' :: "public"."notification_scope"
        )
      )
    )
  );

CREATE POLICY "Users can view attachments on project updates" ON "public"."task_project_update_attachments" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_attachments"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
            AND ("tpu"."deleted_at" IS NULL)
          )
      )
    )
  );

CREATE POLICY "Users can view break types for workspaces they belong to" ON "public"."workspace_break_types" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "workspace_break_types"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view breaks for sessions in their workspaces" ON "public"."time_tracking_breaks" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."time_tracking_sessions" "s"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "s"."ws_id"))
          )
        WHERE
          (
            ("s"."id" = "time_tracking_breaks"."session_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view budgets in their workspace" ON "public"."finance_budgets" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "finance_budgets"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view channels in their workspace" ON "public"."workspace_chat_channels" FOR
SELECT
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can view comments on project updates" ON "public"."task_project_update_comments" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_comments"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
            AND ("tpu"."deleted_at" IS NULL)
            AND (
              "task_project_update_comments"."deleted_at" IS NULL
            )
          )
      )
    )
  );

CREATE POLICY "Users can view habit completions in their workspaces" ON "public"."habit_completions" FOR
SELECT
  USING (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can view habit events in their workspaces" ON "public"."habit_calendar_events" FOR
SELECT
  USING (
    (
      "habit_id" IN (
        SELECT
          "workspace_habits"."id"
        FROM
          "public"."workspace_habits"
        WHERE
          (
            "workspace_habits"."ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
      )
    )
  );

CREATE POLICY "Users can view habits in their workspaces" ON "public"."workspace_habits" FOR
SELECT
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can view labels in their workspaces" ON "public"."workspace_task_labels" FOR
SELECT
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can view notes in their workspaces" ON "public"."notes" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "notes"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view participants in their channels" ON "public"."workspace_chat_participants" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_chat_channels" "c"
            JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
          )
        WHERE
          (
            (
              "c"."id" = "workspace_chat_participants"."channel_id"
            )
            AND ("m"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view project updates in their workspaces" ON "public"."task_project_updates" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."task_projects" "tp"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            ("tp"."id" = "task_project_updates"."project_id")
            AND ("wm"."user_id" = "auth"."uid"())
            AND ("task_project_updates"."deleted_at" IS NULL)
          )
      )
    )
  );

CREATE POLICY "Users can view reactions on project updates" ON "public"."task_project_update_reactions" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."task_project_updates" "tpu"
              JOIN "public"."task_projects" "tp" ON (("tp"."id" = "tpu"."project_id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tpu"."id" = "task_project_update_reactions"."update_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
            AND ("tpu"."deleted_at" IS NULL)
          )
      )
    )
  );

CREATE POLICY "Users can view recurring transactions in their workspace" ON "public"."recurring_transactions" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "recurring_transactions"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view scheduling metadata in their workspaces" ON "public"."workspace_scheduling_metadata" FOR
SELECT
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can view sync logs for their workspaces" ON "public"."workspace_calendar_sync_log" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "wm"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view tags in their workspace" ON "public"."transaction_tags" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members"
        WHERE
          (
            (
              "workspace_members"."ws_id" = "transaction_tags"."ws_id"
            )
            AND ("workspace_members"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task cycle tasks in their workspaces" ON "public"."task_cycle_tasks" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."task_cycles" "tc"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tc"."ws_id"))
          )
        WHERE
          (
            ("tc"."id" = "task_cycle_tasks"."cycle_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task cycles in their workspaces" ON "public"."task_cycles" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_cycles"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task events in their workspaces" ON "public"."task_calendar_events" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              LEFT JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
            )
            LEFT JOIN "public"."workspace_members" "wm" ON (
              (
                ("wb"."ws_id" = "wm"."ws_id")
                OR (
                  EXISTS (
                    SELECT
                      1
                    FROM
                      (
                        (
                          "public"."task_lists" "tl"
                          JOIN "public"."workspace_boards" "wb2" ON (("tl"."board_id" = "wb2"."id"))
                        )
                        JOIN "public"."workspace_members" "wm2" ON (("wb2"."ws_id" = "wm2"."ws_id"))
                      )
                    WHERE
                      (
                        ("tl"."id" = "t"."list_id")
                        AND ("wm2"."user_id" = "auth"."uid"())
                      )
                  )
                )
              )
            )
          )
        WHERE
          (
            ("t"."id" = "task_calendar_events"."task_id")
            AND (
              ("wm"."user_id" = "auth"."uid"())
              OR ("wm"."user_id" IS NULL)
            )
          )
      )
    )
  );

CREATE POLICY "Users can view task initiatives in their workspaces" ON "public"."task_initiatives" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_initiatives"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task labels for tasks in their workspaces" ON "public"."task_labels" FOR
SELECT
  USING (
    (
      (
        EXISTS (
          SELECT
            1
          FROM
            "public"."tasks" "t"
          WHERE
            ("t"."id" = "task_labels"."task_id")
        )
      )
      AND (
        EXISTS (
          SELECT
            1
          FROM
            "public"."workspace_task_labels" "tl"
          WHERE
            ("tl"."id" = "task_labels"."label_id")
        )
      )
    )
  );

CREATE POLICY "Users can view task project initiatives in their workspaces" ON "public"."task_project_initiatives" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."task_projects" "tp"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            (
              "tp"."id" = "task_project_initiatives"."project_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task project tasks in their workspaces" ON "public"."task_project_tasks" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."task_projects" "tp"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "tp"."ws_id"))
          )
        WHERE
          (
            ("tp"."id" = "task_project_tasks"."project_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task projects in their workspaces" ON "public"."task_projects" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            ("wm"."ws_id" = "task_projects"."ws_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task relationships in their workspaces" ON "public"."task_relationships" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              JOIN "public"."workspace_boards" "wb" ON (("t"."board_id" = "wb"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            ("t"."id" = "task_relationships"."source_task_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view task watchers for accessible tasks" ON "public"."task_watchers" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              (
                "public"."tasks" "t"
                JOIN "public"."task_lists" "tl" ON (("t"."list_id" = "tl"."id"))
              )
              JOIN "public"."workspace_boards" "wb" ON (("tl"."board_id" = "wb"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("wb"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            ("t"."id" = "task_watchers"."task_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view their own batches" ON "public"."notification_batches" FOR
SELECT
  USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        "ws_id" IN (
          SELECT
            "workspace_members"."ws_id"
          FROM
            "public"."workspace_members"
          WHERE
            ("workspace_members"."user_id" = "auth"."uid"())
        )
      )
    )
  );

CREATE POLICY "Users can view their own delivery logs" ON "public"."notification_delivery_log" FOR
SELECT
  USING (
    (
      "notification_id" IN (
        SELECT
          "notifications"."id"
        FROM
          "public"."notifications"
        WHERE
          ("notifications"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Users can view their own reminder history" ON "public"."task_reminder_sent" FOR
SELECT
  USING (("user_id" = "auth"."uid"()));

CREATE POLICY "Users can view transaction tags in their workspace" ON "public"."wallet_transaction_tags" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."wallet_transactions" "wt"
              JOIN "public"."workspace_wallets" "ww" ON (("wt"."wallet_id" = "ww"."id"))
            )
            JOIN "public"."workspace_members" "wm" ON (("ww"."ws_id" = "wm"."ws_id"))
          )
        WHERE
          (
            (
              "wt"."id" = "wallet_transaction_tags"."transaction_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view typing indicators in their channels" ON "public"."workspace_chat_typing_indicators" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_chat_channels" "c"
            JOIN "public"."workspace_members" "m" ON (("m"."ws_id" = "c"."ws_id"))
          )
        WHERE
          (
            (
              "c"."id" = "workspace_chat_typing_indicators"."channel_id"
            )
            AND ("m"."user_id" = "auth"."uid"())
          )
      )
    )
  );

CREATE POLICY "Users can view workspace preferences" ON "public"."notification_preferences" FOR
SELECT
  USING (
    (
      ("user_id" = "auth"."uid"())
      AND (
        (
          (
            "scope" = 'workspace' :: "public"."notification_scope"
          )
          AND (
            "ws_id" IN (
              SELECT
                "workspace_members"."ws_id"
              FROM
                "public"."workspace_members"
              WHERE
                ("workspace_members"."user_id" = "auth"."uid"())
            )
          )
        )
        OR (
          "scope" <> 'workspace' :: "public"."notification_scope"
        )
      )
    )
  );

CREATE POLICY "Users with audit permission can view email audit" ON "public"."email_audit" FOR
SELECT
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_workspace_audit_logs' :: "text"
    )
  );

CREATE POLICY "Users with manage_changelog permission can create changelogs" ON "public"."changelog_entries" FOR
INSERT
  WITH CHECK (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_changelog' :: "text"
    )
  );

CREATE POLICY "Users with manage_changelog permission can delete changelogs" ON "public"."changelog_entries" FOR DELETE USING (
  "public"."has_workspace_permission"(
    '00000000-0000-0000-0000-000000000000' :: "uuid",
    "auth"."uid"(),
    'manage_changelog' :: "text"
  )
);

CREATE POLICY "Users with manage_changelog permission can update changelogs" ON "public"."changelog_entries" FOR
UPDATE
  USING (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_changelog' :: "text"
    )
  );

CREATE POLICY "Users with manage_changelog permission can view all changelogs" ON "public"."changelog_entries" FOR
SELECT
  USING (
    "public"."has_workspace_permission"(
      '00000000-0000-0000-0000-000000000000' :: "uuid",
      "auth"."uid"(),
      'manage_changelog' :: "text"
    )
  );

CREATE POLICY "Workspace members can create channels" ON "public"."workspace_chat_channels" FOR
INSERT
  WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "Workspace members can read and write whiteboards" ON "public"."workspace_whiteboards" TO "authenticated" USING (
  (
    "ws_id" IN (
      SELECT
        "workspace_members"."ws_id"
      FROM
        "public"."workspace_members"
      WHERE
        ("workspace_members"."user_id" = "auth"."uid"())
    )
  )
) WITH CHECK (
  (
    "ws_id" IN (
      SELECT
        "workspace_members"."ws_id"
      FROM
        "public"."workspace_members"
      WHERE
        ("workspace_members"."user_id" = "auth"."uid"())
    )
  )
);

CREATE POLICY "Workspace members can view reminder settings" ON "public"."workspace_task_reminder_settings" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          "public"."workspace_members" "wm"
        WHERE
          (
            (
              "wm"."ws_id" = "workspace_task_reminder_settings"."ws_id"
            )
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  );

ALTER TABLE
  "public"."abuse_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_chat_members" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_chat_messages" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_chats" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_models" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_providers" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_whitelisted_domains" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."ai_whitelisted_emails" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "allow users to create orders" ON "public"."workspace_orders" FOR
INSERT
  TO "authenticated" WITH CHECK (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow users to create subscriptions" ON "public"."workspace_subscriptions" FOR
INSERT
  TO "authenticated" WITH CHECK (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow users to delete orders" ON "public"."workspace_orders" FOR DELETE TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_subscription' :: "text"
  )
);

CREATE POLICY "allow users to delete subscriptions" ON "public"."workspace_subscriptions" FOR DELETE TO "authenticated" USING (
  "public"."has_workspace_permission"(
    "ws_id",
    "auth"."uid"(),
    'manage_subscription' :: "text"
  )
);

CREATE POLICY "allow users to edit subscriptions" ON "public"."workspace_subscriptions" FOR
UPDATE
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  ) WITH CHECK (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow users to update orders" ON "public"."workspace_orders" FOR
UPDATE
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  ) WITH CHECK (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow users to view orders" ON "public"."workspace_orders" FOR
SELECT
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow users to view subscriptions" ON "public"."workspace_subscriptions" FOR
SELECT
  TO "authenticated" USING (
    "public"."has_workspace_permission"(
      "ws_id",
      "auth"."uid"(),
      'manage_subscription' :: "text"
    )
  );

CREATE POLICY "allow view for all products" ON "public"."workspace_subscription_products" FOR
SELECT
  TO "authenticated" USING (true);

ALTER TABLE
  "public"."audio_chunks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."aurora_ml_forecast" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."aurora_ml_metrics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."aurora_statistical_forecast" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."aurora_statistical_metrics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."blocked_ips" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_auth_tokens" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_connections" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_event_colors" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_event_participant_groups" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_event_platform_participants" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_event_virtual_participants" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_sync_dashboard" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."calendar_sync_states" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."changelog_entries" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."course_certificates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."course_module_completion_status" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."course_module_flashcards" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."course_module_quiz_sets" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."course_module_quizzes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."crawled_url_next_urls" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."crawled_urls" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."credit_wallets" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."cross_app_tokens" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."currencies" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "delete_own_task_user_scheduling_settings" ON "public"."task_user_scheduling_settings" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));

CREATE POLICY "delete_system_only" ON "public"."cross_app_tokens" FOR DELETE USING (false);

ALTER TABLE
  "public"."discord_guild_members" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."discord_integrations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."email_audit" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."email_blacklist" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."email_bounce_complaints" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."external_user_monthly_report_logs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."external_user_monthly_reports" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."field_types" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."finance_budgets" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."finance_invoice_products" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."finance_invoice_promotions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."finance_invoices" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."guest_users_lead_generation" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."habit_calendar_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."habit_completions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."handles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_checkup_vital_groups" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_checkup_vitals" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_checkups" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_diagnoses" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_vital_groups" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."healthcare_vitals" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "insert_own_task_user_scheduling_settings" ON "public"."task_user_scheduling_settings" FOR
INSERT
  TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));

CREATE POLICY "insert_system_only" ON "public"."cross_app_tokens" FOR
INSERT
  WITH CHECK (false);

ALTER TABLE
  "public"."internal_email_api_keys" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."internal_emails" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_batch_products" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_batches" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_products" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_suppliers" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_units" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."inventory_warehouses" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."link_analytics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."live_api_sessions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."meet_together_guest_timeblocks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."meet_together_guests" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."meet_together_plans" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."meet_together_user_timeblocks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notification_batches" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notification_delivery_log" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notification_email_config" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notification_preferences" ENABLE ROW LEVEL SECURITY;

ALTER TABLE
  "public"."notifications" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notifications_delete_policy" ON "public"."notifications" FOR DELETE USING (
  (
    ("user_id" = "auth"."uid"())
    OR (
      ("email" IS NOT NULL)
      AND (
        "email" = "public"."get_user_email"("auth"."uid"())
      )
    )
  )
);

CREATE POLICY "notifications_insert_policy" ON "public"."notifications" FOR
INSERT
  WITH CHECK (false);

CREATE POLICY "notifications_select_policy" ON "public"."notifications" FOR
SELECT
  USING (
    (
      ("user_id" = "auth"."uid"())
      OR (
        ("email" IS NOT NULL)
        AND (
          "email" = "public"."get_user_email"("auth"."uid"())
        )
      )
      OR (
        (
          "scope" = 'system' :: "public"."notification_scope"
        )
        AND (
          ("user_id" = "auth"."uid"())
          OR (
            ("email" IS NOT NULL)
            AND (
              "email" = "public"."get_user_email"("auth"."uid"())
            )
          )
        )
      )
    )
  );

CREATE POLICY "notifications_update_policy" ON "public"."notifications" FOR
UPDATE
  USING (
    (
      ("user_id" = "auth"."uid"())
      OR (
        ("email" IS NOT NULL)
        AND (
          "email" = "public"."get_user_email"("auth"."uid"())
        )
      )
    )
  ) WITH CHECK (
    (
      ("user_id" = "auth"."uid"())
      OR (
        ("email" IS NOT NULL)
        AND (
          "email" = "public"."get_user_email"("auth"."uid"())
        )
      )
    )
  );

CREATE POLICY "select_own_task_user_scheduling_settings" ON "public"."task_user_scheduling_settings" FOR
SELECT
  TO "authenticated" USING (("user_id" = "auth"."uid"()));

CREATE POLICY "select_own_tokens" ON "public"."cross_app_tokens" FOR
SELECT
  USING (("auth"."uid"() = "user_id"));

CREATE POLICY "task_history_delete_policy" ON "public"."task_history" FOR DELETE USING (false);

CREATE POLICY "task_history_insert_policy" ON "public"."task_history" FOR
INSERT
  WITH CHECK (false);

CREATE POLICY "task_history_select_policy" ON "public"."task_history" FOR
SELECT
  USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            (
              "public"."tasks" "t"
              JOIN "public"."task_lists" "tl" ON (("t"."list_id" = "tl"."id"))
            )
            JOIN "public"."workspace_boards" "wb" ON (("tl"."board_id" = "wb"."id"))
          )
        WHERE
          (
            ("t"."id" = "task_history"."task_id")
            AND ("t"."deleted_at" IS NULL)
            AND (
              (
                EXISTS (
                  SELECT
                    1
                  FROM
                    "public"."workspace_members" "wm"
                  WHERE
                    (
                      ("wm"."ws_id" = "wb"."ws_id")
                      AND ("wm"."user_id" = "auth"."uid"())
                    )
                )
              )
              OR (
                EXISTS (
                  SELECT
                    1
                  FROM
                    (
                      "public"."workspace_role_members" "wrm"
                      JOIN "public"."workspace_roles" "wr" ON (("wrm"."role_id" = "wr"."id"))
                    )
                  WHERE
                    (
                      ("wr"."ws_id" = "wb"."ws_id")
                      AND ("wrm"."user_id" = "auth"."uid"())
                    )
                )
              )
              OR (
                EXISTS (
                  SELECT
                    1
                  FROM
                    "public"."workspaces" "w"
                  WHERE
                    (
                      ("w"."id" = "wb"."ws_id")
                      AND ("w"."creator_id" = "auth"."uid"())
                    )
                )
              )
            )
          )
      )
    )
  );

CREATE POLICY "workspace_calendars_delete" ON "public"."workspace_calendars" FOR DELETE USING (
  (
    ("is_system" = false)
    AND (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  )
);

CREATE POLICY "workspace_calendars_insert" ON "public"."workspace_calendars" FOR
INSERT
  WITH CHECK (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "workspace_calendars_select" ON "public"."workspace_calendars" FOR
SELECT
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "workspace_calendars_update" ON "public"."workspace_calendars" FOR
UPDATE
  USING (
    (
      "ws_id" IN (
        SELECT
          "workspace_members"."ws_id"
        FROM
          "public"."workspace_members"
        WHERE
          ("workspace_members"."user_id" = "auth"."uid"())
      )
    )
  );

CREATE POLICY "workspace_members_can_delete_transactions" ON "public"."wallet_transactions" FOR DELETE TO "authenticated" USING (
  (
    EXISTS (
      SELECT
        1
      FROM
        (
          "public"."workspace_wallets" "ww"
          JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "ww"."ws_id"))
        )
      WHERE
        (
          ("ww"."id" = "wallet_transactions"."wallet_id")
          AND ("wm"."user_id" = "auth"."uid"())
          AND (
            (
              NOT (
                "wallet_transactions"."is_amount_confidential"
                OR "wallet_transactions"."is_description_confidential"
                OR "wallet_transactions"."is_category_confidential"
              )
            )
            OR "public"."has_workspace_permission"(
              "ww"."ws_id",
              "auth"."uid"(),
              'delete_confidential_transactions' :: "text"
            )
          )
        )
    )
  )
);

CREATE POLICY "workspace_members_can_insert_transactions" ON "public"."wallet_transactions" FOR
INSERT
  TO "authenticated" WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_wallets" "ww"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "ww"."ws_id"))
          )
        WHERE
          (
            ("ww"."id" = "wallet_transactions"."wallet_id")
            AND ("wm"."user_id" = "auth"."uid"())
            AND (
              (
                NOT (
                  "wallet_transactions"."is_amount_confidential"
                  OR "wallet_transactions"."is_description_confidential"
                  OR "wallet_transactions"."is_category_confidential"
                )
              )
              OR "public"."has_workspace_permission"(
                "ww"."ws_id",
                "auth"."uid"(),
                'create_confidential_transactions' :: "text"
              )
            )
          )
      )
    )
  );

CREATE POLICY "workspace_members_can_select_transactions" ON "public"."wallet_transactions" FOR
SELECT
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_wallets" "ww"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "ww"."ws_id"))
          )
        WHERE
          (
            ("ww"."id" = "wallet_transactions"."wallet_id")
            AND ("wm"."user_id" = "auth"."uid"())
            AND (
              (
                (
                  NOT "wallet_transactions"."is_amount_confidential"
                )
                AND (
                  NOT "wallet_transactions"."is_description_confidential"
                )
                AND (
                  NOT "wallet_transactions"."is_category_confidential"
                )
              )
              OR (
                (
                  (
                    NOT "wallet_transactions"."is_amount_confidential"
                  )
                  OR "public"."has_workspace_permission"(
                    "ww"."ws_id",
                    "auth"."uid"(),
                    'view_confidential_amount' :: "text"
                  )
                )
                AND (
                  (
                    NOT "wallet_transactions"."is_description_confidential"
                  )
                  OR "public"."has_workspace_permission"(
                    "ww"."ws_id",
                    "auth"."uid"(),
                    'view_confidential_description' :: "text"
                  )
                )
                AND (
                  (
                    NOT "wallet_transactions"."is_category_confidential"
                  )
                  OR "public"."has_workspace_permission"(
                    "ww"."ws_id",
                    "auth"."uid"(),
                    'view_confidential_category' :: "text"
                  )
                )
              )
            )
          )
      )
    )
  );

CREATE POLICY "workspace_members_can_update_transactions" ON "public"."wallet_transactions" FOR
UPDATE
  TO "authenticated" USING (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_wallets" "ww"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "ww"."ws_id"))
          )
        WHERE
          (
            ("ww"."id" = "wallet_transactions"."wallet_id")
            AND ("wm"."user_id" = "auth"."uid"())
          )
      )
    )
  ) WITH CHECK (
    (
      EXISTS (
        SELECT
          1
        FROM
          (
            "public"."workspace_wallets" "ww"
            JOIN "public"."workspace_members" "wm" ON (("wm"."ws_id" = "ww"."ws_id"))
          )
        WHERE
          (
            ("ww"."id" = "wallet_transactions"."wallet_id")
            AND ("wm"."user_id" = "auth"."uid"())
            AND (
              (
                NOT (
                  "wallet_transactions"."is_amount_confidential"
                  OR "wallet_transactions"."is_description_confidential"
                  OR "wallet_transactions"."is_category_confidential"
                )
              )
              OR "public"."has_workspace_permission"(
                "ww"."ws_id",
                "auth"."uid"(),
                'update_confidential_transactions' :: "text"
              )
            )
          )
      )
    )
  );