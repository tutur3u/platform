name: Detect Changes for Apps
on:
  push:
    branches-ignore:
    - 'main'
    - 'production'
  workflow_dispatch:


jobs:
  detect-changes:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Check for relevant changes
      id: check-changes
      run: |
        # Get changed files compared to main branch
        CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
        
        # Check if any changes are in apps/* or packages/*
        RELEVANT_CHANGES=$(echo "$CHANGED_FILES" | grep -E '^(apps|packages)/' || true)
        
        if [ -z "$RELEVANT_CHANGES" ]; then
          echo "ℹ️  No changes detected in apps/* or packages/* directories"
          echo "✅ Workflow completed successfully - no apps need to be built"
          echo "has_relevant_changes=false" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "📋 Found relevant changes in:"
          echo "$RELEVANT_CHANGES"
          echo "has_relevant_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Setup bun
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      run: bun install

    - name: Install jq and fd
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      run: |
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          sudo apt-get update
          sudo apt-get install -y jq
        else
          echo "jq is already available"
        fi

        if ! command -v fd &> /dev/null; then
          echo "Installing fd..."
          sudo apt-get install -y fd-find
          # Create symlink for fd
          sudo ln -sf $(which fdfind) /usr/local/bin/fd 2>/dev/null || true
        else
          echo "fd is already available"
        fi

    - name: Detect changes using Turbo
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      id: changes
      run: |
        set -e  # Exit on any error

        # Ensure we have the latest main branch
        CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
        CHANGED_COUNT=$(echo "$CHANGED_FILES" | wc -l)
        echo "Changed files found: $CHANGED_COUNT"

        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "ℹ️  No changes detected compared to main branch"
          echo "   This workflow will continue but no apps will be built"
        fi

        # Use Turbo to find affected packages for each app
        APPS_TO_BUILD=()

        # Get all apps from workspace - try multiple approaches
        echo "Getting apps from workspace..."

        # Method 1: Try turbo list with better filtering
        APPS=""
        echo "Attempting to use Turbo list..."
        if bun run turbo list --filter="apps/*" > /tmp/turbo_output 2>&1; then
          # Filter for actual app packages and clean up the output
          POTENTIAL_APPS=$(cat /tmp/turbo_output | grep "^@tuturuuu/[^/]*$" | grep -v "#build" | tr -d ' ' | sort -u)

          # Check if we actually found any apps (not just that the command succeeded)
          if [ -n "$POTENTIAL_APPS" ]; then
            APPS="$POTENTIAL_APPS"
            echo "✅ Turbo list successful, found apps: $APPS"
          else
            echo "⚠️  Turbo list succeeded but found no apps (likely due to lockfile issues)"
            echo "🔄 Falling back to directory scanning method..."
            # Method 2: Direct directory scanning
            if command -v fd &> /dev/null; then
              APPS="$(fd -t f package.json apps \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            else
              echo "fd not available, using find..."
              APPS="$(find apps -name package.json -type f \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            fi
            echo "✅ Directory scan successful, found apps: $APPS"
          fi
        else
          echo "⚠️  Turbo list failed (likely due to Tailwind CSS v4 WASM dependencies)"
          echo "Turbo error output:"
          cat /tmp/turbo_output | head -10
          echo "..."
          
          echo "🔄 Falling back to directory scanning method..."
          # Method 2: Direct directory scanning
          if command -v fd &> /dev/null; then
            APPS="$(fd -t f package.json apps \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          else
            echo "fd not available, using find..."
            APPS="$(find apps -name package.json -type f \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          fi
          echo "✅ Directory scan successful, found apps: $APPS"
        fi

        if [ -z "$APPS" ]; then
          echo "❌ Could not discover apps via turbo or scan. Exiting to avoid stale deployments."
          exit 1
        fi

        echo "Processing apps: $APPS"

        for app in $APPS; do
          # Check if app directory changed
          # Extract the app name without the @tuturuuu/ prefix
          app_name=${app#@tuturuuu/}
          app_path="apps/$app_name"
          
          echo "Checking app: $app ($app_path)"
          
          if echo "$CHANGED_FILES" | grep -q "^$app_path/"; then
            echo "✅ App $app has direct changes, adding to build list"
            APPS_TO_BUILD+=("$app")
            continue
          fi
          
          # Try to use Turbo to find dependencies, fallback to package.json scanning
          AFFECTED=""
          if bun run turbo run build --filter="$app" --dry-run > /tmp/turbo_build_output 2>&1; then
            # Clean up the output to only get package names, not paths or build targets
            # The output format is: @tuturuuu/package-name#build
            POTENTIAL_AFFECTED=$(cat /tmp/turbo_build_output | grep "^@tuturuuu/[^/]*#build$" | sed 's|#build||' | tr -d ' ' | sort -u)

            # Check if we actually found dependencies (not just that the command succeeded)
            if [ -n "$POTENTIAL_AFFECTED" ]; then
              AFFECTED="$POTENTIAL_AFFECTED"
              echo "✅ Turbo build analysis for $app successful, found dependencies: $AFFECTED"
            else
              echo "⚠️  Turbo build analysis for $app succeeded but found no dependencies, using package.json fallback..."
              # Fallback: read dependencies directly from package.json
              if [ -f "apps/$app_name/package.json" ]; then
                AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
                echo "📦 Package.json fallback for $app found: $AFFECTED"
              fi
            fi
          else
            echo "⚠️  Turbo build analysis for $app failed, using package.json fallback..."
            # Fallback: read dependencies directly from package.json
            if [ -f "apps/$app_name/package.json" ]; then
              AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
              echo "📦 Package.json fallback for $app found: $AFFECTED"
            fi
          fi
          
          # Check if any of the affected packages changed
          for pkg in $AFFECTED; do
            pkg_path=""
            if [[ $pkg == @tuturuuu/* ]]; then
              pkg_name=${pkg#@tuturuuu/}
              # Check if it's an app or package
              if [ -d "apps/$pkg_name" ]; then
                pkg_path="apps/$pkg_name"
              elif [ -d "packages/$pkg_name" ]; then
                pkg_path="packages/$pkg_name"
              fi
            fi
            
            if [ -n "$pkg_path" ] && echo "$CHANGED_FILES" | grep -q "^$pkg_path/"; then
              echo "🔗 Package $pkg ($pkg_path) changed, adding app $app to build list"
              APPS_TO_BUILD+=("$app")
              break
            fi
          done
        done

        # Remove duplicates and create matrix
        UNIQUE_APPS=$(printf '%s\n' "${APPS_TO_BUILD[@]}" | sort -u | grep -v '^$')

        # Create matrix safely, handle empty case
        if [ -n "$UNIQUE_APPS" ]; then
          # Ensure jq is available and handle potential errors
          if command -v jq >/dev/null 2>&1; then
            MATRIX=$(echo "$UNIQUE_APPS" | jq -R -s -c 'split("\n")[:-1] | map({app: .})' 2>/dev/null || echo "[]")
            if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
              echo "⚠️  jq matrix creation failed, using fallback format"
              MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            fi
          else
            echo "⚠️  jq not available, using fallback matrix format"
            MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
          fi
        else
          MATRIX="[]"
        fi

        # Save results to files for artifacts
        echo "$UNIQUE_APPS" > apps-to-build.txt
        echo "$MATRIX" > matrix.json

        echo "=== Information ==="
        echo "Changed files:"
        echo "$CHANGED_FILES" | head -20
        echo "..."
        echo ""
        echo "All apps found:"
        echo "$APPS"
        echo ""
        echo "Apps to build: $UNIQUE_APPS"
        echo "Matrix: $MATRIX"

        # Validate outputs
        if [ -z "$UNIQUE_APPS" ]; then
          echo "ℹ️  No apps require building based on detected changes"
          echo "   This is normal when changes don't affect any applications"
        else
          echo "✅ Successfully detected apps to build: $UNIQUE_APPS"
        fi

        if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
          echo "⚠️  Warning: Matrix is empty but apps were detected"
        else
          echo "✅ Matrix created successfully: $MATRIX"
        fi

        # Provide final summary
        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "🏁 Workflow completed: No changes to process"
        elif [ -z "$UNIQUE_APPS" ]; then
          echo "🏁 Workflow completed: Changes detected but no apps affected"
        else
          echo "🏁 Workflow completed: Ready to build $UNIQUE_APPS"
        fi

        # Always exit successfully to avoid workflow failures
        exit 0

    - name: Upload apps-to-build artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: apps-to-build
        path: apps-to-build.txt
        retention-days: 1

    - name: Upload matrix artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: matrix
        path: matrix.json
        retention-days: 1

    - name: Create empty artifacts for no changes
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      run: |
        echo "" > apps-to-build.txt
        echo "[]" > matrix.json

    - name: Upload empty apps-to-build artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: apps-to-build
        path: apps-to-build.txt
        retention-days: 1

    - name: Upload empty matrix artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: matrix
        path: matrix.json
        retention-days: 1

    - name: Trigger deployment workflows for affected apps
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      run: |
        # Read the apps that need to be built
        if [ -f "apps-to-build.txt" ]; then
          APPS_TO_BUILD=$(cat apps-to-build.txt | grep -v '^$' | sort -u)
          
          if [ -n "$APPS_TO_BUILD" ]; then
            echo "🚀 Triggering deployment workflows for affected apps..."
            
            for app in $APPS_TO_BUILD; do
              # Extract app name from @tuturuuu/app-name format
              app_name=${app#@tuturuuu/}
              
              echo "📦 Processing app: $app_name"
              
              # Map app names to their corresponding workflow files
              case "$app_name" in
                "calendar")
                  workflow_file="vercel-preview-calendar.yaml"
                  ;;
                "finance")
                  workflow_file="vercel-preview-finance.yaml"
                  ;;
                "nova")
                  workflow_file="vercel-preview-nova.yaml"
                  ;;
                "rewise")
                  workflow_file="vercel-preview-rewise.yaml"
                  ;;
                "shortener")
                  workflow_file="vercel-preview-shortener.yaml"
                  ;;
                "tudo")
                  workflow_file="vercel-preview-todo.yaml"
                  ;;
                "tumeet")
                  workflow_file="vercel-preview-tumeet.yaml"
                  ;;
                "web"|"platform")
                  workflow_file="vercel-preview-platform.yaml"
                  ;;
                "external")
                  # External app might not have a preview workflow
                  echo "⚠️  External app detected but no preview workflow configured"
                  continue
                  ;;
                "playground")
                  # Playground might not need deployment
                  echo "⚠️  Playground app detected but no preview workflow configured"
                  continue
                  ;;
                *)
                  echo "⚠️  Unknown app: $app_name, skipping workflow trigger"
                  continue
                  ;;
              esac
              
              echo "🔄 Triggering workflow: $workflow_file for app: $app_name"
              
              # Method 1: Use GitHub API to trigger the workflow directly
              if curl -L \
                -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/actions/workflows/$workflow_file/dispatches" \
                -d "{\"ref\":\"${{ github.ref }}\",\"inputs\":{\"force_deploy\":\"false\"}}" \
                --fail --silent --show-error; then
                echo "✅ Successfully triggered $workflow_file via API"
              else
                echo "❌ Failed to trigger $workflow_file via API"
                
                # Method 2: Try repository dispatch as fallback
                echo "🔄 Attempting repository dispatch for $app_name..."
                if curl -L \
                  -X POST \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${{ github.repository }}/dispatches" \
                  -d "{\"event_type\":\"deploy-app\",\"client_payload\":{\"app\":\"$app_name\",\"ref\":\"${{ github.ref }}\",\"force_deploy\":false}}" \
                  --fail --silent --show-error; then
                  echo "✅ Successfully sent repository dispatch for $app_name"
                else
                  echo "❌ Repository dispatch also failed for $app_name"
                fi
              fi
              
              # Small delay between API calls to avoid rate limiting
              sleep 1
            done
            
            echo "✅ Finished triggering deployment workflows"
          else
            echo "ℹ️  No apps found in apps-to-build.txt"
          fi
        else
          echo "ℹ️  apps-to-build.txt not found, no workflows to trigger"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
