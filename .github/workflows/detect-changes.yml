name: Detect Changes for Apps
on:
  push:
    branches-ignore:
    - 'main'
    - 'production'
  workflow_dispatch:


jobs:
  detect-changes:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Check for relevant changes
      id: check-changes
      run: |
        # Get changed files compared to main branch
        CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
        
        # Check if any changes are in apps/* or packages/*
        RELEVANT_CHANGES=$(echo "$CHANGED_FILES" | grep -E '^(apps|packages)/' || true)
        
        if [ -z "$RELEVANT_CHANGES" ]; then
          echo "â„¹ï¸  No changes detected in apps/* or packages/* directories"
          echo "âœ… Workflow completed successfully - no apps need to be built"
          echo "has_relevant_changes=false" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "ðŸ“‹ Found relevant changes in:"
          echo "$RELEVANT_CHANGES"
          echo "has_relevant_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Setup bun
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      run: bun install

    - name: Install jq and fd
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      run: |
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          sudo apt-get update
          sudo apt-get install -y jq
        else
          echo "jq is already available"
        fi

        if ! command -v fd &> /dev/null; then
          echo "Installing fd..."
          sudo apt-get install -y fd-find
          # Create symlink for fd
          sudo ln -sf $(which fdfind) /usr/local/bin/fd 2>/dev/null || true
        else
          echo "fd is already available"
        fi

    - name: Detect changes using Turbo
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      id: changes
      run: |
        set -e  # Exit on any error

        # Ensure we have the latest main branch
        CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
        CHANGED_COUNT=$(echo "$CHANGED_FILES" | wc -l)
        echo "Changed files found: $CHANGED_COUNT"

        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "â„¹ï¸  No changes detected compared to main branch"
          echo "   This workflow will continue but no apps will be built"
        fi

        # Use Turbo to find affected packages for each app
        APPS_TO_BUILD=()

        # Get all apps from workspace - try multiple approaches
        echo "Getting apps from workspace..."

        # Method 1: Try turbo list with better filtering
        APPS=""
        echo "Attempting to use Turbo list..."
        if bun run turbo list --filter="apps/*" > /tmp/turbo_output 2>&1; then
          # Filter for actual app packages and clean up the output
          POTENTIAL_APPS=$(cat /tmp/turbo_output | grep "^@tuturuuu/[^/]*$" | grep -v "#build" | tr -d ' ' | sort -u)

          # Check if we actually found any apps (not just that the command succeeded)
          if [ -n "$POTENTIAL_APPS" ]; then
            APPS="$POTENTIAL_APPS"
            echo "âœ… Turbo list successful, found apps: $APPS"
          else
            echo "âš ï¸  Turbo list succeeded but found no apps (likely due to lockfile issues)"
            echo "ðŸ”„ Falling back to directory scanning method..."
            # Method 2: Direct directory scanning
            if command -v fd &> /dev/null; then
              APPS="$(fd -t f package.json apps \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            else
              echo "fd not available, using find..."
              APPS="$(find apps -name package.json -type f \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            fi
            echo "âœ… Directory scan successful, found apps: $APPS"
          fi
        else
          echo "âš ï¸  Turbo list failed (likely due to Tailwind CSS v4 WASM dependencies)"
          echo "Turbo error output:"
          cat /tmp/turbo_output | head -10
          echo "..."
          
          echo "ðŸ”„ Falling back to directory scanning method..."
          # Method 2: Direct directory scanning
          if command -v fd &> /dev/null; then
            APPS="$(fd -t f package.json apps \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          else
            echo "fd not available, using find..."
            APPS="$(find apps -name package.json -type f \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          fi
          echo "âœ… Directory scan successful, found apps: $APPS"
        fi

        if [ -z "$APPS" ]; then
          echo "âŒ Could not discover apps via turbo or scan. Exiting to avoid stale deployments."
          exit 1
        fi

        echo "Processing apps: $APPS"

        for app in $APPS; do
          # Check if app directory changed
          # Extract the app name without the @tuturuuu/ prefix
          app_name=${app#@tuturuuu/}
          app_path="apps/$app_name"
          
          echo "Checking app: $app ($app_path)"
          
          if echo "$CHANGED_FILES" | grep -q "^$app_path/"; then
            echo "âœ… App $app has direct changes, adding to build list"
            APPS_TO_BUILD+=("$app")
            continue
          fi
          
          # Try to use Turbo to find dependencies, fallback to package.json scanning
          AFFECTED=""
          if bun run turbo run build --filter="$app" --dry-run > /tmp/turbo_build_output 2>&1; then
            # Clean up the output to only get package names, not paths or build targets
            # The output format is: @tuturuuu/package-name#build
            POTENTIAL_AFFECTED=$(cat /tmp/turbo_build_output | grep "^@tuturuuu/[^/]*#build$" | sed 's|#build||' | tr -d ' ' | sort -u)

            # Check if we actually found dependencies (not just that the command succeeded)
            if [ -n "$POTENTIAL_AFFECTED" ]; then
              AFFECTED="$POTENTIAL_AFFECTED"
              echo "âœ… Turbo build analysis for $app successful, found dependencies: $AFFECTED"
            else
              echo "âš ï¸  Turbo build analysis for $app succeeded but found no dependencies, using package.json fallback..."
              # Fallback: read dependencies directly from package.json
              if [ -f "apps/$app_name/package.json" ]; then
                AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
                echo "ðŸ“¦ Package.json fallback for $app found: $AFFECTED"
              fi
            fi
          else
            echo "âš ï¸  Turbo build analysis for $app failed, using package.json fallback..."
            # Fallback: read dependencies directly from package.json
            if [ -f "apps/$app_name/package.json" ]; then
              AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
              echo "ðŸ“¦ Package.json fallback for $app found: $AFFECTED"
            fi
          fi
          
          # Check if any of the affected packages changed
          for pkg in $AFFECTED; do
            pkg_path=""
            if [[ $pkg == @tuturuuu/* ]]; then
              pkg_name=${pkg#@tuturuuu/}
              # Check if it's an app or package
              if [ -d "apps/$pkg_name" ]; then
                pkg_path="apps/$pkg_name"
              elif [ -d "packages/$pkg_name" ]; then
                pkg_path="packages/$pkg_name"
              fi
            fi
            
            if [ -n "$pkg_path" ] && echo "$CHANGED_FILES" | grep -q "^$pkg_path/"; then
              echo "ðŸ”— Package $pkg ($pkg_path) changed, adding app $app to build list"
              APPS_TO_BUILD+=("$app")
              break
            fi
          done
        done

        # Remove duplicates and create matrix
        UNIQUE_APPS=$(printf '%s\n' "${APPS_TO_BUILD[@]}" | sort -u | grep -v '^$')

        # Create matrix safely, handle empty case
        if [ -n "$UNIQUE_APPS" ]; then
          # Ensure jq is available and handle potential errors
          if command -v jq >/dev/null 2>&1; then
            MATRIX=$(echo "$UNIQUE_APPS" | jq -R -s -c 'split("\n")[:-1] | map({app: .})' 2>/dev/null || echo "[]")
            if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
              echo "âš ï¸  jq matrix creation failed, using fallback format"
              MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            fi
          else
            echo "âš ï¸  jq not available, using fallback matrix format"
            MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
          fi
        else
          MATRIX="[]"
        fi

        # Save results to files for artifacts
        echo "$UNIQUE_APPS" > apps-to-build.txt
        echo "$MATRIX" > matrix.json

        echo "=== Information ==="
        echo "Changed files:"
        echo "$CHANGED_FILES" | head -20
        echo "..."
        echo ""
        echo "All apps found:"
        echo "$APPS"
        echo ""
        echo "Apps to build: $UNIQUE_APPS"
        echo "Matrix: $MATRIX"

        # Validate outputs
        if [ -z "$UNIQUE_APPS" ]; then
          echo "â„¹ï¸  No apps require building based on detected changes"
          echo "   This is normal when changes don't affect any applications"
        else
          echo "âœ… Successfully detected apps to build: $UNIQUE_APPS"
        fi

        if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
          echo "âš ï¸  Warning: Matrix is empty but apps were detected"
        else
          echo "âœ… Matrix created successfully: $MATRIX"
        fi

        # Provide final summary
        if [ "$CHANGED_COUNT" -eq 0 ]; then
          echo "ðŸ Workflow completed: No changes to process"
        elif [ -z "$UNIQUE_APPS" ]; then
          echo "ðŸ Workflow completed: Changes detected but no apps affected"
        else
          echo "ðŸ Workflow completed: Ready to build $UNIQUE_APPS"
        fi

        # Always exit successfully to avoid workflow failures
        exit 0

    - name: Upload apps-to-build artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: apps-to-build
        path: apps-to-build.txt
        retention-days: 1

    - name: Upload matrix artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: matrix
        path: matrix.json
        retention-days: 1

    - name: Create empty artifacts for no changes
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      run: |
        echo "" > apps-to-build.txt
        echo "[]" > matrix.json

    - name: Upload empty apps-to-build artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: apps-to-build
        path: apps-to-build.txt
        retention-days: 1

    - name: Upload empty matrix artifact
      if: steps.check-changes.outputs.has_relevant_changes == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: matrix
        path: matrix.json
        retention-days: 1
