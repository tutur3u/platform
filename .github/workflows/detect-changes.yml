name: Detect Changes for Apps
on:
  push:
    branches-ignore:
    - 'main'
    - 'production'
  pull_request:
    types: [ opened, synchronize, reopened ]
    paths:
    - 'apps/**'
    - 'packages/**'
  workflow_dispatch:


jobs:
  detect-changes:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Setup bun
      uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      run: bun install

    - name: Install jq and fd
      run: |
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          sudo apt-get update
          sudo apt-get install -y jq
        else
          echo "jq is already available"
        fi

        if ! command -v fd &> /dev/null; then
          echo "Installing fd..."
          sudo apt-get install -y fd-find
          # Create symlink for fd
          sudo ln -sf $(which fdfind) /usr/local/bin/fd 2>/dev/null || true
        else
          echo "fd is already available"
        fi

    - name: Detect changes using Turbo
      id: changes
      run: |
        set -e  # Exit on any error

        # Ensure we have the latest main branch
        CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
        echo "Changed files found: $(echo "$CHANGED_FILES" | wc -l)"

        # Use Turbo to find affected packages for each app
        APPS_TO_BUILD=()

        # Get all apps from workspace - try multiple approaches
        echo "Getting apps from workspace..."

        # Method 1: Try turbo list with better filtering
        APPS=""
        echo "Attempting to use Turbo list..."
        if bun run turbo list --filter="apps/*" > /tmp/turbo_output 2>&1; then
          # Filter for actual app packages and clean up the output
          POTENTIAL_APPS=$(cat /tmp/turbo_output | grep "^@tuturuuu/" | grep -v "#build" | tr -d ' ' | sort -u)
          
          # Debug: show raw turbo output
          echo "Raw turbo list output:"
          cat /tmp/turbo_output | head -20
          echo "..."
          
          # Check if we actually found any apps (not just that the command succeeded)
          if [ -n "$POTENTIAL_APPS" ]; then
            APPS="$POTENTIAL_APPS"
            echo "‚úÖ Turbo list successful, found apps: $APPS"
          else
            echo "‚ö†Ô∏è  Turbo list succeeded but found no apps (likely due to lockfile issues)"
            echo "üîÑ Falling back to directory scanning method..."
            # Method 2: Direct directory scanning
            if command -v fd &> /dev/null; then
              APPS="$(fd -t f package.json apps \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            else
              echo "fd not available, using find..."
              APPS="$(find apps -name package.json -type f \
                | while read -r f; do \
                    jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                  done \
                | sort -u)"
            fi
            echo "‚úÖ Directory scan successful, found apps: $APPS"
          fi
        else
          echo "‚ö†Ô∏è  Turbo list failed (likely due to Tailwind CSS v4 WASM dependencies)"
          echo "Turbo error output:"
          cat /tmp/turbo_output | head -10
          echo "..."
          
          echo "üîÑ Falling back to directory scanning method..."
          # Method 2: Direct directory scanning
          if command -v fd &> /dev/null; then
            APPS="$(fd -t f package.json apps \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          else
            echo "fd not available, using find..."
            APPS="$(find apps -name package.json -type f \
              | while read -r f; do \
                  jq -r 'select(.name|startswith("@tuturuuu/")) | .name' "$f" 2>/dev/null || true; \
                done \
              | sort -u)"
          fi
          echo "‚úÖ Directory scan successful, found apps: $APPS"
        fi

        if [ -z "$APPS" ]; then
          echo "‚ùå Could not discover apps via turbo or scan. Exiting to avoid stale deployments."
          exit 1
        fi

        echo "Processing apps: $APPS"

        for app in $APPS; do
          # Check if app directory changed
          # Extract the app name without the @tuturuuu/ prefix
          app_name=${app#@tuturuuu/}
          app_path="apps/$app_name"
          
          echo "Checking app: $app ($app_path)"
          
          if echo "$CHANGED_FILES" | grep -q "^$app_path/"; then
            echo "‚úÖ App $app has direct changes, adding to build list"
            APPS_TO_BUILD+=("$app")
            continue
          fi
          
          # Try to use Turbo to find dependencies, fallback to package.json scanning
          AFFECTED=""
          if bun run turbo run build --filter="$app" --dry-run > /tmp/turbo_build_output 2>&1; then
            # Clean up the output to only get package names, not paths or build targets
            # The output format is: @tuturuuu/package-name#build
            POTENTIAL_AFFECTED=$(cat /tmp/turbo_build_output | grep "^@tuturuuu/" | sed 's|#build||' | tr -d ' ' | sort -u)
            
            # Debug: show raw build output for first few lines
            echo "Raw turbo build output (first 10 lines):"
            cat /tmp/turbo_build_output | head -10
            echo "..."
            
            # Check if we actually found dependencies (not just that the command succeeded)
            if [ -n "$POTENTIAL_AFFECTED" ]; then
              AFFECTED="$POTENTIAL_AFFECTED"
              echo "‚úÖ Turbo build analysis for $app successful, found dependencies: $AFFECTED"
            else
              echo "‚ö†Ô∏è  Turbo build analysis for $app succeeded but found no dependencies, using package.json fallback..."
              # Fallback: read dependencies directly from package.json
              if [ -f "apps/$app_name/package.json" ]; then
                AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
                echo "üì¶ Package.json fallback for $app found: $AFFECTED"
              fi
            fi
          else
            echo "‚ö†Ô∏è  Turbo build analysis for $app failed, using package.json fallback..."
            # Fallback: read dependencies directly from package.json
            if [ -f "apps/$app_name/package.json" ]; then
              AFFECTED=$(grep -o '"@tuturuuu/[^"]*"' "apps/$app_name/package.json" | tr -d '"')
              echo "üì¶ Package.json fallback for $app found: $AFFECTED"
            fi
          fi
          
          # Check if any of the affected packages changed
          for pkg in $AFFECTED; do
            pkg_path=""
            if [[ $pkg == @tuturuuu/* ]]; then
              pkg_name=${pkg#@tuturuuu/}
              # Check if it's an app or package
              if [ -d "apps/$pkg_name" ]; then
                pkg_path="apps/$pkg_name"
              elif [ -d "packages/$pkg_name" ]; then
                pkg_path="packages/$pkg_name"
              fi
            fi
            
            if [ -n "$pkg_path" ] && echo "$CHANGED_FILES" | grep -q "^$pkg_path/"; then
              echo "üîó Package $pkg ($pkg_path) changed, adding app $app to build list"
              APPS_TO_BUILD+=("$app")
              break
            fi
          done
        done

        # Remove duplicates and create matrix
        UNIQUE_APPS=$(printf '%s\n' "${APPS_TO_BUILD[@]}" | sort -u | grep -v '^$')

        # Create matrix safely, handle empty case
        if [ -n "$UNIQUE_APPS" ]; then
          # Ensure jq is available and handle potential errors
          if command -v jq >/dev/null 2>&1; then
            MATRIX=$(echo "$UNIQUE_APPS" | jq -R -s -c 'split("\n")[:-1] | map({app: .})' 2>/dev/null || echo "[]")
            if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
              echo "‚ö†Ô∏è  jq matrix creation failed, using fallback format"
              MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
            fi
          else
            echo "‚ö†Ô∏è  jq not available, using fallback matrix format"
            MATRIX=$(echo "$UNIQUE_APPS" | sed 's/^/{"app":"/;s/$/"}/' | tr '\n' ',' | sed 's/,$//' | sed 's/^/[/;s/$/]/')
          fi
        else
          MATRIX="[]"
        fi

        # Save results to files for artifacts
        echo "$UNIQUE_APPS" > apps-to-build.txt
        echo "$MATRIX" > matrix.json

        echo "=== Debug Information ==="
        echo "Changed files:"
        echo "$CHANGED_FILES" | head -20
        echo "..."
        echo ""
        echo "All apps found:"
        echo "$APPS"
        echo ""
        echo "Apps to build: $UNIQUE_APPS"
        echo "Matrix: $MATRIX"

        # Validate outputs
        if [ -z "$UNIQUE_APPS" ]; then
          echo "‚ö†Ô∏è  Warning: No apps to build detected"
        else
          echo "‚úÖ Successfully detected apps to build: $UNIQUE_APPS"
        fi

        if [ "$MATRIX" = "[]" ] && [ -n "$UNIQUE_APPS" ]; then
          echo "‚ö†Ô∏è  Warning: Matrix is empty but apps were detected"
        else
          echo "‚úÖ Matrix created successfully: $MATRIX"
        fi

        # Exit successfully
        exit 0

    - name: Upload apps-to-build artifact
      uses: actions/upload-artifact@v4
      with:
        name: apps-to-build
        path: apps-to-build.txt
        retention-days: 1

    - name: Upload matrix artifact
      uses: actions/upload-artifact@v4
      with:
        name: matrix
        path: matrix.json
        retention-days: 1
